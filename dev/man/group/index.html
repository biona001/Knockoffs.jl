<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Group Knockoffs Â· Knockoffs.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Knockoffs.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../fixed/fixed/">Fixed-X Knockoffs</a></li><li><a class="tocitem" href="../modelX/modelX/">Model-X Knockoffs</a></li><li class="is-active"><a class="tocitem" href>Group Knockoffs</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Data-simulation"><span>Data simulation</span></a></li><li><a class="tocitem" href="#Gaussian-model-X-knockoffs-with-known-mean-and-covariance"><span>Gaussian model-X knockoffs with known mean and covariance</span></a></li><li class="toplevel"><a class="tocitem" href="#Define-group-memberships"><span>Define group memberships</span></a></li><li><a class="tocitem" href="#Generating-group-knockoffs"><span>Generating group knockoffs</span></a></li><li><a class="tocitem" href="#Second-order-group-knockoffs"><span>Second order group knockoffs</span></a></li><li><a class="tocitem" href="#Lasso-Example"><span>Lasso Example</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li><li><a class="tocitem" href="../fastphase_hmm/fastphase_hmm/">fastPHASE HMM Knockoffs</a></li><li><a class="tocitem" href="../shapeit_hmm/">SHAPEIT HMM Knockoffs</a></li><li><a class="tocitem" href="../knockoffscreen/knockoffscreen/">KnockoffScreen Knockoffs</a></li><li><a class="tocitem" href="../ghost_knockoffs/">Ghost Knockoffs</a></li><li><a class="tocitem" href="../JuliaCall/">Calling from R</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Group Knockoffs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Group Knockoffs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/biona001/Knockoffs.jl/blob/master/docs/src/man/group.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Group-Knockoffs"><a class="docs-heading-anchor" href="#Group-Knockoffs">Group Knockoffs</a><a id="Group-Knockoffs-1"></a><a class="docs-heading-anchor-permalink" href="#Group-Knockoffs" title="Permalink"></a></h1><p>This tutorial generates group (model-X) knockoffs, which is useful when predictors are highly correlated. The methodology is described in the following paper</p><blockquote><p>Dai R, Barber R. The knockoff filter for FDR control in group-sparse and multitask regression. InInternational conference on machine learning 2016 Jun 11 (pp. 1851-1859). PMLR.</p></blockquote><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the original paper, Dai and Barber only describes how to construct a suboptimal equi-correlated group knockoffs. Here we implement fully generalized alternatives.</p></div></div><p>Currently available options for group knockoffs:</p><ul><li><code>:mvr</code>: Fully general minimum variance-based reconstructability (MVR) group knockoff, based on coordinate descent.</li><li><code>:maxent</code>: Fully general maximum entropy (maxent) group knockoff, based on coordinate descent.</li><li><code>:equi</code>: This implements the equi-correlated idea proposed in <a href="https://proceedings.mlr.press/v48/daia16.html">Barber and Dai</a>, which lets <span>$S_j = \gamma \Sigma_{(G_j, G_j)}$</span> where <span>$\Sigma_{(G_j, G_j)}$</span> is the block of <span>$\Sigma$</span> containing variables in the <span>$j$</span>th group. Thus, instead of optimizing over all variables in <span>$S$</span>, we optimize a scalar <span>$\gamma$</span>. Conveniently, there a simple closed form solution for <span>$\gamma$</span>. For <code>mvr</code> and <code>maxent</code> group knockoffs, we initialize <span>$S$</span> using this construction. </li><li><code>:SDP</code>: This generalizes the equi-correlated group knockoff idea by having <span>$S_j = \gamma_j \Sigma_{(G_j, G_j)}$</span>. Instead of optimizing over all variables in <span>$S$</span>, we optimize over a vector <span>$\gamma_1,...,\gamma_G$</span>. </li></ul><pre><code class="language-julia hljs"># load packages for this tutorial
using Revise
using Knockoffs
using LinearAlgebra
using Random
using StatsBase
using Statistics
using ToeplitzMatrices
using Distributions
using Clustering
using ProgressMeter
using LowRankApprox
using Plots
gr(fmt=:png);</code></pre><pre><code class="nohighlight hljs">[36m[1m[ [22m[39m[36m[1mInfo: [22m[39mPrecompiling Knockoffs [878bf26d-0c49-448a-9df5-b057c815d613]</code></pre><h1 id="Data-simulation"><a class="docs-heading-anchor" href="#Data-simulation">Data simulation</a><a id="Data-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-simulation" title="Permalink"></a></h1><h2 id="Gaussian-model-X-knockoffs-with-known-mean-and-covariance"><a class="docs-heading-anchor" href="#Gaussian-model-X-knockoffs-with-known-mean-and-covariance">Gaussian model-X knockoffs with known mean and covariance</a><a id="Gaussian-model-X-knockoffs-with-known-mean-and-covariance-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-model-X-knockoffs-with-known-mean-and-covariance" title="Permalink"></a></h2><p>To illustrate, lets simulate data <span>$\mathbf{X}$</span> with covariance <span>$\Sigma$</span> and mean <span>$\mu$</span>. Our model is</p><p class="math-container">\[\begin{aligned}
    X_{p \times 1} \sim N(\mathbf{0}_p, \Sigma)
\end{aligned}\]</p><p>where</p><p class="math-container">\[\begin{aligned}
\Sigma = 
\begin{pmatrix}
    1 &amp; \rho &amp; \rho^2 &amp; ... &amp; \rho^p\\
    \rho &amp; 1 &amp; &amp; ... &amp; \rho^{p-1}\\
    \vdots &amp; &amp; &amp; 1 &amp; \vdots \\
    \rho^p &amp; \cdots &amp; &amp; &amp; 1
\end{pmatrix}
\end{aligned}\]</p><p>Given <span>$n$</span> iid samples from the above distribution, we will generate knockoffs according to </p><p class="math-container">\[\begin{aligned}
(X, \tilde{X}) \sim N
\left(0, \ 
\begin{pmatrix}
    \Sigma &amp; \Sigma - diag(s)\\
    \Sigma - diag(s) &amp; \Sigma
\end{pmatrix}
\right)
\end{aligned}\]</p><p>Because variables are highly correlated with its neighbors (<span>$\rho = 0.9$</span>), it becomes difficult to distinguish which among a bunch of highly correlated variables are truly causal. Thus, group knockoffs test whether a <em>group</em> of variables have any signal should have better power than standard (single-variable) knockoffs. </p><p>First, lets simulate some data</p><pre><code class="language-julia hljs"># simulate data
Random.seed!(2022)
m = 1
p = 500
k = 10
n = 250 # sample size
Î£ = Matrix(SymmetricToeplitz(0.9.^(0:(p-1)))) # true covariance matrix
Î¼ = zeros(p)
# Î£ = simulate_AR1(p, a=3, b=1) # true covariance matrix
# Î£ = simulate_block_covariance(groups, 0.75, 0.25)
L = cholesky(Î£).L
X = randn(n, p) * L
zscore!(X, mean(X, dims=1), std(X, dims=1)); # standardize columns of X</code></pre><h1 id="Define-group-memberships"><a class="docs-heading-anchor" href="#Define-group-memberships">Define group memberships</a><a id="Define-group-memberships-1"></a><a class="docs-heading-anchor-permalink" href="#Define-group-memberships" title="Permalink"></a></h1><p>To generate group knockoffs, we need to vector specifying group membership. One can define this vector manually, or use the built-in functions <a href="https://biona001.github.io/Knockoffs.jl/dev/man/api/#Knockoffs.hc_partition_groups">hc<em>partition</em>groups</a> or <a href="https://biona001.github.io/Knockoffs.jl/dev/man/api/#Knockoffs.id_partition_groups">id<em>partition</em>groups</a>. </p><pre><code class="language-julia hljs">groups = hc_partition_groups(X, cutoff = 0.5)</code></pre><pre><code class="nohighlight hljs">500-element Vector{Int64}:
  1
  1
  1
  2
  2
  2
  2
  3
  3
  3
  3
  3
  3
  â‹®
 92
 92
 92
 93
 93
 93
 93
 93
 93
 94
 94
 94</code></pre><h2 id="Generating-group-knockoffs"><a class="docs-heading-anchor" href="#Generating-group-knockoffs">Generating group knockoffs</a><a id="Generating-group-knockoffs-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-group-knockoffs" title="Permalink"></a></h2><p>Generate group knockoffs with the exported function <a href="https://biona001.github.io/Knockoffs.jl/dev/man/api/#Knockoffs.modelX_gaussian_group_knockoffs">modelX<em>gaussian</em>group_knockoffs</a>. Similar to non-group knockoffs, group knockoff accepts keyword arguments <code>m</code>, <code>tol</code>, <code>method</code>, and <code>verbose</code> which controls the algorithm&#39;s behavior. </p><pre><code class="language-julia hljs">@time Gme = modelX_gaussian_group_knockoffs(
    X, :maxent, groups, Î¼, Î£, 
    m = 1,          # number of knockoffs per variable to generate
    tol = 0.0001,   # convergence tolerance
    verbose=true);  # whether to print informative intermediate results</code></pre><pre><code class="nohighlight hljs">Maxent initial obj = -2365.1271671584636
Iter 1 (PCA): obj = -1943.045776513885, Î´ = 0.25150956170113037, t1 = 0.17, t2 = 0.07
Iter 2 (CCD): obj = -1884.7660301701906, Î´ = 0.031022028535121957, t1 = 0.21, t2 = 0.21, t3 = 0.0
Iter 3 (PCA): obj = -1867.744620087067, Î´ = 0.10436380706161898, t1 = 0.39, t2 = 0.28
Iter 4 (CCD): obj = -1858.078541301307, Î´ = 0.018488655084151602, t1 = 0.43, t2 = 0.41, t3 = 0.0
Iter 5 (PCA): obj = -1851.18883889653, Î´ = 0.05718304726075169, t1 = 0.59, t2 = 0.49
Iter 6 (CCD): obj = -1846.5094892606514, Î´ = 0.014731502428335617, t1 = 0.63, t2 = 0.62, t3 = 0.0
Iter 7 (PCA): obj = -1842.6854122257062, Î´ = 0.04959871535431794, t1 = 0.75, t2 = 0.69
Iter 8 (CCD): obj = -1839.6089892211846, Î´ = 0.012335539087343748, t1 = 0.8, t2 = 0.82, t3 = 0.0
Iter 9 (PCA): obj = -1837.360146695403, Î´ = 0.044938228762372016, t1 = 0.92, t2 = 0.89
Iter 10 (CCD): obj = -1835.1734755639154, Î´ = 0.010399754320591098, t1 = 0.97, t2 = 1.03, t3 = 0.0
Iter 11 (PCA): obj = -1833.7231336451528, Î´ = 0.03748376275692853, t1 = 1.1, t2 = 1.1
Iter 12 (CCD): obj = -1832.101288654608, Î´ = 0.008801047805283797, t1 = 1.14, t2 = 1.23, t3 = 0.0
Iter 13 (PCA): obj = -1831.102476063046, Î´ = 0.0315920226350087, t1 = 1.31, t2 = 1.3
Iter 14 (CCD): obj = -1829.8558917563043, Î´ = 0.007405521544014147, t1 = 1.35, t2 = 1.43, t3 = 0.0
Iter 15 (PCA): obj = -1829.1331764776448, Î´ = 0.027251705414512956, t1 = 1.54, t2 = 1.51
Iter 16 (CCD): obj = -1828.1467028977806, Î´ = 0.0062269999296655784, t1 = 1.59, t2 = 1.64, t3 = 0.0
Iter 17 (PCA): obj = -1827.601614884978, Î´ = 0.024021658879939404, t1 = 1.74, t2 = 1.72
Iter 18 (CCD): obj = -1826.8031717697318, Î´ = 0.005134406703349799, t1 = 1.78, t2 = 1.85, t3 = 0.01
Iter 19 (PCA): obj = -1826.3790649213395, Î´ = 0.021686121988716597, t1 = 2.1, t2 = 1.92
Iter 20 (CCD): obj = -1825.719663964593, Î´ = 0.004306407736902811, t1 = 2.14, t2 = 2.06, t3 = 0.01
Iter 21 (PCA): obj = -1825.3813405870092, Î´ = 0.020027352081161146, t1 = 2.33, t2 = 2.14
Iter 22 (CCD): obj = -1824.8287941270414, Î´ = 0.0036981896648250467, t1 = 2.37, t2 = 2.27, t3 = 0.01
Iter 23 (PCA): obj = -1824.5539111768705, Î´ = 0.018679609598580154, t1 = 2.51, t2 = 2.34
Iter 24 (CCD): obj = -1824.0855704567543, Î´ = 0.0033805757479844394, t1 = 2.55, t2 = 2.47, t3 = 0.01
Iter 25 (PCA): obj = -1823.8582217968954, Î´ = 0.017704569642057685, t1 = 2.72, t2 = 2.54
Iter 26 (CCD): obj = -1823.4570724075688, Î´ = 0.003093041667690277, t1 = 2.76, t2 = 2.67, t3 = 0.01
Iter 27 (PCA): obj = -1823.2668508565507, Î´ = 0.016636566975055, t1 = 2.89, t2 = 2.74
Iter 28 (CCD): obj = -1822.920750671551, Î´ = 0.002841438825057293, t1 = 2.93, t2 = 2.88, t3 = 0.01
Iter 29 (PCA): obj = -1822.7597639156436, Î´ = 0.015703113567105947, t1 = 3.1, t2 = 2.95
Iter 30 (CCD): obj = -1822.4586667077572, Î´ = 0.0026784317614699567, t1 = 3.14, t2 = 3.09, t3 = 0.01
Iter 31 (PCA): obj = -1822.3212257910723, Î´ = 0.014901519698466406, t1 = 3.29, t2 = 3.15
Iter 32 (CCD): obj = -1822.0577163477485, Î´ = 0.002525631519600995, t1 = 3.33, t2 = 3.29, t3 = 0.01
Iter 33 (PCA): obj = -1821.9392188180846, Î´ = 0.014156625934948678, t1 = 3.46, t2 = 3.35
Iter 34 (CCD): obj = -1821.7074829823384, Î´ = 0.002381575459035566, t1 = 3.5, t2 = 3.48, t3 = 0.01
Iter 35 (PCA): obj = -1821.6044312026802, Î´ = 0.01355257394079164, t1 = 3.7, t2 = 3.56
Iter 36 (CCD): obj = -1821.3998063817892, Î´ = 0.00227850010564236, t1 = 3.74, t2 = 3.69, t3 = 0.01
Iter 37 (PCA): obj = -1821.3096287409437, Î´ = 0.012940450253892096, t1 = 3.9, t2 = 3.76
Iter 38 (CCD): obj = -1821.128115245744, Î´ = 0.0022145104741294287, t1 = 3.94, t2 = 3.89, t3 = 0.01
  8.428074 seconds (1.26 M allocations: 124.370 MiB, 4.36% compilation time)</code></pre><p>Note <span>$t_1, t_2, t_3$</span> are timers which corresponds to (1) updating cholesky factors, (2) solving forward-backward equations, and (3) solving off-diagonal 1D optimization problems using Brent&#39;s method. As we can see, the computational bottleneck in (2), which we dispatch to efficient LAPACK libraries. </p><p>The output is a struct with the following fields</p><pre><code class="language-julia hljs">struct GaussianGroupKnockoff{T&lt;:AbstractFloat, BD&lt;:AbstractMatrix, S&lt;:Symmetric} &lt;: Knockoff
    X::Matrix{T} # n Ã— p design matrix
    XÌƒ::Matrix{T} # n Ã— mp matrix storing knockoffs of X
    groups::Vector{Int} # p Ã— 1 vector of group membership
    S::BD # p Ã— p block-diagonal matrix of the same size as Î£. S and (m+1)/m*Î£ - S are both psd
    Î³s::Vector{T} # for suboptimal group construction only. These are scalars chosen so that S_i = Î³_i * Î£_i
    m::Int # number of knockoffs per feature generated
    Î£::S # p Ã— p symmetric covariance matrix. 
    method::Symbol # method for solving s
    obj::T # final objective value of group knockoff
end</code></pre><p>Given this result, lets do a sanity check: is <span>$2\Sigma - S$</span> positive semi-definite?</p><pre><code class="language-julia hljs"># compute minimum eigenvalues of 2Î£ - S
eigmin(2Gme.Î£ - Gme.S)</code></pre><pre><code class="nohighlight hljs">0.04410255003113407</code></pre><h2 id="Second-order-group-knockoffs"><a class="docs-heading-anchor" href="#Second-order-group-knockoffs">Second order group knockoffs</a><a id="Second-order-group-knockoffs-1"></a><a class="docs-heading-anchor-permalink" href="#Second-order-group-knockoffs" title="Permalink"></a></h2><p>In practice, we often do not have the true covariance matrix <span>$\Sigma$</span> and the true means <span>$\mu$</span>. In that case, we can generate second order group knockoffs via the 3 argument function</p><pre><code class="language-julia hljs">Gme_second_order = modelX_gaussian_group_knockoffs(X, :maxent, groups);</code></pre><p>This will estimate the covariance matrix via a shrinkage estimator, see documentation API for more details. </p><h2 id="Lasso-Example"><a class="docs-heading-anchor" href="#Lasso-Example">Lasso Example</a><a id="Lasso-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Lasso-Example" title="Permalink"></a></h2><p>Lets see the empirical power and FDR group knockoffs over 10 simulations when</p><ul><li>the targer FDR is 10%</li><li>we generate <span>$m=5$</span> knockoffs per feature</li><li><p class="math-container">\[\beta_j \sim \pm 0.25\]</p>for <span>$10$</span> causal <span>$j$</span>s</li></ul><p>Note power and FDR is defined at the group level</p><pre><code class="language-julia hljs">group_powers, group_fdrs, group_times, group_s = Float64[], Float64[], Float64[], Float64[]

Random.seed!(2022)
for sim in 1:10
    # simulate X
    Random.seed!(sim)
    n = 1000 # sample size
    p = 200  # number of covariates
    k = 10   # number of true predictors
    Î£ = Matrix(SymmetricToeplitz(0.9.^(0:(p-1)))) # true covariance matrix
    Î¼ = zeros(p)
    L = cholesky(Î£).L
    X = randn(n, p) * L
    zscore!(X, mean(X, dims=1), std(X, dims=1)); # standardize columns of X

    # define groups
    groups = hc_partition_groups(X, cutoff=0.5)
    
    # simulate y
    Î²true = zeros(p)
    Î²true[1:k] .= rand(-1:2:1, k) .* 0.25
    shuffle!(Î²true)
    correct_groups = groups[findall(!iszero, Î²true)] |&gt; unique
    Ïµ = randn(n)
    y = X * Î²true + Ïµ;

    # group ME knockoffs
    t = @elapsed ko_filter = fit_lasso(y, X, method=:maxent, groups=groups, m=5)
    selected = ko_filter.selected[3]
    power = length(intersect(correct_groups, selected)) / length(correct_groups)
    fdr = length(setdiff(selected, correct_groups)) / max(1, length(selected))
    println(&quot;Sim $sim group-knockoff power = $power, FDR = $fdr, time=$t&quot;)
    push!(group_powers, power); push!(group_fdrs, fdr); push!(group_times, t)
    GC.gc();GC.gc();GC.gc();
end

println(&quot;\nME group knockoffs have average group power $(mean(group_powers))&quot;)
println(&quot;ME group knockoffs have average group FDR $(mean(group_fdrs))&quot;)
println(&quot;ME group knockoffs took average $(mean(group_times)) seconds&quot;);</code></pre><pre><code class="nohighlight hljs">Sim 1 group-knockoff power = 1.0, FDR = 0.1, time=6.71429675
Sim 2 group-knockoff power = 0.7777777777777778, FDR = 0.0, time=7.203738083
Sim 3 group-knockoff power = 0.8888888888888888, FDR = 0.1111111111111111, time=5.199876167
Sim 4 group-knockoff power = 0.8, FDR = 0.0, time=7.725970875
Sim 5 group-knockoff power = 0.7, FDR = 0.0, time=8.715202042
Sim 6 group-knockoff power = 0.5, FDR = 0.0, time=8.797519166
Sim 7 group-knockoff power = 1.0, FDR = 0.0, time=6.052631459
Sim 8 group-knockoff power = 0.4444444444444444, FDR = 0.0, time=8.221799459
Sim 9 group-knockoff power = 0.7, FDR = 0.0, time=9.489696541
Sim 10 group-knockoff power = 0.5555555555555556, FDR = 0.0, time=6.281113166

ME group knockoffs have average group power 0.7366666666666667
ME group knockoffs have average group FDR 0.021111111111111112
ME group knockoffs took average 7.4401843708 seconds</code></pre><p>For comparison, lets try the same simulation but we generate regular (non-grouped) knockoffs</p><pre><code class="language-julia hljs">regular_powers, regular_fdrs, regular_times = Float64[], Float64[], Float64[]

Random.seed!(2022)
for sim in 1:10
    # simulate X
    Random.seed!(sim)
    n = 1000 # sample size
    p = 200  # number of covariates
    k = 10   # number of true predictors
    Î£ = Matrix(SymmetricToeplitz(0.9.^(0:(p-1)))) # true covariance matrix
    Î¼ = zeros(p)
    L = cholesky(Î£).L
    X = randn(n, p) * L
    zscore!(X, mean(X, dims=1), std(X, dims=1)); # standardize columns of X
    
    # simulate y
    Î²true = zeros(p)
    Î²true[1:k] .= rand(-1:2:1, k) .* 0.25
    shuffle!(Î²true)
    correct_snps = findall(!iszero, Î²true)
    Ïµ = randn(n)
    y = X * Î²true + Ïµ;

    # group ME knockoffs
    t = @elapsed ko_filter = fit_lasso(y, X, method=:maxent, m=5)
    selected = ko_filter.selected[3]
    power = length(intersect(correct_snps, selected)) / length(correct_snps)
    fdr = length(setdiff(selected, correct_snps)) / max(1, length(selected))
    println(&quot;Sim $sim nongroup-knockoff power = $power, FDR = $fdr, time=$t&quot;)
    push!(regular_powers, power); push!(regular_fdrs, fdr); push!(regular_times, t)
    GC.gc();GC.gc();GC.gc();
end

println(&quot;\nME (standard) knockoffs have average group power $(mean(regular_powers))&quot;)
println(&quot;ME (standard) knockoffs have average group FDR $(mean(regular_fdrs))&quot;)
println(&quot;ME (standard) knockoffs took average $(mean(regular_times)) seconds&quot;);</code></pre><pre><code class="nohighlight hljs">Sim 1 nongroup-knockoff power = 0.7, FDR = 0.2222222222222222, time=5.165706875
Sim 2 nongroup-knockoff power = 0.7, FDR = 0.0, time=5.707978708
Sim 3 nongroup-knockoff power = 0.2, FDR = 0.0, time=4.334730542
Sim 4 nongroup-knockoff power = 0.0, FDR = 0.0, time=6.279638458
Sim 5 nongroup-knockoff power = 0.2, FDR = 0.0, time=7.839875459
Sim 6 nongroup-knockoff power = 0.0, FDR = 0.0, time=7.261292667
Sim 7 nongroup-knockoff power = 0.0, FDR = 0.0, time=4.292064292
Sim 8 nongroup-knockoff power = 0.0, FDR = 0.0, time=7.985766
Sim 9 nongroup-knockoff power = 0.4, FDR = 0.0, time=8.667096167
Sim 10 nongroup-knockoff power = 0.5, FDR = 0.0, time=5.635861

ME (standard) knockoffs have average group power 0.26999999999999996
ME (standard) knockoffs have average group FDR 0.02222222222222222
ME (standard) knockoffs took average 6.3170010168 seconds</code></pre><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><ul><li>When variables are highly correlated so that one cannot find exact discoveries, group knockoffs may be useful for improving power as it identifies whether a group of variables are non-null without having to pinpoint the exact discovery.</li><li>Group knockoffs control the group FDR to be below the target FDR level. </li><li>Groups do not have to be contiguous</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../modelX/modelX/">Â« Model-X Knockoffs</a><a class="docs-footer-nextpage" href="../fastphase_hmm/fastphase_hmm/">fastPHASE HMM Knockoffs Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 29 April 2023 02:31">Saturday 29 April 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
