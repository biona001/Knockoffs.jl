<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Knockoffs.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Knockoffs.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../fixed/fixed/">Fixed-X Knockoffs</a></li><li><a class="tocitem" href="../modelX/modelX/">Model-X Knockoffs</a></li><li><a class="tocitem" href="../group/">Group Knockoffs</a></li><li><a class="tocitem" href="../knockoffscreen/knockoffscreen/">KnockoffScreen Knockoffs</a></li><li><a class="tocitem" href="../ghost_knockoffs/">Ghost Knockoffs</a></li><li><a class="tocitem" href="../hmm/hmm/">HMM Knockoffs</a></li><li><a class="tocitem" href="../ipad/">IPAD Knockoffs</a></li><li><a class="tocitem" href="../JuliaCall/">Calling from R</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Generating-knockoffs"><span>Generating knockoffs</span></a></li><li><a class="tocitem" href="#Other-functions"><span>Other functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/biona001/Knockoffs.jl/blob/master/docs/src/man/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>Here is a list of available function calls. A detailed description can be found below. </p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Knockoffs.MK_statistics"><code>Knockoffs.MK_statistics</code></a></li><li><a href="#Knockoffs.approx_modelX_gaussian_knockoffs"><code>Knockoffs.approx_modelX_gaussian_knockoffs</code></a></li><li><a href="#Knockoffs.choose_group_reps"><code>Knockoffs.choose_group_reps</code></a></li><li><a href="#Knockoffs.fit_lasso"><code>Knockoffs.fit_lasso</code></a></li><li><a href="#Knockoffs.fit_marginal"><code>Knockoffs.fit_marginal</code></a></li><li><a href="#Knockoffs.fixed_knockoffs"><code>Knockoffs.fixed_knockoffs</code></a></li><li><a href="#Knockoffs.full_knockoffscreen"><code>Knockoffs.full_knockoffscreen</code></a></li><li><a href="#Knockoffs.ghost_knockoffs"><code>Knockoffs.ghost_knockoffs</code></a></li><li><a href="#Knockoffs.hc_partition_groups"><code>Knockoffs.hc_partition_groups</code></a></li><li><a href="#Knockoffs.hmm_knockoff"><code>Knockoffs.hmm_knockoff</code></a></li><li><a href="#Knockoffs.id_partition_groups"><code>Knockoffs.id_partition_groups</code></a></li><li><a href="#Knockoffs.ipad"><code>Knockoffs.ipad</code></a></li><li><a href="#Knockoffs.modelX_gaussian_group_knockoffs"><code>Knockoffs.modelX_gaussian_group_knockoffs</code></a></li><li><a href="#Knockoffs.modelX_gaussian_knockoffs"><code>Knockoffs.modelX_gaussian_knockoffs</code></a></li><li><a href="#Knockoffs.modelX_gaussian_rep_group_knockoffs"><code>Knockoffs.modelX_gaussian_rep_group_knockoffs</code></a></li><li><a href="#Knockoffs.normalize_col!"><code>Knockoffs.normalize_col!</code></a></li><li><a href="#Knockoffs.rapid"><code>Knockoffs.rapid</code></a></li><li><a href="#Knockoffs.simulate_AR1"><code>Knockoffs.simulate_AR1</code></a></li><li><a href="#Knockoffs.simulate_ER"><code>Knockoffs.simulate_ER</code></a></li><li><a href="#Knockoffs.solve_s"><code>Knockoffs.solve_s</code></a></li><li><a href="#Knockoffs.solve_s_graphical_group"><code>Knockoffs.solve_s_graphical_group</code></a></li><li><a href="#Knockoffs.solve_s_group"><code>Knockoffs.solve_s_group</code></a></li><li><a href="#Knockoffs.threshold"><code>Knockoffs.threshold</code></a></li></ul><h2 id="Generating-knockoffs"><a class="docs-heading-anchor" href="#Generating-knockoffs">Generating knockoffs</a><a id="Generating-knockoffs-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-knockoffs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.fixed_knockoffs" href="#Knockoffs.fixed_knockoffs"><code>Knockoffs.fixed_knockoffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fixed_knockoffs(X::Matrix{T}; [method], [kwargs...])</code></pre><p>Creates fixed-X knockoffs. Internally, <code>X</code> will be automatically normalized before computing its knockoff. </p><p><strong>Inputs</strong></p><ul><li><code>X</code>: A column-normalized <code>n × p</code> numeric matrix, each row is a sample, and   each column is covariate. We will internally normalized <code>X</code> if it is not. </li><li><code>method</code>: Can be one of the following<ul><li><code>:mvr</code>: Minimum variance-based reconstructability knockoffs (alg 1 in ref 2)</li><li><code>:maxent</code>: Maximum entropy knockoffs (alg 2 in ref 2)</li><li><code>:equi</code>: Equi-distant knockoffs (eq 2.3 in ref 1), </li><li><code>:sdp</code>: SDP knockoffs (eq 2.4 in ref 1)</li><li><code>:sdp_fast</code>: SDP knockoffs via coordiate descent (alg 2.2 in ref 3)</li></ul></li><li><code>kwargs...</code>: Possible optional inputs to <code>method</code>, see <a href="man/@ref"><code>solve_MVR</code></a>,    <a href="man/@ref"><code>solve_max_entropy</code></a>, and <a href="man/@ref"><code>solve_sdp_fast</code></a></li></ul><p><strong>Output</strong></p><ul><li><code>GaussianKnockoff</code>: A struct containing the original (column-normalized) <code>X</code>   and its knockoff <code>X̃</code>, in addition to other variables (e.g. <code>s</code>)</li></ul><p><strong>Reference</strong></p><ol><li>&quot;Controlling the false discovery rate via Knockoffs&quot; by Barber and Candes (2015).</li><li>&quot;Powerful knockoffs via minimizing reconstructability&quot; by Spector, Asher, and Lucas Janson (2020)</li><li>&quot;FANOK: Knockoffs in Linear Time&quot; by Askari et al. (2020).</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/fixed.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.modelX_gaussian_knockoffs" href="#Knockoffs.modelX_gaussian_knockoffs"><code>Knockoffs.modelX_gaussian_knockoffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modelX_gaussian_knockoffs(X::Matrix, method::Symbol; [m], [covariance_approximator], [kwargs...])
modelX_gaussian_knockoffs(X::Matrix, method::Symbol, μ::Vector, Σ::Matrix; [m], [kwargs...])</code></pre><p>Creates model-free multivariate normal knockoffs by sequentially sampling from  conditional multivariate normal distributions. The true mean <code>μ</code> and covariance <code>Σ</code> is estimated from data if not supplied. </p><p><strong>Inputs</strong></p><ul><li><code>X</code>: A <code>n × p</code> numeric matrix, each row is a sample, and each column is covariate.</li><li><code>method</code>: Can be one of the following<ul><li><code>:mvr</code> for minimum variance-based reconstructability knockoffs (alg 1 in ref 2)</li><li><code>:maxent</code> for maximum entropy knockoffs (alg 2 in ref 2)</li><li><code>:equi</code> for equi-distant knockoffs (eq 2.3 in ref 1), </li><li><code>:sdp</code> for SDP knockoffs (eq 2.4 in ref 1)</li><li><code>:sdp_ccd</code> for SDP knockoffs via coordiate descent (alg 2.2 in ref 3)</li></ul></li><li><code>μ</code>: A <code>p × 1</code> vector of column mean of <code>X</code>, defaults to column mean</li><li><code>Σ</code>: A <code>p × p</code> matrix of covariance of <code>X</code>, defaults to a shrinkage estimator   specified by <code>covariance_approximator</code>. </li><li><code>m</code>: Number of knockoff copies per variable to generate, defaults to 1. </li><li><code>covariance_approximator</code>: A covariance estimator, defaults to <code>LinearShrinkage(DiagonalUnequalVariance(), :lw)</code>   which tends to give good empirical performance when p&gt;n. See CovarianceEstimation.jl for more options.</li><li><code>kwargs...</code>: Possible optional inputs to solvers specified in <code>method</code>, see    <a href="man/@ref"><code>solve_MVR</code></a>, <a href="man/@ref"><code>solve_max_entropy</code></a>, and <a href="man/@ref"><code>solve_sdp_fast</code></a></li></ul><p><strong>Reference:</strong></p><ol><li>&quot;Panning for Gold: Model-X Knockoffs for High-dimensional Controlled  Variable Selection&quot; by Candes, Fan, Janson, and Lv (2018)</li><li>&quot;Powerful knockoffs via minimizing reconstructability&quot; by Spector, Asher, and Lucas Janson (2020)</li><li>&quot;FANOK: Knockoffs in Linear Time&quot; by Askari et al. (2020).</li></ol><p><strong>Covariance Approximation:</strong></p><p>The covariance is approximated by a linear shrinkage estimator using  Ledoit-Wolf with <code>DiagonalUnequalVariance</code> target,  which seems to perform well for <code>p&gt;n</code> cases. We do not simply use <code>cov(X)</code> since <code>isposdef(cov(X))</code> is typically false. For comparison of various estimators, see: https://mateuszbaran.github.io/CovarianceEstimation.jl/dev/man/msecomp/#msecomp</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/modelX.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.modelX_gaussian_group_knockoffs" href="#Knockoffs.modelX_gaussian_group_knockoffs"><code>Knockoffs.modelX_gaussian_group_knockoffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modelX_gaussian_group_knockoffs(X, method, groups, μ, Σ; [m], [nrep], [covariance_approximator])
modelX_gaussian_group_knockoffs(X, method, groups; [m], [nrep], [covariance_approximator])</code></pre><p>Constructs Gaussian model-X group knockoffs. If the covariance <code>Σ</code> and mean <code>μ</code>  are not specified, they will be estimated from data, i.e. we will make second-order group knockoffs. To incorporate group structure, the (true or estimated) covariance  matrix is block-diagonalized according to <code>groups</code> membership to solve a relaxed  optimization problem. See reference paper and Knockoffs.jl docs for more details. </p><p><strong>Inputs</strong></p><ul><li><code>X</code>: A <code>n × p</code> design matrix. Each row is a sample, each column is a feature.</li><li><code>method</code>: Method for constructing knockoffs. Options include<ul><li><code>:maxent</code>: (recommended) for fully general maximum entropy group knockoffs</li><li><code>:mvr</code>: for fully general minimum variance-based reconstructability (MVR) group    knockoffs (contrary to using <code>:maxent</code>, we don&#39;t do line search for MVR   group knockoffs because evaluating the objective is expensive)</li><li><code>:equi</code>: for equi-correlated knockoffs. This is the methodology proposed in   <code>Dai R, Barber R. The knockoff filter for FDR control in group-sparse and multitask regression.    International conference on machine learning 2016 Jun 11 (pp. 1851-1859). PMLR.</code></li><li><code>:sdp</code>: Fully general SDP group knockoffs based on coodinate descent</li><li><code>:sdp_block</code>: Fully general SDP group knockoffs where each block is solved exactly    using an interior point solver. </li><li><code>:sdp_subopt</code>: Chooses each block <code>S_{i} = γ_i * Σ_{ii}</code>. This slightly    generalizes the equi-correlated group knockoff idea proposed in Dai and Barber 2016.</li></ul></li><li><code>groups</code>: Vector of group membership</li><li><code>μ</code>: A length <code>p</code> vector storing the true column means of <code>X</code></li><li><code>Σ</code>: A <code>p × p</code> covariance matrix for columns of <code>X</code></li><li><code>m</code>: Number of knockoffs per variable, defaults to 1. </li><li><code>covariance_approximator</code>: A covariance estimator, defaults to    <code>LinearShrinkage(DiagonalUnequalVariance(), :lw)</code>. See CovarianceEstimation.jl    for more options.</li><li><code>kwargs</code>: Extra keyword arguments for <code>solve_s_group</code></li></ul><p><strong>How to define groups</strong></p><p>The exported functions <code>hc_partition_groups</code> and <code>id_partition_groups</code> can be used to build a group membership vector. </p><p><strong>A note on compute time</strong></p><p>The computational complexity of group knockoffs scales quadratically with group size. Thus, very large groups (e.g. &gt;100 members per group) dramatically slows down  parameter estimation. In such cases, one can consider running the routine  <code>modelX_gaussian_rep_group_knockoffs</code> which constructs group knockoffs by choosing top representatives from each group. </p><p><strong>Reference</strong></p><p>Dai &amp; Barber 2016, The knockoff filter for FDR control in group-sparse and multitask regression</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/group.jl#L46-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.modelX_gaussian_rep_group_knockoffs" href="#Knockoffs.modelX_gaussian_rep_group_knockoffs"><code>Knockoffs.modelX_gaussian_rep_group_knockoffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modelX_gaussian_rep_group_knockoffs(X, method, groups; [m], [covariance_approximator], [kwargs...])
modelX_gaussian_rep_group_knockoffs(X, method, groups, μ, Σ; [m], [kwargs...])</code></pre><p>Constructs group knockoffs by choosing representatives from each group and solving a smaller optimization problem based on the representatives only. Remaining knockoffs are generated based on a conditional independence assumption similar to a graphical model (details to be given later). The representatives are computed by <a href="#Knockoffs.choose_group_reps"><code>choose_group_reps</code></a></p><p><strong>Inputs</strong></p><ul><li><code>X</code>: A <code>n × p</code> design matrix. Each row is a sample, each column is a feature.</li><li><code>method</code>: Method for constructing knockoffs. Options are the same as    <code>modelX_gaussian_group_knockoffs</code></li><li><code>groups</code>: Vector of <code>Int</code> denoting group membership. <code>groups[i]</code> is the group    of <code>X[:, i]</code></li><li><code>covariance_approximator</code>: A covariance estimator, defaults to    <code>LinearShrinkage(DiagonalUnequalVariance(), :lw)</code>. See CovarianceEstimation.jl    for more options.</li><li><code>μ</code>: A length <code>p</code> vector storing the true column means of <code>X</code></li><li><code>Σ</code>: A <code>p × p</code> covariance matrix for columns of <code>X</code></li><li><code>rep_threshold</code>: Value between 0 and 1 that controls the number of    representatives per group. Larger means more representatives (default 0.5)</li><li><code>m</code>: Number of knockoffs per variable, defaults to 1. </li><li><code>kwargs</code>: Extra keyword arguments for <code>solve_s_group</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/group.jl#L128-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.approx_modelX_gaussian_knockoffs" href="#Knockoffs.approx_modelX_gaussian_knockoffs"><code>Knockoffs.approx_modelX_gaussian_knockoffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">approx_modelX_gaussian_knockoffs(X, method; [m=1], [windowsize = 500], [covariance_approximator], kwargs...)
approx_modelX_gaussian_knockoffs(X, method, window_ranges; [m=1], [covariance_approximator], kwargs...)</code></pre><p>Generates Gaussian knockoffs by approximating the covariance as a block diagonal matrix.  Each block contains <code>windowsize</code> consecutive features. One could alternatively  specify the <code>window_ranges</code> argument to construct blocks of different sizes. </p><p><strong>Inputs</strong></p><ul><li><code>X</code>: A <code>n × p</code> numeric matrix or <code>SnpArray</code>. Each row is a sample, and each column is covariate.</li><li><code>method</code>: Can be one of the following<ul><li><code>:mvr</code> for minimum variance-based reconstructability knockoffs (alg 1 in ref 2)</li><li><code>:maxent</code> for maximum entropy knockoffs (alg 2 in ref 2)</li><li><code>:equi</code> for equi-distant knockoffs (eq 2.3 in ref 1), </li><li><code>:sdp</code> for SDP knockoffs (eq 2.4 in ref 1)</li><li><code>:sdp_fast</code> for SDP knockoffs via coordiate descent (alg 2.2 in ref 3)</li></ul></li><li><code>m</code>: Number of knockoff copies per variable to generate, defaults to 1. </li><li><code>windowsize</code>: Number of covariates to be included in a block. Each block consists of   adjacent variables. The last block could contain less than <code>windowsize</code> variables. </li><li><code>window_ranges</code>: Vector of ranges for each window. e.g. [1:97, 98:200, 201:500]</li><li><code>covariance_approximator</code>: A covariance estimator, defaults to <code>LinearShrinkage(DiagonalUnequalVariance(), :lw)</code>.   See CovarianceEstimation.jl for more options.</li><li><code>kwargs...</code>: Possible optional inputs to solvers specified in <code>method</code>, see    <a href="man/@ref"><code>solve_MVR</code></a>, <a href="man/@ref"><code>solve_max_entropy</code></a>, and <a href="man/@ref"><code>solve_sdp_fast</code></a></li></ul><p><strong>Multithreading (todo)</strong></p><p>To enable multiple threads, simply start Julia with &gt;1 threads and this routine will run with all available threads. </p><p><strong>Covariance Approximation:</strong></p><p>The covariance is approximated by a <code>LinearShrinkageEstimator</code> using  Ledoit-Wolf shrinkage with <code>DiagonalUnequalVariance</code> target,  which seems to perform well for <code>p&gt;n</code> cases. We do not simply use <code>cov(X)</code> since <code>isposdef(cov(X))</code> is typically false. For comparison of different estimators, see: https://mateuszbaran.github.io/CovarianceEstimation.jl/dev/man/msecomp/#msecomp</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/approx.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.hmm_knockoff" href="#Knockoffs.hmm_knockoff"><code>Knockoffs.hmm_knockoff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hmm_knockoff(plinkname; [datadir], [plink_outfile], [fastphase_outfile], [outdir], [verbose], args...)</code></pre><p>Generates HMM knockoffs from binary PLINK formatted files. This is done by first running fastPHASE, then running Algorithm 2 of &quot;Gene hunting with hidden Markov model knockoffs&quot; by Sesia, Sabatti, and Candes</p><p><strong>Input</strong></p><ul><li><code>plinkname</code>: Binary PLINK file names without the <code>.bed/.bim/.fam</code> suffix. </li></ul><p><strong>Optional arguments</strong></p><ul><li><code>datadir</code>: Full path to the PLINK and fastPHASE files (default = current directory)</li><li><code>plink_outfile</code>: Output PLINK format name</li><li><code>fastphase_outfile</code>: The output file name from fastPHASE&#39;s alpha, theta, r files</li><li><code>args...</code>: Any parameter that accepted in <code>fastPHASE.fastphase_estim_param()</code></li></ul><p><strong>Output</strong></p><ul><li><code>plink_outfile.bed</code>: <code>n × p</code> knockoff genotypes</li><li><code>plink_outfile.bim</code>: SNP mapping file. Knockoff have SNP names ending in &quot;.k&quot;</li><li><code>plink_outfile.fam</code>: Sample mapping file, this is a copy of the original <code>plinkname.fam</code> file</li><li><code>fastphase_outfile_rhat.txt</code>: averaged r hat file from fastPHASE</li><li><code>fastphase_outfile_alphahat.txt</code>: averaged alpha hat file from fastPHASE</li><li><code>fastphase_outfile_thetahat.txt</code>: averaged theta hat file from fastPHASE</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/experimental/hmm.jl#L255-L278">source</a></section><section><div><pre><code class="nohighlight hljs">hmm_knockoff(snpdata::SnpData, r::AbstractVecOrMat, θ::AbstractMatrix, α::AbstractMatrix)</code></pre><p>Generates knockoff of <code>snpdata</code> with loaded r, θ, α</p><p><strong>Input</strong></p><ul><li><code>SnpData</code>: A <code>SnpData</code> object from SnpArrays</li><li><code>r</code>: The r vector estimated by fastPHASE</li><li><code>θ</code>: The θ matrix estimated by fastPHASE</li><li><code>α</code>: The α matrix estimated by fastPHASE</li></ul><p><strong>Optional Inputs</strong></p><ul><li><code>outdir</code>: Output directory for generated knockoffs</li><li><code>plink_outfile</code>: Output file name for knockoff genotypes</li><li><code>estimate_δ</code>: If true, will estimate pseudo-FDR by computing a δ value    for each SNP via likelihood ratio bound</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/experimental/hmm.jl#L310-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.full_knockoffscreen" href="#Knockoffs.full_knockoffscreen"><code>Knockoffs.full_knockoffscreen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">full_knockoffscreen(x::SnpArray; windowsize::Int=100)</code></pre><p>Generates knockoffs <code>X̃ⱼ</code> by on regressing <code>Xⱼ</code> on SNPs knockoffs within a sliding window of width <code>windowsize</code>. </p><p><strong>Inputs</strong></p><ul><li><code>x</code>: A <code>SnpArray</code> or <code>String</code> for the path of the PLINK <code>.bed</code> file</li><li><code>windowsize</code>: <code>Int</code> specifying window width. Defaults to 100</li></ul><p><strong>Outputs</strong></p><ul><li><code>X̃</code>: A <code>n × p</code> dense matrix of <code>Float64</code>, each row is a sample.</li></ul><p><strong>References</strong></p><ul><li>He, Zihuai, Linxi Liu, Chen Wang, Yann Le Guen, Justin Lee, Stephanie Gogarten, Fred Lu et al. &quot;Identification of putative causal loci in whole-genome sequencing data via knockoff statistics.&quot; Nature communications 12, no. 1 (2021): 1-18.</li><li>He, Zihuai, Yann Le Guen, Linxi Liu, Justin Lee, Shiyang Ma, Andrew C. Yang, Xiaoxia Liu et al. &quot;Genome-wide analysis of common and rare variants via multiple knockoffs at biobank scale, with an application to Alzheimer disease genetics.&quot; The American Journal of Human Genetics 108, no. 12 (2021): 2336-2353.</li></ul><p><strong>TODO</strong></p><ul><li>Use <code>ElasticArrays.jl</code> to avoid reallocating design matrix in each loop</li><li>Write iterator interface to avoid allocating and storing all knockoffs at once</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/knockoffscreen.jl#L31-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.ghost_knockoffs" href="#Knockoffs.ghost_knockoffs"><code>Knockoffs.ghost_knockoffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ghost_knockoffs(Zscores, D, Σinv; [m=1])
ghost_knockoffs(Zscores, Z_pos, H_pos, H, method; [windowsize], [covariance_approximator], [kwargs])</code></pre><p>Generate Ghost knockoffs given a list of z-scores (GWAS summary statistic). </p><p><strong>Inputs</strong></p><ul><li><code>Zscores</code>: List of z-score statistics</li><li><code>D</code>: Matrix obtained from solving the knockoff problem satisfying    <code>(m+1)/m*Σ - D ⪰ 0</code></li><li><code>Σinv</code>: Inverse of the covariance matrix</li><li><code>Z_pos</code>: A sorted list of SNP position for each SNP in <code>Zscores</code></li><li><code>H_pos</code>: A sorted list of SNP position in the reference panel <code>H</code></li><li><code>H</code>: A haplotype reference panel. Each row is a sample and each column is a variant.</li><li><code>method</code>: Can be any of the method in <a href="#Knockoffs.approx_modelX_gaussian_knockoffs"><code>approx_modelX_gaussian_knockoffs</code></a></li><li><code>windowsize</code>: Number of covariates to be included in a block. Each block consists of   adjacent variables. The last block could contain less than <code>windowsize</code> variables. </li><li><code>covariance_approximator</code>: A covariance estimator, defaults to    <code>LinearShrinkage(DiagonalUnequalVariance(), :lw)</code>. See    CovarianceEstimation.jl for more options.</li><li><code>kwargs...</code>: Possible optional inputs to solvers specified in <code>method</code>, see    <a href="man/@ref"><code>solve_MVR</code></a>, <a href="man/@ref"><code>solve_max_entropy</code></a>, and <a href="man/@ref"><code>solve_sdp_fast</code></a></li></ul><p><strong>optional inputs</strong></p><ul><li><code>m</code>: Number of knockoffs</li></ul><p><strong>Reference</strong></p><p>He, Z., Liu, L., Belloy, M. E., Le Guen, Y., Sossin, A., Liu, X., ... &amp; Ionita-Laza, I. (2021).  Summary statistics knockoff inference empowers identification of putative causal variants in  genome-wide association studies. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/ghost.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.ipad" href="#Knockoffs.ipad"><code>Knockoffs.ipad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ipad(X::Matrix; [r_method], [m])</code></pre><p>Generates knockoffs based on intertwined probabilitistic factors decoupling (IPAD). This assumes that <code>X</code> can be factored as <code>X = FΛ&#39; + E</code> where <code>F</code> is a <code>n × r</code> random matrix of latent factors, <code>Λ</code> are factor loadings, and <code>E</code> are residual errors. When this assumption is met, FDR can be controlled with no power loss when applying the knockoff procedure. Internally, we need to compute an eigenfactorization for a <code>n × n</code> matrix. This is often faster than standard model-X knockoffs which requires solving <code>p</code>-dimensional convex optimization problem.</p><p><strong>Inputs</strong></p><ul><li><code>X</code>: A <code>n × p</code> numeric matrix, each row is a sample, and each column is covariate.</li><li><code>r_method</code>: Method used for estimating <code>r</code>, the number of latent factors.    Choices include <code>:er</code> (default), <code>:gr</code>, or <code>:ve</code></li><li><code>m</code>: Number of (simultaneous) knockoffs per variable to generate, default <code>m=1</code></li></ul><p><strong>References</strong></p><ul><li>Fan, Y., Lv, J., Sharifvaghefi, M. and Uematsu, Y., 2020. IPAD: stable interpretable forecasting with knockoffs inference. Journal of the American Statistical Association, 115(532), pp.1822-1834.</li><li>Bai, J., 2003. Inferential theory for factor models of large dimensions. Econometrica, 71(1), pp.135-171.</li><li>Ahn, S.C. and Horenstein, A.R., 2013. Eigenvalue ratio test for the number of factors. Econometrica, 81(3), pp.1203-1227.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/ipad.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.solve_s" href="#Knockoffs.solve_s"><code>Knockoffs.solve_s</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve_s(Σ::Symmetric, method::Symbol; m=1, kwargs...)</code></pre><p>Solves the vector <code>s</code> for generating knockoffs. <code>Σ</code> can be a general  covariance matrix but it must be wrapped in the <code>Symmetric</code> keyword. </p><p><strong>Inputs</strong></p><ul><li><code>Σ</code>: A covariance matrix (one must wrap <code>Symmetric(Σ)</code> explicitly)</li><li><code>method</code>: Can be one of the following<ul><li><code>:mvr</code> for minimum variance-based reconstructability knockoffs (alg 1 in ref 2)</li><li><code>:maxent</code> for maximum entropy knockoffs (alg 2 in ref 2)</li><li><code>:equi</code> for equi-distant knockoffs (eq 2.3 in ref 1), </li><li><code>:sdp</code> for SDP knockoffs (eq 2.4 in ref 1)</li><li><code>:sdp_ccd</code> fast SDP knockoffs via coordiate descent (alg 2.2 in ref 3)</li><li><code>kwargs...</code>: Possible optional inputs to <code>method</code>, see <a href="man/@ref"><code>solve_MVR</code></a>,    <a href="man/@ref"><code>solve_max_entropy</code></a>, and <a href="man/@ref"><code>solve_sdp_ccd</code></a></li></ul></li><li><code>m</code>: Number of knockoffs per variable, defaults to 1. </li><li><code>kwargs</code>: Extra arguments available for specific methods. For example, to use    less stringent convergence tolerance for MVR knockoffs, specify <code>tol = 0.001</code>.</li></ul><p><strong>Reference</strong></p><ol><li>&quot;Controlling the false discovery rate via Knockoffs&quot; by Barber and Candes (2015).</li><li>&quot;Powerful knockoffs via minimizing reconstructability&quot; by Spector, Asher, and Lucas Janson (2020)</li><li>&quot;FANOK: Knockoffs in Linear Time&quot; by Askari et al. (2020).</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/utilities.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.solve_s_group" href="#Knockoffs.solve_s_group"><code>Knockoffs.solve_s_group</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve_s_group(Σ, groups, method; [m=1], kwargs...)</code></pre><p>Solves the group knockoff problem, returns block diagonal matrix S satisfying <code>(m+1)/m*Σ - S ⪰ 0</code> where <code>m</code> is number of knockoffs per feature. </p><p><strong>Inputs</strong></p><ul><li><code>Σ</code>: A general covariance matrix wrapped by <code>Symmetric</code> keyword</li><li><code>groups</code>: Vector of group membership, does not need to be contiguous</li><li><code>method</code>: Method for constructing knockoffs. Options include<ul><li><code>:maxent</code>: (recommended) for fully general maximum entropy group knockoffs</li><li><code>:mvr</code>: for fully general minimum variance-based reconstructability (MVR) group    knockoffs (contrary to using <code>:maxent</code>, we don&#39;t do line search for MVR   group knockoffs because evaluating the objective is expensive)</li><li><code>:equi</code>: for equi-correlated knockoffs. This is the methodology proposed in   <code>Dai R, Barber R. The knockoff filter for FDR control in group-sparse and multitask regression.    International conference on machine learning 2016 Jun 11 (pp. 1851-1859). PMLR.</code></li><li><code>:sdp</code>: Fully general SDP group knockoffs based on coodinate descent</li><li><code>:sdp_subopt</code>: Chooses each block <code>S_{i} = γ_i * Σ_{ii}</code>. This slightly    generalizes the equi-correlated group knockoff idea proposed in Dai and Barber 2016.</li><li><code>:sdp_block</code>: Fully general SDP group knockoffs where each block is solved exactly    using an interior point solver. </li></ul></li><li><code>m</code>: Number of knockoffs per variable, defaults to 1. </li><li><code>kwargs</code>: Extra arguments available for specific methods. For example, to use    less stringent convergence tolerance for MVR knockoffs, specify <code>tol = 0.001</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>S</code>: A matrix solved so that <code>(m+1)/m*Σ - S ⪰ 0</code> and <code>S ⪰ 0</code></li><li><code>γ</code>: A vector that is only non-empty for equi and suboptimal knockoff constructions.    They correspond to values of γ where <code>S_{gg} = γΣ_{gg}</code>. So for equi, the   vector is length 1. For SDP, the vector has length equal to number of groups</li><li><code>obj</code>: Final SDP/MVR/ME objective value given <code>S</code>. Equi-correlated group knockoffs   and singleton (non-grouped knockoffs) returns 0 because they either no objective    value or it is not necessary to evaluate the objectives</li></ul><p><strong>Warning</strong></p><p>This function potentially permutes the columns/rows of <code>Σ</code>, and puts them back at the end. Thus one should NOT call <code>solve_s_group</code> on the same <code>Σ</code> simultaneously, e.g. in a multithreaded for loop. Permutation does not happen when groups are contiguous. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/group.jl#L304-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.solve_s_graphical_group" href="#Knockoffs.solve_s_graphical_group"><code>Knockoffs.solve_s_graphical_group</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve_s_graphical_group(Σ::Symmetric, groups::Vector{Int}, group_reps::Vector{Int},
method; [m], [verbose])</code></pre><p>Solves the group knockoff problem but the convex optimization problem only runs on the representatives. The non-representative variables are assumed to be  independent by groups when conditioning on the reprensetatives. </p><p><strong>Inputs</strong></p><ul><li><code>Σ</code>: Symmetric <code>p × p</code> covariance matrix</li><li><code>groups</code>: <code>p</code> dimensional vector of group membership</li><li><code>group_reps</code>: Indices for the representatives. </li><li><code>method</code>: Method for solving group knockoff problem</li><li><code>m</code>: Number of knockoffs to generate per feature</li><li><code>verbose</code>: Whether to print informative intermediate results</li><li><code>kwargs...</code>: extra arguments for <a href="#Knockoffs.solve_s_group"><code>solve_s_group</code></a></li></ul><p><strong>Outputs</strong></p><ul><li><code>S</code>: Matrix obtained from solving the optimization problem on the representatives.</li><li><code>D</code>: A <code>p × p</code> (dense) matrix corresponding to the S matrix for both the   representative and non-representative variables. Knockoff sampling should    use this matrix. If the graphical conditional independent assumption is    satisfied exactly, this matrix should be sparse, but it is always never sparse   unless we use <code>cond_indep_corr</code> to force the covariance matrix to satisify it. </li><li><code>obj</code>: Objective value for solving the optimization problem on the representatives. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/group.jl#L238-L263">source</a></section></article><h2 id="Other-functions"><a class="docs-heading-anchor" href="#Other-functions">Other functions</a><a id="Other-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.threshold" href="#Knockoffs.threshold"><code>Knockoffs.threshold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">threshold(w::AbstractVector, q::Number, [method=:knockoff], [m::Int=1])</code></pre><p>Chooses a threshold τ &gt; 0 by choosing <code>τ</code> to be one of the following τ = min{ t &gt; 0 : {#j: w[j] ≤ -t} / {#j: w[j] ≥ t} ≤ q }        (<code>method=:knockoff</code>) τ = min{ t &gt; 0 : (1 + {#j: w[j] ≤ -t}) / {#j: w[j] ≥ t} ≤ q }  (<code>method=:knockoff</code>)</p><p><strong>Inputs</strong></p><ul><li><code>w</code>: Vector of feature important statistics</li><li><code>q</code>: target FDR (between 0 and 1)</li><li><code>method</code>: either <code>:knockoff</code> or <code>:knockoff_plus</code> (default)</li></ul><p><strong>Reference:</strong></p><p>Equation 3.10 (<code>method=:knockoff</code>) or 3.11 (<code>method=:knockoff_plus</code>) of  &quot;Panning for Gold: Model-X Knockoffs for High-dimensional Controlled Variable Selection&quot; by Candes, Fan, Janson, and Lv (2018)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/threshold.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.MK_statistics" href="#Knockoffs.MK_statistics"><code>Knockoffs.MK_statistics</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MK_statistics(T0::Vector, Tk::Vector{Vector}; filter_method)</code></pre><p>Computes the multiple knockoff statistics kappa, tau, and W. </p><p><strong>Inputs</strong></p><ul><li><code>T0</code>: p-vector of importance score for original variables</li><li><code>Tk</code>: Vector storing T1, ..., Tm, where Ti is importance scores for    the <code>i</code>th knockoff copy</li><li><code>filter_method</code>: Either <code>Statistics.median</code> (default) or max (original    function used in 2019 Gimenez and Zou)</li></ul><p><strong>output</strong></p><ul><li><code>κ</code>: Index of the most significant feature (<code>κ[i] = 0</code> if original feature most    important, otherwise <code>κ[i] = k</code> if the <code>k</code>th knockoff is most important)</li><li><code>τ</code>: <code>τ[i]</code> stores the most significant statistic among original and knockoff   variables minus <code>filter_method()</code> applied to the remaining statistics. </li><li><code>W</code>: coefficient difference statistic <code>W[i] = abs(T0[i]) - abs(Tk[i])</code>     </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/threshold.jl#L71-L89">source</a></section><section><div><pre><code class="nohighlight hljs">MK_statistics(T0::Vector, Tk::Vector)</code></pre><p>Compute regular knockoff statistics tau and W. </p><p><strong>Inputs</strong></p><ul><li><code>T0</code>: p-vector of importance score for original variables</li><li><code>Tk</code>: p-vector of importance score for knockoff variables</li></ul><p><strong>output</strong></p><ul><li><code>W</code>: coefficient difference statistic <code>W[i] = abs(T0[i]) - abs(Tk[i])</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/threshold.jl#L116-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.hc_partition_groups" href="#Knockoffs.hc_partition_groups"><code>Knockoffs.hc_partition_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hc_partition_groups(X::AbstractMatrix; [cutoff], [min_clusters], [force_contiguous])
hc_partition_groups(Σ::Symmetric; [cutoff], [min_clusters], [force_contiguous])</code></pre><p>Computes a group partition based on individual level data <code>X</code> or correlation  matrix <code>Σ</code> using hierarchical clustering with specified linkage. </p><p><strong>Inputs</strong></p><ul><li><code>X</code>: <code>n × p</code> data matrix. Each row is a sample</li><li><code>Σ</code>: <code>p × p</code> correlation matrix. Must be wrapped in the <code>Symmetric</code> argument,   otherwise we will treat it as individual level data</li><li><code>cutoff</code>: Height value for which the clustering result is cut, between 0 and 1   (default 0.5). This ensures that no variables between 2 groups have correlation   greater than <code>cutoff</code>. 1 recovers ungrouped structure, 0 corresponds to    everything in a single group. </li><li><code>min_clusters</code>: The desired number of clusters. </li><li><code>linkage</code>: <em>cluster linkage</em> function to use (when <code>force_contiguous=true</code>,    <code>linkage</code> must be <code>:single</code>). <code>linkage</code> defines how the    distances between the data points are aggregated into the distances between    the clusters. Naturally, it affects what clusters are merged on each    iteration. The valid choices are:<ul><li><code>:single</code> (default): use the minimum distance between any of the cluster members</li><li><code>:average</code>: use the mean distance between any of the cluster members</li><li><code>:complete</code>: use the maximum distance between any of the members</li><li><code>:ward</code>: the distance is the increase of the average squared distance of a   point to its cluster centroid after merging the two clusters</li><li><code>:ward_presquared</code>: same as <code>:ward</code>, but assumes that the distances in d    are already squared.</li></ul></li><li><code>rep_method</code>: Method for selecting representatives for each group. Options are   <code>:id</code> (tends to select roughly independent variables) or <code>:rss</code> (tends to   select more correlated variables)</li></ul><p>If <code>force_contiguous = false</code> and both <code>min_clusters</code> and <code>cutoff</code> are specified,  it is guaranteed that the number of clusters is not less than <code>min_clusters</code> and their height is not above <code>cutoff</code>. If <code>force_contiguous = true</code>, <code>min_clusters</code> keyword is ignored. </p><p><strong>Outputs</strong></p><ul><li><code>groups</code>: Length <code>p</code> vector of group membership for each variable</li><li><code>group_reps</code>: Columns of X selected as representatives. Each group have at    most <code>nrep</code> representatives. These are typically used to construct smaller   group knockoff for extremely large groups</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/group.jl#L1711-L1753">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.id_partition_groups" href="#Knockoffs.id_partition_groups"><code>Knockoffs.id_partition_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">id_partition_groups(X::AbstractMatrix; [rss_target], [force_contiguous])
id_partition_groups(Σ::Symmetric; [rss_target], [force_contiguous])</code></pre><p>Compute group members based on interpolative decompositions. An initial pass  first selects the most representative features such that regressing each  non-represented feature on the selected will have residual less than <code>rss_target</code>. The selected features are then defined as group centers and the remaining  features are assigned to groups</p><p><strong>Inputs</strong></p><ul><li><code>G</code>: Either individual level data <code>X</code> or a correlation matrix <code>Σ</code>. If one   inputs <code>Σ</code>, it must be wrapped in the <code>Symmetric</code> argument, otherwise   we will treat it as individual level data</li><li><code>rss_target</code>: Target residual level (greater than 0) for the first pass, smaller   means more groups</li><li><code>force_contiguous</code>: Whether groups are forced to be contiguous. If true,   variants are assigned its left or right center, whichever   has the largest correlation with it without breaking contiguity.</li></ul><p><strong>Outputs</strong></p><ul><li><code>groups</code>: Length <code>p</code> vector of group membership for each variable</li></ul><p>Note: interpolative decomposition is a stochastic algorithm. Set a seed to guarantee reproducible results. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/group.jl#L1661-L1686">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.choose_group_reps" href="#Knockoffs.choose_group_reps"><code>Knockoffs.choose_group_reps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">choose_group_reps(Σ::Symmetric, groups::AbstractVector; threshold=0.5)
choose_group_reps(X::AbstractMatrix, groups::AbstractVector; threshold=0.5)</code></pre><p>Chooses group representatives. If R is the set of selected variables within a group and O is the set of variables outside the group, then we keep adding variables to R until the proportion of variance explained by R divided by the proportion of variance explained by R and O exceeds <code>threshold</code>. </p><p><strong>Inputs</strong></p><ul><li>First argument: Either individual level data <code>X</code> or the correlation matrix <code>Σ</code>.   If one inputs <code>Σ</code>, it must be wrapped in the <code>Symmetric</code> argument.</li><li><code>groups</code>: Vector of group membership. </li><li><code>threshold</code>: Value between 0 and 1 that controls the number of    representatives per group. Larger means more representatives (default 0.5)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/group.jl#L1849-L1864">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.fit_lasso" href="#Knockoffs.fit_lasso"><code>Knockoffs.fit_lasso</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit_lasso(y, X, method=:maxent, ...)
fit_lasso(y, X, μ, Σ, method=:maxent, ...)</code></pre><p>Generates model-X knockoffs with <code>method</code>, runs Lasso, then applies the  knockoff-filter. If <code>μ</code> and <code>Σ</code> are not provided, they will be estimated from data. </p><p><strong>Inputs</strong></p><ul><li><code>y</code>: A <code>n × 1</code> response vector</li><li><code>X</code>: A <code>n × p</code> numeric matrix, each row is a sample, and each column is covariate.</li><li><code>method</code>: Method for knockoff generation (defaults to <code>:maxent</code>)</li><li><code>μ</code>: A <code>p × 1</code> vector of column mean of <code>X</code>. If not provided, defaults to column mean.</li><li><code>Σ</code>: A <code>p × p</code> covariance matrix of <code>X</code>. If not provided, it will be estimated    based on a shrinked empirical covariance matrix, see <a href="#Knockoffs.modelX_gaussian_knockoffs"><code>modelX_gaussian_knockoffs</code></a></li><li><code>d</code>: Distribution of response. Defaults <code>Normal()</code>, for binary response   (logistic regression) use <code>Binomial()</code>.</li><li><code>m</code>: Number of simultaneous knockoffs to generate, defaults to <code>m=1</code></li><li><code>fdrs</code>: Target FDRs, defaults to <code>[0.01, 0.05, 0.1, 0.25, 0.5]</code></li><li><code>groups</code>: Vector of group membership. If not supplied, we generate regular knockoffs.   If supplied, we run group knockoffs.</li><li><code>filter_method</code>: Choices are <code>:knockoff</code> or <code>:knockoff_plus</code> (default) </li><li><code>debias</code>: Defines how the selected coefficients are debiased. Specify <code>:ls</code>    for least squares or <code>:lasso</code> for Lasso (only running on the    support). To not debias, specify <code>debias=nothing</code> (default).</li><li><code>kwargs</code>: Additional arguments to input into <code>glmnetcv</code> and <code>glmnet</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/fit_lasso.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.fit_marginal" href="#Knockoffs.fit_marginal"><code>Knockoffs.fit_marginal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit_marginal(y, X, method=:maxent, ...)
fit_marginal(y, X, μ, Σ, method=:maxent, ...)</code></pre><p>Generates model-X knockoffs with <code>method</code> and computes feature importance statistics based on squared marginal Z score: abs2(x[:, i]^t*y) / n. If <code>μ</code> and <code>Σ</code> are not provided, they will be estimated from data. </p><p><strong>Inputs</strong></p><ul><li><code>y</code>: A <code>n × 1</code> response vector</li><li><code>X</code>: A <code>n × p</code> numeric matrix, each row is a sample, and each column is covariate.</li><li><code>method</code>: Method for knockoff generation (defaults to <code>:maxent</code>)</li><li><code>μ</code>: A <code>p × 1</code> vector of column mean of <code>X</code>. If not provided, defaults to column mean.</li><li><code>Σ</code>: A <code>p × p</code> covariance matrix of <code>X</code>. If not provided, it will be estimated    based on a shrinked empirical covariance matrix, see <a href="#Knockoffs.modelX_gaussian_knockoffs"><code>modelX_gaussian_knockoffs</code></a></li><li><code>d</code>: Distribution of response. Defaults <code>Normal()</code>, for binary response   (logistic regression) use <code>Binomial()</code>.</li><li><code>m</code>: Number of simultaneous knockoffs to generate, defaults to <code>m=1</code></li><li><code>fdrs</code>: Target FDRs, defaults to <code>[0.01, 0.05, 0.1, 0.25, 0.5]</code></li><li><code>groups</code>: Vector of group membership. If not supplied, we generate regular knockoffs.   If supplied, we run group knockoffs.</li><li><code>filter_method</code>: Choices are <code>:knockoff</code> or <code>:knockoff_plus</code> (default) </li><li><code>debias</code>: Defines how the selected coefficients are debiased. Specify <code>:ls</code>    for least squares or <code>:lasso</code> for Lasso (only running on the    support). To not debias, specify <code>debias=nothing</code> (default).</li><li><code>kwargs</code>: Additional arguments to input into <code>glmnetcv</code> and <code>glmnet</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/fit_lasso.jl#L154-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.simulate_AR1" href="#Knockoffs.simulate_AR1"><code>Knockoffs.simulate_AR1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_AR1(p::Int, a=1, b=1, tol=1e-3, max_corr=1, rho=nothing)</code></pre><p>Generates <code>p</code>-dimensional correlation matrix for AR(1) Gaussian process, where successive correlations are drawn from Beta(<code>a</code>,<code>b</code>) independently. If <code>rho</code> is specified, then the process is stationary with correlation <code>rho</code>.</p><p><strong>Source</strong></p><p>https://github.com/amspector100/knockpy/blob/20eddb3eb60e0e82b206ec989cb936e3c3ee7939/knockpy/dgp.py#L61</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/utilities.jl#L334-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.simulate_ER" href="#Knockoffs.simulate_ER"><code>Knockoffs.simulate_ER</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_ER(p::Int; [invert])</code></pre><p>Simulates a covariance matrix from a clustered Erdos-Renyi graph, which is a block diagonal matrix where each block is an Erdo-Renyi graph. The result is scaled back to a correlation matrix. </p><p>For details, see the 4th simulation routine in section 5.1 of Li and Maathius  https://academic.oup.com/jrsssb/article/83/3/534/7056103?login=false</p><p><strong>Inputs</strong></p><ul><li><code>p</code>: Dimension of covariance matrix</li><li><code>ϕ</code>: Probability of forming an edge between any 2 nodes</li><li><code>lb</code>: lower bound for the value of an edge (drawn from uniform distribution)</li><li><code>ub</code>: upper bound for the value of an edge (drawn from uniform distribution)</li><li><code>invert</code>: Whther to invert the covariance matrix (to obtain the precision)</li><li><code>λmin</code>: minimum eigenvalue of the resulting covariance matrix</li><li><code>blocksize</code>: Number of variables within each ER graph. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/utilities.jl#L371-L389">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>simulate_block_covariance</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.normalize_col!" href="#Knockoffs.normalize_col!"><code>Knockoffs.normalize_col!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_col!(X::AbstractVecOrMat)</code></pre><p>Normalize each column of <code>X</code> so they sum to 1. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/utilities.jl#L485-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knockoffs.rapid" href="#Knockoffs.rapid"><code>Knockoffs.rapid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rapid(rapid_exe, vcffile, mapfile, d, outfolder, w, r, s, [a])</code></pre><p>Wrapper for the RaPID program. </p><p><strong>Inputs</strong></p><ul><li><code>rapid_exe</code>: Full path to the <code>RaPID_v.1.7</code> executable file</li><li><code>vcffile</code>: Phased VCF file name</li><li><code>mapfile</code>: Map file name</li><li><code>d</code>: Actual Minimum IBD length in cM</li><li><code>outfolder</code>: Output folder name</li><li><code>w</code>: Number of SNPs in a window for sub-sampling</li><li><code>r</code>: Number of runs</li><li><code>s</code>: Minimum number of successes to consider a hit</li></ul><p><strong>Optional Inputs</strong></p><ul><li><code>a</code>: If <code>true</code>, ignore MAFs. By default (<code>a=false</code>) the sites are selected at random weighted by their MAFs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/biona001/Knockoffs.jl/blob/bc91f9870d6260f5d674937403df057c5cae9103/src/experimental/hmm_wrapper.jl#L12-L29">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../JuliaCall/">« Calling from R</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 3 June 2023 02:47">Saturday 3 June 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
