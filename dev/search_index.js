var documenterSearchIndex = {"docs":
[{"location":"man/fastphase_hmm/fastphase_hmm/#fastPHASE-HMM-knockoffs","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM knockoffs","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"This is a tutorial for generating (fastPHASE) HMM knockoffs for genome-wide association studies. This kind of knockoffs is suitable for data without population admixture or cryptic relatedness. The methodology is described in the following paper:","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Sesia, Matteo, Chiara Sabatti, and Emmanuel J. Candès. \"Gene hunting with hidden Markov model knockoffs.\" Biometrika 106.1 (2019): 1-18.","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"If your samples have diverse ancestries and/or extensive relatedness, we recommend those samples to be filtered out, or use SHAPEIT-HMM knockoffs.","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# first load packages needed for this tutorial\nusing Revise\nusing SnpArrays\nusing Knockoffs\nusing Statistics\nusing Plots\nusing GLMNet\nusing Distributions\nusing Random\ngr(fmt=:png);","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Step-0:-Prepare-example-data","page":"fastPHASE HMM Knockoffs","title":"Step 0: Prepare example data","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"To illustrate we need example PLINK data, which are available in Knockoffs.jl/data","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"test.(bed/bim/fam) are simulated genotypes without missings\nmouse.imputed.(bed/bim/fam) are real genotypes without missing","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# Path to PLINK data\ndata_path = joinpath(normpath(Knockoffs.datadir()), \"test\")","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"\"/Users/biona001/.julia/dev/Knockoffs/data/test\"","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Step-1:-Generate-Knockoffs","page":"fastPHASE HMM Knockoffs","title":"Step 1: Generate Knockoffs","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Knockoffs are made using the wrapper function hmm_knockoff. This function does 3 steps sequentially:","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Run fastPHASE on mathbfX_ntimes p to estimate alpha theta r (this step takes 5-10 min for the example data)\nFit and generate knockoff copies of the HMM \nStore knockoffs tildemathbfX_ntimes p in binary PLINK format (by default under a new directory called knockoffs) and return it as a SnpArray","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"@time X̃ = hmm_knockoff(data_path, plink_outfile=\"test.fastphase.knockoffs\")","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"seed = 1652154851\n\nThis is fastPHASE 1.4.8\n\nCopyright 2005-2006.  University of Washington. All rights reserved.\nWritten by Paul Scheet, with algorithm developed by Paul Scheet and\nMatthew Stephens in the Department of Statistics at the University of\nWashington.  Please contact pscheet@alum.wustl.edu for questions, or to\nobtain the software visit\nhttp://stephenslab.uchicago.edu/software.html\n\nTotal proportion of missing genotypes: 0.000000\n1000 diploids below missingness threshold, 0 haplotypes\n data read successfully\n1000 diploid individuals, 10000 loci\n\nK selected (by user): \t\t 12\nseed: \t\t\t 1\nno. EM starts: \t\t 1\nEM iterations: \t\t 10\nno. haps from posterior: 0\nNOT using subpopulation labels\n\n\n this is random start no. 1 of 1 for the EM...\n\nseed for this start: 1\n-12448937.79229315\n-9445075.64492578\n-8349084.94704032\n-7261896.43613014\n-6281741.47324536\n-5576823.19655063\n-5155151.87406101\n-4928193.53344398\n-4802495.92350104\n-4725979.88580363\nfinal loglikelihood: -4676003.575106\niterations: 10\n\nwriting parameter estimates to disk\n\n  simulating 0 haplotype configurations for each individual... done.\n\n\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:02:45\u001b[39m\n\n\n\n\nsimulating 0 haplotypes from model: knockoffs/tmp1_hapsfrommodel.out\n554.600068 seconds (124.71 M allocations: 6.023 GiB, 0.35% gc time, 4.53% compilation time)\n\n\n\n\n\n1000×10000 SnpArray:\n 0x00  0x00  0x02  0x03  0x02  0x02  …  0x03  0x03  0x03  0x02  0x03  0x02\n 0x00  0x02  0x03  0x03  0x02  0x00     0x02  0x02  0x02  0x00  0x00  0x02\n 0x00  0x00  0x02  0x03  0x02  0x02     0x03  0x03  0x00  0x00  0x02  0x02\n 0x00  0x00  0x00  0x00  0x00  0x02     0x02  0x02  0x02  0x02  0x00  0x00\n 0x00  0x00  0x02  0x02  0x02  0x02     0x02  0x00  0x00  0x00  0x03  0x03\n 0x00  0x00  0x03  0x03  0x02  0x02  …  0x03  0x03  0x02  0x02  0x02  0x00\n 0x00  0x00  0x03  0x03  0x00  0x03     0x03  0x00  0x02  0x02  0x03  0x03\n 0x02  0x02  0x03  0x02  0x00  0x02     0x03  0x03  0x02  0x00  0x02  0x02\n 0x02  0x00  0x02  0x02  0x00  0x02     0x03  0x03  0x02  0x02  0x00  0x03\n 0x00  0x03  0x02  0x03  0x03  0x02     0x03  0x03  0x03  0x00  0x00  0x02\n 0x00  0x02  0x02  0x03  0x03  0x02  …  0x03  0x03  0x03  0x03  0x00  0x02\n 0x02  0x02  0x02  0x02  0x00  0x00     0x02  0x02  0x02  0x00  0x02  0x00\n 0x00  0x00  0x03  0x03  0x02  0x02     0x02  0x02  0x02  0x00  0x00  0x00\n    ⋮                             ⋮  ⋱           ⋮                    \n 0x00  0x00  0x03  0x02  0x02  0x00     0x03  0x03  0x03  0x02  0x02  0x00\n 0x00  0x02  0x02  0x03  0x03  0x03     0x03  0x02  0x03  0x02  0x03  0x03\n 0x02  0x02  0x03  0x03  0x03  0x02  …  0x03  0x00  0x00  0x00  0x03  0x03\n 0x00  0x00  0x02  0x03  0x03  0x02     0x03  0x02  0x02  0x02  0x03  0x03\n 0x02  0x00  0x00  0x00  0x02  0x02     0x02  0x00  0x00  0x00  0x03  0x03\n 0x00  0x00  0x02  0x02  0x02  0x03     0x02  0x03  0x02  0x02  0x02  0x02\n 0x03  0x03  0x03  0x03  0x02  0x00     0x03  0x02  0x03  0x03  0x03  0x02\n 0x00  0x00  0x02  0x02  0x02  0x00  …  0x03  0x02  0x02  0x00  0x02  0x03\n 0x02  0x02  0x02  0x02  0x00  0x00     0x03  0x03  0x03  0x02  0x00  0x03\n 0x00  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x02  0x02\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x02  0x02  0x00  0x02  0x02\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x03  0x02","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Optional-parameters","page":"fastPHASE HMM Knockoffs","title":"Optional parameters","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Here are some optional parameters one can tune when fitting the HMM procedure. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"K: Number of haplotype clusters. Defaults to 12\nC: Number of EM iterations before convergence. Defaults to 10.\nn: Number of samples used to fit HMM in fastPHASE. Defaults to using all samples","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"They can be specified via:","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"@time X̃ = hmm_knockoff(\n    data_file,\n    plink_outfile=\"test.fastphase.knockoffs\",\n    K = 12,\n    C = 10,\n    n = 100)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Step-2:-Examine-knockoff-statistics","page":"fastPHASE HMM Knockoffs","title":"Step 2: Examine knockoff statistics","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Lets check if the knockoffs \"make sense\". We will use SnpArrays.jl to import the original and knockoff genotypes, and compare summary statistics using built-in functions comparepairwisecorrelation and compare_correlation","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# import original and knockoff genotypes\nX = SnpArray(data_path * \".bed\")\nX̃ = SnpArray(\"knockoffs/test.fastphase.knockoffs.bed\")\nn, p = size(X̃)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"(1000, 10000)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Lets compare cor(X_i X_j) and cor(X_i tildeX_j). If knockoffs satisfy exchangability, their correlation should be very similar and form a diagonal line. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# look at only pairwise correlation between first 200 snps\nr1, r2 = compare_pairwise_correlation(X, X̃, snps=200)\n\n# make plot\nscatter(r1, r2, xlabel = \"cor(Xi, Xj)\", ylabel=\"cor(Xi, X̃j)\", legend=false)\nPlots.abline!(1, 0, line=:dash)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Plots distribution of cor(X_j tildeX_j) for all j. Ideally, we want cor(X_j tildeX_j) to be small in magnitude (i.e. X and tildeX is very different). Here the knockoffs are tightly correlated with the original genotypes, so they will likely have low power. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"r2 = compare_correlation(X, X̃)\nhistogram(r2, legend=false, xlabel=\"cor(Xi, X̃i)\", ylabel=\"count\")","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#LASSO-example","page":"fastPHASE HMM Knockoffs","title":"LASSO example","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Let us apply the generated knockoffs to the model selection problem","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Given response mathbfy_n times 1, design matrix mathbfX_n times p, we want to select a subset S subset 1p of variables that are truly causal for mathbfy. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Simulate-data","page":"fastPHASE HMM Knockoffs","title":"Simulate data","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"We will simulate ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"mathbfy_n times 1 sim N(mathbfX_n times pmathbfbeta_p times 1    mathbfepsilon_n times 1) quad epsilon_i sim N(0 1)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"where k=50 positions of mathbfbeta is non-zero with effect size beta_j sim N(0 1). The goal is to recover those 50 positions using LASSO.","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# set seed for reproducibility\nRandom.seed!(1111)\n\n# simulate true beta\nn, p = size(X)\nk = 50\nβtrue = zeros(p)\nβtrue[1:k] .= randn(k)\nshuffle!(βtrue)\n\n# find true causal variables\ncorrect_position = findall(!iszero, βtrue)\n\n# simulate y\ny = X * βtrue + randn(n)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"1000-element Vector{Float64}:\n -7.523748950079584\n -5.870529819964483\n -0.5742132199848955\n  2.1309132557501718\n -1.6879497296254022\n  6.303519372510508\n -5.802636275728736\n  4.326923276536526\n -1.0412802760571847\n -8.041827059609703\n  5.499043516471697\n -7.052572319910739\n -0.7269822409994189\n  ⋮\n -8.64616507915174\n  9.75520485123946\n -4.741610543782101\n  0.19476116174706148\n -6.907628164727042\n  4.074654461857484\n -0.8816816975311048\n -4.477392544345892\n -0.9657429191845255\n -2.6017256381373777\n  3.599329780486735\n -8.028131783786595","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Standard-LASSO","page":"fastPHASE HMM Knockoffs","title":"Standard LASSO","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Lets try running standard LASSO, which will produce hatmathbfbeta_p times 1 where we typically declare SNP j to be selected if hatbeta_j ne 0. We use LASSO solver in GLMNet.jl package, which is just a Julia wrapper for the GLMnet Fortran code. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"How well does LASSO perform in terms of power and FDR?","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# run 10-fold cross validation to find best λ minimizing MSE\nlasso_cv = glmnetcv(X, y)\nλbest = lasso_cv.lambda[argmin(lasso_cv.meanloss)]\n\n# use λbest to fit LASSO on full data\nβlasso = glmnet(X, y, lambda=[λbest]).betas[:, 1]\n\n# check power and false discovery rate\npower = length(findall(!iszero, βlasso) ∩ correct_position) / k\nFDR = length(setdiff(findall(!iszero, βlasso), correct_position)) / count(!iszero, βlasso)\n\n#summarize\ncount(!iszero, βlasso), power, FDR","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"(348, 0.9, 0.8706896551724138)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Observe that","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"LASSO found a total of 348 SNPs\nLASSO found 90% of all true predictors\nFalse discovery rate is 87%, meaning that 303/348 discovered predictors are false positives. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#KnockoffLASSO","page":"fastPHASE HMM Knockoffs","title":"Knockoff+LASSO","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Now lets try applying the knockoff methodology. Recall that consists of a few steps ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Run LASSO on mathbfX mathbftildeX\nCompare feature importance score W_j = textscore(x_j) - textscore(tildex_j) for each j = 1p. Here we use W_j = beta_j - tildebeta_j\nChoose target FDR 0 le q le 1 and compute ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"tau = min_tleftt  0 fracj W_j  -tj W_j  t le qright","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"note: Note\nIn step 1, mathbfX mathbftildeX is written for notational convenience. In practice one must interleave knockoffs with the original variables, where either the knockoff come first or the original genotype come first with equal probability. This is due to the inherent bias of LASSO solvers: when the original and knockoff variable are equally valid, the one listed first will be selected. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# interleave knockoffs with originals\nXfull, original, knockoff = merge_knockoffs_with_original(data_path,\n    \"knockoffs/test.fastphase.knockoffs\",\n    des=\"knockoffs/merged\") \nXfull = convert(Matrix{Float64}, Xfull, center=true, scale=true)\n\n# step 1\nknockoff_cv = glmnetcv(Xfull, y)                         # cross validation step\nλbest = knockoff_cv.lambda[argmin(knockoff_cv.meanloss)] # find lambda that minimizes MSE\nβestim = glmnet(Xfull, y, lambda=[λbest]).betas[:, 1]    # refit lasso with best lambda\n\n# target FDR is 0.05, 0.1, ..., 0.5\nFDR = collect(0.05:0.05:0.5)\nempirical_power = Float64[]\nempirical_fdr = Float64[]\nfor fdr in FDR\n    βknockoff = extract_beta(βestim, fdr, original, knockoff) # steps 2-3 happen here\n\n    # compute power and false discovery proportion\n    power = length(findall(!iszero, βknockoff) ∩ correct_position) / k\n    fdp = length(setdiff(findall(!iszero, βknockoff), correct_position)) / max(count(!iszero, βknockoff), 1)\n    push!(empirical_power, power)\n    push!(empirical_fdr, fdp)\nend\n\n# visualize FDR and power\npower_plot = plot(FDR, empirical_power, xlabel=\"Target FDR\", ylabel=\"Empirical power\", legend=false)\nfdr_plot = plot(FDR, empirical_fdr, xlabel=\"Target FDR\", ylabel=\"Empirical FDR\", legend=false)\nPlots.abline!(fdr_plot, 1, 0, line=:dash)\nplot(power_plot, fdr_plot)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Observe that","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"LASSO + knockoffs controls the false discovery rate at approximately the target (dashed line). If we repeat the simulation multiple times, the empirical FDR should average out to be slightly below the target level.\nThe power of LASSO + knockoffs is lower than standard LASSO","category":"page"},{"location":"man/modelX/modelX/#Model-X-knockoffs","page":"Model-X Knockoffs","title":"Model-X knockoffs","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"This tutorial is for generating model-X knockoffs, which handles cases where covariates outnumber sample size (p  n). The methodology is described in the following paper","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Candes E, Fan Y, Janson L, Lv J. Panning for gold:‘model‐X’knockoffs for high dimensional controlled variable selection. Journal of the Royal Statistical Society: Series B (Statistical Methodology). 2018 Jun;80(3):551-77.","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"# load packages needed for this tutorial\nusing Knockoffs\nusing Plots\nusing Random\nusing GLMNet\nusing Distributions\nusing LinearAlgebra\nusing ToeplitzMatrices\nusing StatsBase\ngr(fmt=:png);","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"┌ Info: Precompiling Knockoffs [878bf26d-0c49-448a-9df5-b057c815d613]\n└ @ Base loading.jl:1423","category":"page"},{"location":"man/modelX/modelX/#Gaussian-model-X-knockoffs-with-known-mean-and-covariance","page":"Model-X Knockoffs","title":"Gaussian model-X knockoffs with known mean and covariance","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"To illustrate, lets simulate data mathbfX with covariance Sigma and mean mu. Our model is","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"beginaligned\n    X_p times 1 sim N(mathbf0_p Sigma)\nendaligned","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"where","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"beginaligned\nSigma = \nbeginpmatrix\n    1  rho  rho^2    rho^p\n    rho  1     rho^p-1\n    vdots    1  vdots \n    rho^p  cdots    1\nendpmatrix\nendaligned","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Given n iid samples from the above distribution, we will generate knockoffs according to ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"beginaligned\n(X tildeX) sim N\nleft(0  \nbeginpmatrix\n    Sigma  Sigma - diag(s)\n    Sigma - diag(s)  Sigma\nendpmatrix\nright)\nendaligned","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"where s is solved so that 0 le s_j for all j and 2Σ - diag(s) is PSD","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Random.seed!(2022)\nn = 100 # sample size\np = 500 # number of covariates\nρ = 0.4\nΣ = Matrix(SymmetricToeplitz(ρ.^(0:(p-1)))) # true covariance matrix\nμ = zeros(p) # true mean parameters\nL = cholesky(Σ).L\nX = randn(n, p) * L # var(X) = L var(N(0, 1)) L' = var(Σ)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"100×500 Matrix{Float64}:\n -0.877527   -1.30346    -0.682964   …  -0.350442   -2.05031    -1.19774\n  1.94981     0.625748   -0.157094       0.328944   -0.50083    -1.77715\n -0.372347   -0.0577255  -0.545009       2.04892     0.447051   -0.172137\n  0.281239   -1.2314     -2.25883       -0.863995   -1.29658    -1.69292\n -1.94197    -0.514252   -0.126406       1.58385    -0.508209   -0.576327\n  0.32584     1.29406    -0.944499   …   0.336041    0.834595    1.01313\n  0.312506   -0.892288   -1.28543        0.656042   -0.727716   -0.062318\n -0.130798    0.080975   -1.00406        0.140716   -0.0171299   0.0520695\n -1.37595    -1.7559     -0.965395       0.475523    0.476843    0.0988572\n  1.17982     1.1271      1.29655       -1.16738    -1.72623    -0.848002\n  0.328697    0.674708    1.08453    …   0.886085   -0.405945   -0.190064\n -0.155799    0.740727    0.0747548      0.694317    0.483984    0.791628\n -2.03164    -0.90797    -1.57553        2.3821      1.89785     0.318261\n  ⋮                                  ⋱                          \n -0.950099   -1.38457     0.158824      -0.187195    1.70564     1.20939\n  0.236699   -0.22054    -0.852487       0.44721    -1.06464     1.19481\n -0.409184    0.393978    0.894276   …  -0.603513   -0.0926733  -0.979548\n -0.20095    -0.200403   -1.76704       -0.151618    0.0987953   1.35385\n -0.366858    0.719476    0.234908      -0.245508   -0.321876   -0.420004\n -0.232295    0.305845   -0.494038       0.910901    1.67494    -0.114834\n  0.712566    0.86745     1.08866       -0.161063   -1.05527    -0.604559\n -0.413006    0.322623    0.152769   …  -0.438893    0.731315   -0.398558\n  0.0977592  -0.301898    0.0328142      1.17656     0.45638     0.232298\n  0.988324   -0.698384   -0.436609      -0.466774   -0.0569571  -0.499042\n  0.132829    0.26532     1.60743        0.955361   -0.626877   -0.242588\n -0.525434   -0.854175    0.170717       0.0667342  -2.16955    -0.63145","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"To generate knockoffs, the 4 argument function modelX_gaussian_knockoffs will generate exact model-X knockoffs. The 2nd argument specifies the method to generate knockoffs. We generally recommend :mvr or :maxent because they are more efficient to compute and tend to be more powerful than the SDP construction. The 3rd and 4th argument supplies the true mean and covariance of features.","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"@time mvr = modelX_gaussian_knockoffs(X, :mvr, μ, Σ);","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"  2.798276 seconds (60 allocations: 19.917 MiB)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"The return type is a GaussianKnockoff struct, which contains the following fields","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"struct GaussianKnockoff{T}\n    X::Matrix{T}    # n × p original design matrix\n    X̃::Matrix{T}    # n × p knockoff of X\n    s::Vector{T}    # p × 1 vector. Diagonal(s) and 2Σ - Diagonal(s) are both psd\n    Σ::Matrix{T}    # p × p gram matrix X'X\n    method::Symbol # :sdp or :equi\nend","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Thus, to access these fields, one can do e.g.","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"s = mvr.s","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"500-element Vector{Float64}:\n 0.7055837242604751\n 0.550599643132556\n 0.5579633308207883\n 0.5578990459757974\n 0.5578830358745579\n 0.5578842779646905\n 0.557884239188223\n 0.557884238362934\n 0.5578842385242271\n 0.5578842385157536\n 0.557884238515875\n 0.5578842385158908\n 0.5578842385158888\n ⋮\n 0.5578842369066758\n 0.5578842348979732\n 0.5578842398872369\n 0.5578842817258655\n 0.5578843495474255\n 0.5578842071395308\n 0.5578843562366876\n 0.5578830621807336\n 0.557899089676546\n 0.5579633702735248\n 0.5505996786150799\n 0.7055838005026086","category":"page"},{"location":"man/modelX/modelX/#Second-order-knockoffs","page":"Model-X Knockoffs","title":"Second order knockoffs","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"The 2 argument modelX_gaussian_knockoffs will estimate the mean and covariance of X and use them to generate model-X knockoffs","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"# make 2nd order knockoffs\n@time mvr_2nd_order = modelX_gaussian_knockoffs(X, :mvr);","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"  1.382837 seconds (110 allocations: 30.624 MiB)","category":"page"},{"location":"man/modelX/modelX/#Approximate-construction-for-speed","page":"Model-X Knockoffs","title":"Approximate construction for speed","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Generating model-X knockoffs scales as mathcalO(p^3) with coordinate descent (e.g. sdp_fast, mvr, maxent), which becomes prohibitively slow for large p (e.g. p = 5000). ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Sometimes one expects that covariates are only correlated with its nearby neighbors. Then, we can approximate the covariance matrix as a block diagonal structure with block size windowsize, and solve each block independently as smaller problems. This is implemented as approx_modelX_gaussian_knockoffs","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"@time mvr_approx = approx_modelX_gaussian_knockoffs(X, :mvr, windowsize=100);","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"  0.866715 seconds (2.40 M allocations: 192.950 MiB, 28.64% gc time)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"We can compare the s vector estimated from all 3 methods.","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"[mvr.s mvr_2nd_order.s mvr_approx.s]","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"500×3 Matrix{Float64}:\n 0.705584  0.765939  0.663288\n 0.5506    0.809084  0.697905\n 0.557963  1.04366   0.921062\n 0.557899  0.86139   0.761527\n 0.557883  0.911251  0.79024\n 0.557884  0.978194  0.861529\n 0.557884  0.919028  0.801033\n 0.557884  0.738538  0.667032\n 0.557884  0.867094  0.766879\n 0.557884  0.85405   0.741398\n 0.557884  0.719779  0.643368\n 0.557884  1.17217   1.0488\n 0.557884  0.827193  0.71336\n ⋮                   \n 0.557884  0.817115  0.692749\n 0.557884  0.991195  0.855441\n 0.557884  0.604032  0.534393\n 0.557884  0.67311   0.593851\n 0.557884  0.867172  0.765961\n 0.557884  0.877053  0.784296\n 0.557884  0.962095  0.843415\n 0.557883  1.09807   0.955454\n 0.557899  0.929814  0.821244\n 0.557963  0.961874  0.833571\n 0.5506    0.868214  0.779083\n 0.705584  0.685257  0.598158","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"In this example, they are quite different.","category":"page"},{"location":"man/modelX/modelX/#LASSO-example","page":"Model-X Knockoffs","title":"LASSO example","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Let us apply the generated knockoffs to the model selection problem","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Given response mathbfy_n times 1, design matrix mathbfX_n times p, we want to select a subset S subset 1p of variables that are truly causal for mathbfy. ","category":"page"},{"location":"man/modelX/modelX/#Simulate-data","page":"Model-X Knockoffs","title":"Simulate data","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"We will simulate ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"mathbfy sim N(mathbfXmathbfbeta mathbfepsilon) quad mathbfepsilon sim N(0 1)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"where k=50 positions of mathbfbeta is non-zero with effect size beta_j sim N(0 1). The goal is to recover those 50 positions using LASSO.","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"# set seed for reproducibility\nRandom.seed!(123)\n\n# simulate true beta\nn, p = size(X)\nk = 50\nβtrue = zeros(p)\nβtrue[1:k] .= randn(50)\nshuffle!(βtrue)\n\n# find true causal variables\ncorrect_position = findall(!iszero, βtrue)\n\n# simulate y\ny = X * βtrue + randn(n)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"100-element Vector{Float64}:\n  10.430304834810704\n   9.430844234150014\n   2.41106568009123\n  14.925207979666721\n  -8.743596474193751\n   5.775257576204118\n  -1.5879969409798689\n  13.60514062643101\n -18.781349632593468\n   7.855239413947383\n  -5.738117008161742\n  -4.631197619265103\n -11.89784179331142\n   ⋮\n -10.887325590058023\n  13.949139924153949\n  -2.5416321952957093\n   3.1895938123917964\n   1.0637262185056753\n  -7.626490623432156\n   1.8563101020426087\n   1.0666016246401202\n  -7.242249824299234\n  -3.2289570492580526\n   4.014480647244053\n   4.832304427120105","category":"page"},{"location":"man/modelX/modelX/#Standard-LASSO","page":"Model-X Knockoffs","title":"Standard LASSO","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Lets try running standard LASSO. We use LASSO solver in GLMNet.jl package, which is just a Julia wrapper for the GLMnet Fortran code. ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"How does it perform in power and FDR?","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"# run 10-fold cross validation to find best λ minimizing MSE\nlasso_cv = glmnetcv(X, y)\nλbest = lasso_cv.lambda[argmin(lasso_cv.meanloss)]\n\n# use λbest to fit LASSO on full data\nβlasso = glmnet(X, y, lambda=[λbest]).betas[:, 1]\n\n# check power and false discovery rate\npower = length(findall(!iszero, βlasso) ∩ correct_position) / k\nFDR = length(setdiff(findall(!iszero, βlasso), correct_position)) / count(!iszero, βlasso)\nprintln(\"Lasso power = $power, FDR = $FDR\")","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Lasso power = 0.54, FDR = 0.7","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"More than half of all Lasso discoveries are false positives. ","category":"page"},{"location":"man/modelX/modelX/#KnockoffLASSO","page":"Model-X Knockoffs","title":"Knockoff+LASSO","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Now lets try applying the knockoff methodology. Recall that consists of a few steps ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Run LASSO on mathbfX mathbftildeX\nCompare feature importance score W_j = textscore(x_j) - textscore(tildex_j) for each j = 1p. Here we use W_j = beta_j - tildebeta_j\nChoose target FDR q in 0 1 and compute ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"tau = min_tleftt  0 fracj W_j  -tmax(1 j W_j  t) le qright","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"note: Note\nIn step 1, mathbfX mathbftildeX is written for notational convenience. In practice one must interleave knockoffs with the original variables, where either the knockoff come first or the original genotype come first with equal probability. This is due to the inherent bias of LASSO solvers: when the original and knockoff variable are equally valid, the one listed first will be selected. ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Run Lasso on mathbfX mathbftildeX and apply knockoff filter:","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"@time knockoff_filter = fit_lasso(y, X, mvr.X̃);","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"  0.370703 seconds (4.81 k allocations: 53.646 MiB)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"The return type is now a KnockoffFilter, which contains the following information","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"struct KnockoffFilter{T}\n    XX̃ :: Matrix{T} # n × 2p matrix of original X and its knockoff interleaved randomly\n    original :: Vector{Int} # p × 1 vector of indices of XX̃ that corresponds to X\n    knockoff :: Vector{Int} # p × 1 vector of indices of XX̃ that corresponds to X̃\n    W :: Vector{T} # p × 1 vector of feature-importance statistics for fdr level fdr\n    βs :: Vector{Vector{T}} # βs[i] is the p × 1 vector of effect sizes corresponding to fdr level fdr_target[i]\n    a0 :: Vector{T}   # intercepts for each model in βs\n    τs :: Vector{T}   # knockoff threshold for selecting Ws correponding to each FDR\n    fdr_target :: Vector{T} # target FDR level for each τs and βs\n    debiased :: Bool # whether βs and a0 have been debiased\nend","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Given these information, we can e.g. visualize power and FDR trade-off:","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"FDR = knockoff_filter.fdr_target\nempirical_power = Float64[]\nempirical_fdr = Float64[]\nfor i in eachindex(FDR)\n    # extract beta for current fdr\n    βknockoff = knockoff_filter.βs[i]\n    \n    # compute power and false discovery proportion\n    power = length(findall(!iszero, βknockoff) ∩ correct_position) / k\n    fdp = length(setdiff(findall(!iszero, βknockoff), correct_position)) / max(count(!iszero, βknockoff), 1)\n    push!(empirical_power, power)\n    push!(empirical_fdr, fdp)\nend\n\n# visualize FDR and power\npower_plot = plot(FDR, empirical_power, xlabel=\"Target FDR\", ylabel=\"Empirical power\", legend=false, w=2)\nfdr_plot = plot(FDR, empirical_fdr, xlabel=\"Target FDR\", ylabel=\"Empirical FDR\", legend=false, w=2)\nPlots.abline!(fdr_plot, 1, 0, line=:dash)\nplot(power_plot, fdr_plot)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Conclusion: ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"LASSO + knockoffs controls the false discovery rate at below the target (dashed line). Thus, one trade power for FDR control. \nThe power of standard LASSO is better, but it comes with high empirical FDR that one cannot control via cross validation. ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"If we repeated the simulation multiple times, we expect the empirical FDR to hug the target FDR more closely.","category":"page"},{"location":"man/shapeit_hmm/#SHAPEIT-HMM-knockoffs","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM knockoffs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"This page is a tutorial for generating (SHAPEIT) HMM knockoffs, which is good for controlling FDR in the presence of cryptic relatedness and diverse ancestries. The methodology is described in the following paper:","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Sesia, Matteo, et al. \"False discovery rate control in genome-wide association studies with population structure.\" Proceedings of the National Academy of Sciences 118.40 (2021). ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"This tutorial closely follows the original knockoffgwas tutorial. Currently users need to manually run and process various input/intermediate files, but eventually, we will write native Julia wrappers to circumvent these tedious procedures. Stay tuned. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"note: Note\nIt is highly recommended to run this tutorial on linux machines, because RaPID (for detecting IBD segments) only run on linux. Currently users of windows and macOS machines must assume no IBD segments exist. ","category":"page"},{"location":"man/shapeit_hmm/#Installation","page":"SHAPEIT HMM Knockoffs","title":"Installation","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Install knockoffgwas and its dependencies\nInstall qctools for converting between VCF and BGEN formats\nInstall RaPID for detecting IBD segments (this only run on linux)\nInstall the following Julia packages. Within julia, type","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"]add SnpArrays Distributions ProgressMeter MendelIHT VCFTools StatsBase CodecZlib\n]add https://github.com/biona001/Knockoffs.jl","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Finally, modify these executable path to the ones installed on your local computer. Here the partition_exe is located under the path you installed knockoffgwas: knockoffgwas/knockoffgwas/utils/partition.R.","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"qctools_exe = \"/scratch/users/bbchu/qctool/build/release/qctool_v2.0.7\"\nsnpknock2_exe = \"/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2\"\nrapid_exe = \"/scratch/users/bbchu/RaPID/RaPID_v.1.7\"\npartition_exe = \"/scratch/users/bbchu/knockoffgwas/knockoffgwas/utils/partition.R\";","category":"page"},{"location":"man/shapeit_hmm/#Required-inputs","page":"SHAPEIT HMM Knockoffs","title":"Required inputs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"We need multiple input files to generate knockoffs","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Unphased genotypes in binary PLINK format\nPhased genotypes in VCF and BGEN format: we will simulate haplotypes, store in VCF format, and convert to BGEN using qctools\nNote: knockoffgwas requires only BGEN format, but RaPID requires VCF formats. Hence, the extra conversion\nMap file (providing different group resolution): since data is simulated, we will generate fake map file\nIBD segment file (generated by RaPID which requires VCF inputs)\nVariant partition files (generated by snpknock2, i.e. module 2 of knockoffgwas) \nSample and variant QC files","category":"page"},{"location":"man/shapeit_hmm/#Simulate-genotypes","page":"SHAPEIT HMM Knockoffs","title":"Simulate genotypes","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Our simulation will try to follow","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Adding population structure (admixture & cryptic relatedness): New approaches to population stratification in genome-wide association studies\nHow to simulate siblings: Using Extended Genealogy to Estimate Components of Heritability for 23 Quantitative and Dichotomous Traits","category":"page"},{"location":"man/shapeit_hmm/#Population-structure","page":"SHAPEIT HMM Knockoffs","title":"Population structure","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Specifically, lets simulate genotypes with 2 populations. We simulate 49700 normally differentiated markers and 300 unusually differentiated markers based on allele frequency difference equal to 0.6. Let x_ij be the number of alternate allele count for sample i at SNP j with allele frequency p_j. Also let h_ij 1 denotype haplotype 1 of sample i at SNP j and h_ij 2 the second haplotype. Our simulation model is","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"h_ij 1 sim Bernoulli(p_j) quad h_ij 2 sim Bernoulli(p_j) quad x_ij = h_ij 1 + h_ij 2","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"which is equivalent to  ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"x_ij sim Binomial(2 p_j)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"for unphased data. The allele frequency is p_j = Uniform(0 1) for normally differentiated markers, and ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"p_pop1 j sim Uniform(0 04) quad p_pop2 j = p_pop1 j + 06","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"for abnormally differentiated markers. Each sample is randomly assigned to population 1 or 2. ","category":"page"},{"location":"man/shapeit_hmm/#Sibling-pairs","page":"SHAPEIT HMM Knockoffs","title":"Sibling pairs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Based on the simulated data above, we can randomly sample pairs of individuals and have them produce offspring. Here, half of all offsprings will be siblings with the other half. This is done by first randomly sampling 2 person to represent parent. Assume they have 2 children. Then generate offspring individuals by copying segments of one parent haplotype directly to the corresponding haplotype of the offspring. This recombination event will produce IBD segments. The number of recombination is 1 or 2 per chromosome, and is chosen uniformly across the chromosome. ","category":"page"},{"location":"man/shapeit_hmm/#Step-0:-simulate-genotypes","page":"SHAPEIT HMM Knockoffs","title":"Step 0: simulate genotypes","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Load Julia packages needed for this tutorial","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"using SnpArrays\nusing Knockoffs\nusing DelimitedFiles\nusing Random\nusing LinearAlgebra\nusing Distributions\nusing ProgressMeter\nusing MendelIHT\nusing VCFTools\nusing StatsBase\nusing CodecZlib","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Load helper functions needed for this tutorial (data simulation + some glue code). It is not crucial to understand what they are doing.  ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"\"\"\"\n    simulate_pop_structure(n, p)\n\nSimulate genotypes with K = 2 populations. 300 SNPs will have different allele \nfrequencies between the populations, where 50 of them will be causal\n\n# Inputs\n- `plinkfile`: Output plink file name. \n- `n`: Number of samples\n- `p`: Number of SNPs\n\n# Output\n- `x1`: n×p matrix of the 1st haplotype for each sample. Each row is a haplotype\n- `x2`: n×p matrix of the 2nd haplotype for each sample. `x = x1 + x2`\n- `populations`: Vector of length `n` indicating population membership for eachsample. \n- `diff_markers`: Indices of the differentially expressed alleles.\n\n# Reference\nhttps://www.nature.com/articles/nrg2813\n\"\"\"\nfunction simulate_pop_structure(n::Int, p::Int)\n    # first simulate genotypes treating all samples equally\n    x1 = BitMatrix(undef, n, p)\n    x2 = BitMatrix(undef, n, p)\n    pmeter = Progress(p, 0.1, \"Simulating genotypes...\")\n    @inbounds for j in 1:p\n        d = Bernoulli(rand())\n        for i in 1:n\n            x1[i, j] = rand(d)\n            x2[i, j] = rand(d)\n        end\n        next!(pmeter)\n    end\n    # assign populations and simulate 300 unually differentiated markers\n    populations = rand(1:2, n)\n    diff_markers = sample(1:p, 300, replace=false)\n    @inbounds for j in diff_markers\n        pop1_allele_freq = 0.4rand()\n        pop2_allele_freq = pop1_allele_freq + 0.6\n        pop1_dist = Bernoulli(pop1_allele_freq)\n        pop2_dist = Bernoulli(pop2_allele_freq)\n        for i in 1:n\n            d = isone(populations[i]) ? pop1_dist : pop2_dist\n            x1[i, j] = rand(d)\n            x2[i, j] = rand(d)\n        end\n    end\n    return x1, x2, populations, diff_markers\nend\n\n\"\"\"\n    simulate_IBD(h1::BitMatrix, h2::BitMatrix, k::Int)\n\nSimulate recombination events. Parent haplotypes `h1` and `h2` will be used to generate \n`k` children, then both parent and children haplotypes will be returned. \n\nIn offspring simulation, half of all offsprings will be siblings with the other half.\nThis is done by first randomly sampling 2 samples from to represent parent. Assume they have\n2 children. Then generate offspring individuals by copying segments of the parents haplotype\ndirectly to the offspring to represent IBD segments. The number of segments (i.e. places of\nrecombination) is 1 or 2 per chromosome, and is chosen uniformly across the chromosome. \n\n# Inputs\n- `h1`: `n × p` matrix of the 1st haplotype for each parent. Each row is a haplotype\n- `h2`: `n × p` matrix of the 2nd haplotype for each parent. `H = h1 + h2`\n- `k`: Total number of offsprings\n\n# Output\n- `H1`: `n+k × p` matrix of the 1st haplotype. The first `n` haplotypes are from parents\n    and the next `k` haplotypes are the offsprings. Each row is a haplotype\n- `H2`: `n+k × p` matrix of the 2nd haplotype. `x = x1 + x2`\n\n# References\nhttps://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1003520\n\"\"\"\nfunction simulate_IBD(h1::BitMatrix, h2::BitMatrix, k::Int)\n    n, p = size(h1)\n    iseven(k) || error(\"number of offsprings should be even\")\n    # randomly designate gender for parents\n    sex = bitrand(n)\n    male_idx = findall(x -> x == true, sex)\n    female_idx = findall(x -> x == false, sex)\n    # simulate new samples\n    x1 = falses(k, p)\n    x2 = falses(k, p)\n    fathers = Int[]\n    mothers = Int[]\n    pmeter = Progress(k, 0.1, \"Simulating IBD segments...\")\n    for i in 1:k\n        # assign parents\n        dad = rand(male_idx)\n        mom = rand(female_idx)\n        push!(fathers, dad)\n        push!(mothers, mom)\n        # recombination\n        recombine!(@view(x1[i, :]), @view(x2[i, :]), @view(h1[dad, :]),\n                   @view(h2[dad, :]), @view(h1[mom, :]), @view(h2[mom, :]))\n        # update progress\n        next!(pmeter)\n    end\n    # combine offsprings and parents\n    H1 = [h1; x1]\n    H2 = [h2; x2]\n    return H1, H2, fathers, mothers\nend\n\nfunction recombination_segments(breakpoints::Vector{Int}, snps::Int)\n    start = 1\n    result = UnitRange{Int}[]\n    for bkpt in breakpoints\n        push!(result, start:bkpt)\n        start = bkpt + 1\n    end\n    push!(result, breakpoints[end]+1:snps)\n    return result\nend\n\nfunction recombine!(child_h1, child_h2, dad_h1, dad_h2, mom_h1, mom_h2)\n    p = length(child_h1)\n    recombinations = rand(1:5)\n    breakpoints = sort!(sample(1:p, recombinations, replace=false))\n    segments = recombination_segments(breakpoints, p)\n    for segment in segments\n        dad_hap = rand() < 0.5 ? dad_h1 : dad_h2\n        mom_hap = rand() < 0.5 ? mom_h1 : mom_h2\n        copyto!(@view(child_h1[segment]), @view(dad_hap[segment]))\n        copyto!(@view(child_h2[segment]), @view(mom_hap[segment]))\n    end\nend\n\nfunction write_plink(outfile::AbstractString, x1::AbstractMatrix, x2::AbstractMatrix)\n    n, p = size(x1)\n    x = SnpArray(outfile * \".bed\", n, p)\n    for j in 1:p, i in 1:n\n        c = x1[i, j] + x2[i, j]\n        if c == 0\n            x[i, j] = 0x00\n        elseif c == 1\n            x[i, j] = 0x02\n        elseif c == 2\n            x[i, j] = 0x03\n        else\n            error(\"matrix entries should be 0, 1, or 2 but was $c!\")\n        end\n    end\n    # create .bim file structure: https://www.cog-genomics.org/plink2/formats#bim\n    open(outfile * \".bim\", \"w\") do f\n        for i in 1:p\n            println(f, \"1\\tsnp$i\\t0\\t$(100i)\\t1\\t2\")\n        end\n    end\n    # create .fam file structure: https://www.cog-genomics.org/plink2/formats#fam\n    open(outfile * \".fam\", \"w\") do f\n        for i in 1:n\n            println(f, \"$i\\t1\\t0\\t0\\t1\\t-9\")\n        end\n    end\n    return nothing\nend\n\nfunction make_partition_mapfile(filename, p::Int)\n    map_cM = LinRange(0.0, Int(p / 10000), p)\n    open(filename, \"w\") do io\n        println(io, \"Chromosome\\tPosition(bp)\\tRate(cM/Mb)\\tMap(cM)\")\n        for i in 1:p\n            println(io, \"chr1\\t\", 100i, '\\t', 0.01rand(), '\\t', map_cM[i])\n        end\n    end\nend\n\nfunction make_rapid_mapfile(filename, p::Int)\n    map_cM = LinRange(0.0, Int(p / 10000), p)\n    open(filename, \"w\") do io\n        for i in 1:p\n            println(io, i, '\\t', map_cM[i])\n        end\n    end\nend\n\nfunction process_rapid_output(inputfile, outputfile)\n    writer = open(outputfile, \"w\")\n    df = readdlm(inputfile)\n    println(writer, \"CHR ID1 HID1 ID2 HID2 BP.start BP.end site.start site.end cM FAM1 FAM2\")\n    for r in eachrow(df)\n        chr, id1, id2, hap1, hap2, start_pos, end_pos, genetic_len, start_site, end_site = \n            Int(r[1]), Int(r[2]), Int(r[3]), Int(r[4]), Int(r[5]), Int(r[6]), Int(r[7]),\n            r[8], Int(r[9]), Int(r[10])\n        println(writer, chr, ' ', id1, ' ', hap1, ' ', id2, ' ', hap2, ' ', \n            start_pos, ' ', end_pos, ' ', start_site, ' ', end_site, ' ', \n            genetic_len, ' ', 1, ' ', 1)\n    end\n    close(writer)\nend\n\nfunction make_bgen_samplefile(filename, n)\n    open(filename, \"w\") do io\n        println(io, \"ID_1 ID_2 missing sex\")\n        println(io, \"0 0 0 D\")\n        for i in 1:n\n            println(io, \"$i 1 0 1\")\n        end\n    end \nend","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"make_bgen_samplefile (generic function with 1 method)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Simulate phased data with 2 populations, 49700 usually differentiated markers, and 300 unusually differentiated markers. Then simulate mating, which generates IBD segments. Finally, make unphased data from offspring haplotypes. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"# simulate phased genotypes\nRandom.seed!(2021)\noutfile = \"sim\"\nn = 2000\np = 50000\nh1, h2, populations, diff_markers = simulate_pop_structure(n, p)\n\n# simulate random mating to get IBD segments\noffsprings = 100\nx1, x2 = simulate_IBD(h1, h2, offsprings)\n\n# write phased genotypes to VCF format\nwrite_vcf(\"sim.phased.vcf.gz\", x1, x2)\n\n# write unphased genotypes to PLINK binary format\nwrite_plink(outfile, x1, x2)\n\n# save pop1/pop2 index and unually differentiated marker indices\nwritedlm(\"populations.txt\", populations)\nwritedlm(\"diff_markers.txt\", diff_markers)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"\u001b[32mSimulating genotypes...100%|████████████████████████████| Time: 0:00:01\u001b[39m\n\u001b[32mWriting VCF...100%|█████████████████████████████████████| Time: 0:00:24\u001b[39m","category":"page"},{"location":"man/shapeit_hmm/#Step-1:-Partitions","page":"SHAPEIT HMM Knockoffs","title":"Step 1: Partitions","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"We need","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Map file (in particular the (cM) field will determine group resolution)\nPLINK's bim file\nQC file (all SNP names that pass QC)\noutput file name","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Since data is simulated, there are no genomic map file. Let us generate a fake one. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"# generate fake map file\nmake_partition_mapfile(\"sim.partition.map\", p)\n\n# also generate QC file that contains all SNPs and all samples\nsnpdata = SnpData(\"sim\")\nsnpIDs = snpdata.snp_info[!, :snpid]\nsampleIDs = Matrix(snpdata.person_info[!, 1:2])\nwritedlm(\"variants_qc.txt\", snpIDs)\nwritedlm(\"samples_qc.txt\", sampleIDs)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Now we run the partition script","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"plinkfile = \"sim\"\nmapfile = \"sim.partition.map\"\nqc_variants = \"variants_qc.txt\"\noutfile = \"sim.partition.txt\"\npartition(partition_exe, plinkfile, mapfile, qc_variants, outfile)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Mean group sizes: \n      res_7       res_6       res_5       res_4       res_3       res_2 \n    1.00000    67.75068   349.65035   694.44444  1351.35135  3333.33333 \n      res_1 \n10000.00000 \nPartitions written to: sim.partition.txt\n\n\n\n\n\nProcess(`\u001b[4mRscript\u001b[24m \u001b[4m--vanilla\u001b[24m \u001b[4m/scratch/users/bbchu/knockoffgwas/knockoffgwas/utils/partition.R\u001b[24m \u001b[4msim.partition.map\u001b[24m \u001b[4msim.bim\u001b[24m \u001b[4mvariants_qc.txt\u001b[24m \u001b[4msim.partition.txt\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/shapeit_hmm/#Step-2:-Generate-Knockoffs","page":"SHAPEIT HMM Knockoffs","title":"Step 2: Generate Knockoffs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"First generate IBD segment files. We need to generate RaPID's required map file","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"make_rapid_mapfile(\"sim.rapid.map\", p)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Next we run the RaPID software","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"vcffile = \"sim.phased.vcf.gz\"\nmapfile = \"sim.rapid.map\"\noutfolder = \"rapid\"\nd = 3    # minimum IBD length in cM\nw = 3    # number of SNPs per window\nr = 10   # number of runs\ns = 2    # Minimum number of successes to consider a hit\n@time rapid(rapid_exe, vcffile, mapfile, d, outfolder, w, r, s)\n\n# unzip output file\nrun(pipeline(`gunzip -c ./rapid/results.max.gz`, stdout=\"./rapid/results.max\"))","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"┌ Info: RaPID command:\n│ `/scratch/users/bbchu/RaPID/RaPID_v.1.7 -i sim.phased.vcf.gz -g sim.rapid.map -d 3 -o rapid -w 3 -r 10 -s 2`\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:55\n┌ Info: Output directory: rapid\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:56\n\n\nCreate sub-samples..\nDone!\n 43.120301 seconds (3.04 k allocations: 159.828 KiB)\n\n\n\n\n\nProcess(`\u001b[4mgunzip\u001b[24m \u001b[4m-c\u001b[24m \u001b[4m./rapid/results.max.gz\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"countlines(\"./rapid/results.max\") # d = 3, w = 3, r = 10, s = 9","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"140","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Here we identified 140 IBD segments. Because we only simulated 100 offsprings, and all 2000 parents are unrelated, the \"IBD related families\" are small. When there are too many segments, one might have to prune the IBD segments so that the families are not too connected. See this issue for details. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"where the column format is: ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"<chr_name> <sample_id1> <sample_id2> <hap_id1> <hap_id2> <starting_pos_genomic> <ending_pos_genomic> <genetic_length> <starting_site> <ending_site>","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Then we need to do some postprocessing to this output, as described here. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"process_rapid_output(\"./rapid/results.max\", \"sim.snpknock.ibdmap\")","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"The output looks like follows. The last 5 columns (site.start site.end cM FAM1 FAM2) are not actually currently used. They need to be there (the file should have 12 fields in total), but it doesn't matter what values you put in them.","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":";head sim.snpknock.ibdmap","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"CHR ID1 HID1 ID2 HID2 BP.start BP.end site.start site.end cM FAM1 FAM2\n1 29 0 2053 0 100 5000000 0 49999 4.9999 1 1\n1 64 0 2003 1 100 4712700 0 47126 4.71259 1 1\n1 97 1 2051 0 100 5000000 0 49999 4.9999 1 1\n1 99 1 2017 0 967300 5000000 9672 49999 4.03278 1 1\n1 106 1 2024 1 100 4078800 0 40787 4.07868 1 1\n1 151 1 2009 0 100 5000000 0 49999 4.9999 1 1\n1 155 1 2069 0 100 5000000 0 49999 4.9999 1 1\n1 163 1 2073 1 100 3309000 0 33089 3.30887 1 1\n1 231 1 2080 1 1153000 5000000 11529 49999 3.84708 1 1","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Next convert VCF file to BGEN format (note: sample file must be saved separately)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"# convert VCF to BGEN format\noutfile = \"sim.bgen\"\nrun(`$qctools_exe -g $vcffile -og $outfile`)\n\n# then save sample file separately\nmake_bgen_samplefile(\"sim.sample\", n + offsprings)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Welcome to qctool\n(version: 2.0.7, revision )\n\n(C) 2009-2017 University of Oxford\n\nOpening genotype files                                      : [******************************] (1/1,0.0s,32.2/s)\n========================================================================\n\nInput SAMPLE file(s):         Output SAMPLE file:             \"(n/a)\".\nSample exclusion output file:   \"(n/a)\".\n\nInput GEN file(s):\n                                                    (not computed)  \"sim.phased.vcf.gz\"\n                                         (total 1 sources, number of snps not computed).\n                      Number of samples: 2100\nOutput GEN file(s):             \"sim.bgen\"\nOutput SNP position file(s):    (n/a)\nSample filter:                  .\n# of samples in input files:    2100.\n# of samples after filtering:   2100 (0 filtered out).\n\n========================================================================\n\nProcessing SNPs                                             :  (50000/?,169.4s,295.2/s)60.3s,275.2/s)\nTotal: 50000SNPs.\n========================================================================\n\nNumber of SNPs:\n                     -- in input file(s):                 (not computed).\n -- in output file(s):                50000\n\nNumber of samples in input file(s):   2100.\n\nOutput GEN files:                     (50000  snps)  \"sim.bgen\"\n                                      (total 50000 snps).\n========================================================================\n\n\nThank you for using qctool.","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Finally, generate HMM knockoffs by running the following code in the command line directly. You may need to adjust file directories and change parameters. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"bgenfile = \"sim\"\nsample_qc = \"samples_qc.txt\"\nvariant_qc = \"variants_qc.txt\"\nmapfile = \"sim.partition.map\"\npartfile = \"sim.partition.txt\"\nibdfile = \"sim.snpknock.ibdmap\"\nK = 10\ncluster_size_min = 1000 \ncluster_size_max = 10000 \nhmm_rho = 1\nhmm_lambda = 1e-3 \nwindows = 0\nn_threads = 1\nseed = 2021\ncompute_references = true\ngenerate_knockoffs = true\noutfile = \"sim.knockoffs\"\n\n@time snpknock2(snpknock2_exe, bgenfile, sample_qc, variant_qc, mapfile, partfile, ibdfile, \n    K, cluster_size_min, cluster_size_max, hmm_rho, hmm_lambda, windows, n_threads, \n    seed, compute_references, generate_knockoffs, outfile)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"\t+----------------------+\n\t|                      |\n\t|  SNPKNOCK2, v0.3     |\n\t|  July 21, 2020       |\n\t|  Matteo Sesia        |\n\t|                      |\n\t+----------------------+\n\nCopyright (C) 2020 Stanford University.\nDistributed under the GNU GPLv3 open source license.\n\nUse --help for more information.\n\nCommand line arguments:\n  --bgen sim\n  --keep samples_qc.txt\n  --extract variants_qc.txt\n  --map sim.partition.map\n  --part sim.partition.txt\n  --ibd sim.snpknock.ibdmap\n  --K 10\n  --cluster_size_min 1000\n  --cluster_size_max 10000\n  --hmm-rho 1\n  --hmm-lambda 0.001\n  --windows 0\n  --n_threads 1\n  --seed 2021\n  --compute-references\n  --generate-knockoffs\n  --out ./knockoffs/sim.knockoffs\n\nRequested operations:\n  --compute-references\n  --generate_knockoffs\n\n\n\n┌ Info: snpknock2 command:\n│ `/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2 --bgen sim --keep samples_qc.txt --extract variants_qc.txt --map sim.partition.map --part sim.partition.txt --ibd sim.snpknock.ibdmap --K 10 --cluster_size_min 1000 --cluster_size_max 10000 --hmm-rho 1 --hmm-lambda 0.001 --windows 0 --n_threads 1 --seed 2021 --compute-references --generate-knockoffs --out ./knockoffs/sim.knockoffs`\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:100\n┌ Info: Output directory: /home/users/bbchu/hmm/knockoffs\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:101\n\n\n\n--------------------------------------------------------------------------------\nLoading metadata\n--------------------------------------------------------------------------------\nLoading sample information from:\n  sim.sample\nLoading legend from:\n  sim.bim\nLoading partitions from:\n  sim.partition.txt\nLoading IBD segments from:\n  sim.snpknock.ibdmap\nLoaded 140 IBD segments.\n\nPrinting summary of 1 windows:\n     0: 0--50000\nSummary of metadata for chromosome 1:\n  number of samples (after | before filtering) : 2100 | 2100\n  number of SNPs (after | before filtering)    : 50000 | 50000\n  number of variant partitions                 : 7\n  size of genomic windows                      : whole-chromosome\n  number of IBD segments                       : 140\n\n\n--------------------------------------------------------------------------------\nKinship (using only haplotype data)\n--------------------------------------------------------------------------------\nReached 1\nChromosome 1 will be loaded from:\n  haplotype file            : sim.bgen\n  sample file               : sim.sample\n  legend file               : sim.bim\n  thinning factor           : 10\n  sample filter file        : samples_qc.txt\n  variant filter file       : variants_qc.txt\n  number of SNPs            : 5000\n  number of haplotypes      : 4200\n\nReading BGEN file using 1 thread:\n|....................................................................................................|\n|====================================================================================================|\nSolving 1 bifurcating K-means problems using 1 threads.\n\nKinship clusters written to:\n  ./knockoffs/sim.knockoffs_clust.txt\n  ./knockoffs/sim.knockoffs.sample\n\nAssigning references for the whole chromosome using 1 threads: \n|....................................................................................................|\n|\n\n\nBifurcating K-means\nSmallest allowed cluster size: 1000\n step\t cluster\t    size\t    left\t   right\taccepted\nBifurcating K-means completed after 0 steps.\nNumber of clusters: 1.\n\n\n\n====================================================================================================|\n\nReached 2\nIndividual global references written to:\n  ./knockoffs/sim.knockoffs_lref.txt\n\nIndividual local references written to:\n  ./knockoffs/sim.knockoffs_ref.txt\n\n\n--------------------------------------------------------------------------------\nKnockoffs for chromosome 1\n--------------------------------------------------------------------------------\nChromosome 1 will be loaded from:\n  haplotype file            : sim\n  haplotype file format     : bgen\n  sample file               : sim.sample\n  legend file               : sim.bim\n  map file                  : sim.partition.map\n  sample filter file        : samples_qc.txt\n  variant filter file       : variants_qc.txt\n  number of SNPs            : 50000\n  number of windows         : 1\n  number of haplotypes      : 4200\n\nLoading data for chromosome 1\nReading BGEN file using 1 thread:\n|....................................................................................................|\n|====================================================================================================|\n\nInitializing HMM with user-supplied hyperparameters: rho = 1, lambda = 0.001.\n\nHMM parameters written to:\n  ./knockoffs/sim.knockoffs_hmm.txt\n\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res0_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res0_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 50000 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 50000 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res0.bed\n  ./knockoffs/sim.knockoffs_res0.bim\n  ./knockoffs/sim.knockoffs_res0.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res0_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res1_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res1_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 738 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 738 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res1.bed\n  ./knockoffs/sim.knockoffs_res1.bim\n  ./knockoffs/sim.knockoffs_res1.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res1_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res2_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res2_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 143 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 143 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res2.bed\n  ./knockoffs/sim.knockoffs_res2.bim\n  ./knockoffs/sim.knockoffs_res2.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res2_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res3_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res3_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 72 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 72 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res3.bed\n  ./knockoffs/sim.knockoffs_res3.bim\n  ./knockoffs/sim.knockoffs_res3.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res3_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res4_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res4_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 37 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 37 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res4.bed\n  ./knockoffs/sim.knockoffs_res4.bim\n  ./knockoffs/sim.knockoffs_res4.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res4_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res5_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res5_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 15 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 15 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res5.bed\n  ./knockoffs/sim.knockoffs_res5.bim\n  ./knockoffs/sim.knockoffs_res5.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res5_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res6_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res6_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res6.bed\n  ./knockoffs/sim.knockoffs_res6.bim\n  ./knockoffs/sim.knockoffs_res6.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res6_anc.txt\n\nFinished.\n\n1484.517148 seconds (409.38 k allocations: 24.636 MiB, 0.01% compilation time)\n\n\n\n\n\nProcess(`\u001b[4m/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2\u001b[24m \u001b[4m--bgen\u001b[24m \u001b[4msim\u001b[24m \u001b[4m--keep\u001b[24m \u001b[4msamples_qc.txt\u001b[24m \u001b[4m--extract\u001b[24m \u001b[4mvariants_qc.txt\u001b[24m \u001b[4m--map\u001b[24m \u001b[4msim.partition.map\u001b[24m \u001b[4m--part\u001b[24m \u001b[4msim.partition.txt\u001b[24m \u001b[4m--ibd\u001b[24m \u001b[4msim.snpknock.ibdmap\u001b[24m \u001b[4m--K\u001b[24m \u001b[4m10\u001b[24m \u001b[4m--cluster_size_min\u001b[24m \u001b[4m1000\u001b[24m \u001b[4m--cluster_size_max\u001b[24m \u001b[4m10000\u001b[24m \u001b[4m--hmm-rho\u001b[24m \u001b[4m1\u001b[24m \u001b[4m--hmm-lambda\u001b[24m \u001b[4m0.001\u001b[24m \u001b[4m--windows\u001b[24m \u001b[4m0\u001b[24m \u001b[4m--n_threads\u001b[24m \u001b[4m1\u001b[24m \u001b[4m--seed\u001b[24m \u001b[4m2021\u001b[24m \u001b[4m--compute-references\u001b[24m \u001b[4m--generate-knockoffs\u001b[24m \u001b[4m--out\u001b[24m \u001b[4m./knockoffs/sim.knockoffs\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/shapeit_hmm/#Step-3:-Examine-Generated-Knockoffs","page":"SHAPEIT HMM Knockoffs","title":"Step 3: Examine Generated Knockoffs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"The generated knockoffs are saved in binary PLINK format, we can import it using SnpArrays","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"x = SnpArray(\"knockoffs/sim.knockoffs_res0.bed\")","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"2100×100000 SnpArray:\n 0x03  0x03  0x02  0x02  0x03  0x03  …  0x02  0x02  0x02  0x03  0x03  0x03\n 0x02  0x02  0x03  0x03  0x00  0x02     0x02  0x02  0x03  0x03  0x02  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x00  0x03  0x02  0x02  0x02  0x02     0x03  0x02  0x03  0x03  0x03  0x03\n 0x03  0x03  0x00  0x00  0x03  0x02     0x02  0x02  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02  …  0x03  0x03  0x03  0x02  0x03  0x03\n 0x02  0x00  0x00  0x00  0x02  0x02     0x03  0x00  0x02  0x02  0x03  0x03\n 0x02  0x02  0x02  0x02  0x00  0x02     0x02  0x02  0x02  0x03  0x03  0x03\n 0x02  0x03  0x02  0x02  0x03  0x03     0x02  0x02  0x02  0x00  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x00     0x02  0x02  0x02  0x02  0x03  0x03\n 0x03  0x00  0x02  0x03  0x02  0x03  …  0x02  0x02  0x02  0x02  0x03  0x03\n 0x00  0x03  0x03  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x02  0x02  0x03  0x03  0x03  0x03     0x00  0x02  0x02  0x02  0x03  0x03\n    ⋮                             ⋮  ⋱           ⋮                    \n 0x00  0x00  0x03  0x03  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x00  0x02  0x03  0x03  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x00  0x02  0x03  0x03  0x02  0x02  …  0x00  0x00  0x02  0x00  0x03  0x03\n 0x00  0x00  0x02  0x02  0x03  0x03     0x02  0x02  0x03  0x03  0x03  0x03\n 0x00  0x02  0x03  0x03  0x02  0x02     0x00  0x00  0x02  0x02  0x03  0x03\n 0x00  0x00  0x02  0x02  0x03  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x02  0x03  0x02  0x00  0x03  0x02     0x03  0x03  0x00  0x00  0x03  0x03\n 0x03  0x02  0x03  0x00  0x03  0x03  …  0x02  0x02  0x02  0x02  0x03  0x03\n 0x03  0x03  0x02  0x02  0x03  0x03     0x02  0x02  0x03  0x03  0x02  0x02\n 0x03  0x00  0x00  0x00  0x02  0x02     0x02  0x02  0x03  0x03  0x03  0x03\n 0x00  0x03  0x03  0x02  0x02  0x02     0x00  0x00  0x00  0x00  0x03  0x03\n 0x02  0x00  0x00  0x00  0x02  0x02     0x02  0x02  0x02  0x02  0x03  0x03","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Notice there are 100k SNPs: the original 50k SNPs and their knockoffs. Reading the SNP names will tell us which are the originals:","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"snpid = SnpData(\"knockoffs/sim.knockoffs_res0\").snp_info.snpid","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"100000-element Vector{String}:\n \"snp1.k\"\n \"snp1\"\n \"snp2\"\n \"snp2.k\"\n \"snp3.k\"\n \"snp3\"\n \"snp4.k\"\n \"snp4\"\n \"snp5.k\"\n \"snp5\"\n \"snp6\"\n \"snp6.k\"\n \"snp7\"\n ⋮\n \"snp49995\"\n \"snp49995.k\"\n \"snp49996.k\"\n \"snp49996\"\n \"snp49997.k\"\n \"snp49997\"\n \"snp49998.k\"\n \"snp49998\"\n \"snp49999\"\n \"snp49999.k\"\n \"snp50000.k\"\n \"snp50000\"","category":"page"},{"location":"man/shapeit_hmm/#Step-4:-Model-selection-with-knockoffs","page":"SHAPEIT HMM Knockoffs","title":"Step 4: Model selection with knockoffs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Tutorial for this part coming soon! Basically, one constructs a SnpLinAlg, feed that into MendelIHT.jl, and calculate knockoff statistics afterwards using built-in functions like coefficient_diff and threshold.","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"SnpLinAlg performs compressed linear algebra (often faster than double precision BLAS)\nMendelIHT.jl is a very efficient implementation of the iterative hard thresholding algorithm. For model selection, IHT is known to be superior to standard LASSO, elastic net, and MCP solvers. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"xla = SnpLinAlg{Float64}(x, center=true, scale=true, impute=true)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"2100×100000 SnpLinAlg{Float64}:\n  1.76602    1.68237   -0.311698  …   1.20757    0.0817861   0.12776\n  0.316766   0.246784   1.13646       1.20757  -12.1861      0.12776\n  0.316766   0.246784  -0.311698     -0.22433    0.0817861   0.12776\n -1.13249    1.68237   -0.311698      1.20757    0.0817861   0.12776\n  1.76602    1.68237   -1.75985       1.20757    0.0817861   0.12776\n  0.316766   0.246784  -0.311698  …  -0.22433    0.0817861   0.12776\n  0.316766  -1.1888    -1.75985      -0.22433    0.0817861   0.12776\n  0.316766   0.246784  -0.311698      1.20757    0.0817861   0.12776\n  0.316766   1.68237   -0.311698     -1.65623    0.0817861   0.12776\n  0.316766   0.246784  -0.311698     -0.22433    0.0817861   0.12776\n  1.76602   -1.1888    -0.311698  …  -0.22433    0.0817861   0.12776\n -1.13249    1.68237    1.13646      -0.22433    0.0817861   0.12776\n  0.316766   0.246784   1.13646      -0.22433    0.0817861   0.12776\n  ⋮                               ⋱                         \n -1.13249   -1.1888     1.13646       1.20757    0.0817861   0.12776\n -1.13249    0.246784   1.13646       1.20757    0.0817861   0.12776\n -1.13249    0.246784   1.13646   …  -1.65623    0.0817861   0.12776\n -1.13249   -1.1888    -0.311698      1.20757    0.0817861   0.12776\n -1.13249    0.246784   1.13646      -0.22433    0.0817861   0.12776\n -1.13249   -1.1888    -0.311698     -0.22433    0.0817861   0.12776\n  0.316766   1.68237   -0.311698     -1.65623    0.0817861   0.12776\n  1.76602    0.246784   1.13646   …  -0.22433    0.0817861   0.12776\n  1.76602    1.68237   -0.311698      1.20757  -12.1861     -7.7633\n  1.76602   -1.1888    -1.75985       1.20757    0.0817861   0.12776\n -1.13249    1.68237    1.13646      -1.65623    0.0817861   0.12776\n  0.316766  -1.1888    -1.75985      -0.22433    0.0817861   0.12776","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#KnockoffScreen-knockoffs","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen knockoffs","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"This is a tutorial for generating KnockoffScreen knockoffs for genome-wide association studies. This kind of knockoffs is designed for sequence data that have a lot of rare variants. The methodology is described in the following papers","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"He, Zihuai, Linxi Liu, Chen Wang, Yann Le Guen, Justin Lee, Stephanie Gogarten, Fred Lu et al. \"Identification of putative causal loci in whole-genome sequencing data via knockoff statistics.\" Nature communications 12, no. 1 (2021): 1-18.","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"He, Zihuai, Yann Le Guen, Linxi Liu, Justin Lee, Shiyang Ma, Andrew C. Yang, Xiaoxia Liu et al. \"Genome-wide analysis of common and rare variants via multiple knockoffs at biobank scale, with an application to Alzheimer disease genetics.\" The American Journal of Human Genetics 108, no. 12 (2021): 2336-2353","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"In particular, we generate:","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"beginalign*\nhatX_j = hatbeta_0 + sum_k in B_jhatbeta_kX_k + sum_k in B_j k le j - 1hatgamma_ktildeX_k\nhatepsilon = permute(X_j - hatX_j)\ntildeX_j = hatX_j + hatepsilon\nendalign*","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"where B_j is a ball of variants near j and hatbeta_k hatgamma_k are estimated via least squares. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# first load packages needed for this tutorial\nusing Revise\nusing SnpArrays\nusing Knockoffs\nusing Statistics\nusing Plots\nusing GLMNet\nusing Distributions\nusing Random\ngr(fmt=:png);","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#Step-0:-Prepare-example-data","page":"KnockoffScreen Knockoffs","title":"Step 0: Prepare example data","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"To illustrate we need example PLINK data, which are available in Knockoffs/data/mouse.imputed.(bed/bim/fam)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# Path to PLINK data\nmouse_path = joinpath(normpath(Knockoffs.datadir()), \"mouse.imputed\")","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"\"/Users/biona001/.julia/dev/Knockoffs/data/mouse.imputed\"","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#Step-1:-Generate-Knockoffs","page":"KnockoffScreen Knockoffs","title":"Step 1: Generate Knockoffs","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Knockoffs are made using the wrapper function full_knockoffscreen. An iterator format that streams knockoffs one by one is coming soon.","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"warning: Warning\nThe output of full_knockoffscreen is a dense Float64 matrix, which requires 8np bytes of RAM. Do not call it on large PLINK files. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"@time X̃ = full_knockoffscreen(mouse_path, windowsize=50)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"\u001b[32mGenerating knockoffs100%|███████████████████████████████| Time: 0:01:40\u001b[39m\n\n\n129.793232 seconds (74.18 M allocations: 34.660 GiB, 5.35% gc time, 23.10% compilation time)\n\n\n\n\n\n1940×10150 Matrix{Float64}:\n -0.158027  -0.15993  -0.397849  …   0.663515   0.664671   0.668258\n -0.157256  -0.15993   1.07455       0.663515   0.664671   0.666508\n  1.26416    1.2633    0.914503      0.663515   0.664671   0.669306\n -0.158079  -0.15993  -0.412851      0.663515   0.664671   0.667707\n  1.2641     1.2633    1.05954      -1.17537   -1.17217   -1.16703\n -0.15979   -0.15993  -0.412641  …   0.663515   0.664671   0.66629\n -0.159042  -0.15993   0.258318      0.663515   0.664671   0.669239\n -0.158219  -0.15993   1.0255        0.663515   0.664671   0.665875\n -0.156292  -0.15993   1.07454       0.663515   0.664671   0.667836\n  1.26493    1.2633    1.07325      -1.17537   -1.17217   -1.16801\n  1.26685    1.2633    0.258326  …  -3.01425   -3.00901   -3.00042\n -0.157256  -0.15993  -0.397863      0.663515   0.664671   0.669154\n  1.26332    1.2633    1.06682      -3.01425   -3.00901   -3.00326\n  ⋮                              ⋱                        \n  1.26412    1.2633    1.0803        0.663515   0.664671   0.669112\n  1.26589    1.2633    1.02462       0.663515   0.664671   0.669181\n -0.158027  -0.15993  -0.411348  …   0.663515   0.664671   0.667478\n -0.158219  -0.15993  -0.470753      0.663515   0.664671   0.665076\n  1.26493    1.2633    1.04758       0.663515   0.664671   0.666428\n -0.158306  -0.15993  -0.399157      0.663515   0.664671   0.669292\n  1.26589    1.2633    0.258319      0.663515   0.664671   0.669402\n -0.158023  -0.15993  -0.446907  …   0.663515   0.664671   0.666399\n -0.15899   -0.15993   0.257012      0.663515   0.664671   0.668106\n -0.159269  -0.15993   1.07455       0.663515   0.664671   0.666293\n -0.156292  -0.15993  -0.576227     -3.01425   -3.00901   -3.00041\n -1.58241   -1.58316  -1.88373       0.663515   0.664671   0.66915","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#Step-2:-Examine-knockoff-statistics","page":"KnockoffScreen Knockoffs","title":"Step 2: Examine knockoff statistics","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Lets check if the knockoffs \"make sense\". For example, we can compare SNP 1 and its knockoff (which are very similar):","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# import original genotypes into numeric matrix\nX = convert(Matrix{Float64}, SnpArray(mouse_path * \".bed\"), center=true, scale=true)\n\n# compare SNP 1 with its knockoff\n[X[:, 1] X̃[:, 1]]","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"1940×2 Matrix{Float64}:\n -0.159187  -0.158027\n -0.159187  -0.157256\n  1.26396    1.26416\n -0.159187  -0.158079\n  1.26396    1.2641\n -0.159187  -0.15979\n -0.159187  -0.159042\n -0.159187  -0.158219\n -0.159187  -0.156292\n  1.26396    1.26493\n  1.26396    1.26685\n -0.159187  -0.157256\n  1.26396    1.26332\n  ⋮         \n  1.26396    1.26412\n  1.26396    1.26589\n -0.159187  -0.158027\n -0.159187  -0.158219\n  1.26396    1.26493\n -0.159187  -0.158306\n  1.26396    1.26589\n -0.159187  -0.158023\n -0.159187  -0.15899\n -0.159187  -0.159269\n -0.159187  -0.156292\n -1.58233   -1.58241","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Lets also compare cor(X_i X_j) and cor(X_i tildeX_j). If knockoffs satisfy exchangability, their correlation should be very similar and form a diagonal line. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# look at pairwise correlation (between first 200 snps)\nr1, r2 = Float64[], Float64[]\nfor i in 1:200, j in 1:i\n    push!(r1, cor(@view(X[:, i]), @view(X[:, j])))\n    push!(r2, cor(@view(X[:, i]), @view(X̃[:, j])))\nend\n\n# make plot\nscatter(r1, r2, xlabel = \"cor(Xi, Xj)\", ylabel=\"cor(Xi, X̃j)\", legend=false)\nPlots.abline!(1, 0, line=:dash)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Plots distribution of cor(X_j tildeX_j) for all j. Ideally, we want cor(X_j tildeX_j) to be small in magnitude (i.e. X and tildeX is very different). Here the knockoffs are tightly correlated with the original genotypes, so they will likely have low power. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"r2 = Float64[]\nfor j in 1:size(X, 2)\n    push!(r1, cor(@view(X[:, j]), @view(X[:, j])))\n    push!(r2, cor(@view(X[:, j]), @view(X̃[:, j])))\nend\nhistogram(r2, legend=false, xlabel=\"cor(Xj, X̃j)\", ylabel=\"count\")","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#LASSO-example","page":"KnockoffScreen Knockoffs","title":"LASSO example","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Let us apply the generated knockoffs to the model selection problem. In layman's term, it can be stated as","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Given response mathbfy_n times 1, design matrix mathbfX_n times p, we want to select a subset S subset 1p of variables that are truly causal for mathbfy. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#Simulate-data","page":"KnockoffScreen Knockoffs","title":"Simulate data","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"We will simulate ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"mathbfy_n times 1 sim N(mathbfX_n times pmathbfbeta_p times 1    mathbfepsilon_n times 1) quad epsilon_i sim N(0 1)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"where k=50 positions of mathbfbeta is non-zero with effect size beta_j sim N(0 1). The goal is to recover those 50 positions using LASSO.","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# set seed for reproducibility\nRandom.seed!(999)\n\n# simulate true beta\nn, p = size(X)\nk = 50\nβtrue = zeros(p)\nβtrue[1:k] .= randn(k)\nshuffle!(βtrue)\n\n# find true causal variables\ncorrect_position = findall(!iszero, βtrue)\n\n# simulate y\ny = X * βtrue + randn(n);","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#Standard-LASSO","page":"KnockoffScreen Knockoffs","title":"Standard LASSO","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Lets try running standard LASSO, which will produce hatmathbfbeta_p times 1 where we typically declare SNP j to be selected if hatbeta_j ne 0. We use LASSO solver in GLMNet.jl package, which is just a Julia wrapper for the GLMnet Fortran code. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"How well does LASSO perform in terms of power and FDR?","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# run 10-fold cross validation to find best λ minimizing MSE\nlasso_cv = glmnetcv(X, y)\nλbest = lasso_cv.lambda[argmin(lasso_cv.meanloss)]\n\n# use λbest to fit LASSO on full data\nβlasso = glmnet(X, y, lambda=[λbest]).betas[:, 1]\n\n# check power and false discovery rate\npower = length(findall(!iszero, βlasso) ∩ correct_position) / k\nFDR = length(setdiff(findall(!iszero, βlasso), correct_position)) / count(!iszero, βlasso)\n\n#summarize\ncount(!iszero, βlasso), power, FDR","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"(414, 0.78, 0.9057971014492754)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Observe that ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"LASSO found a total of 414 SNPs\nLASSO found 3950 = 70% of all true predictors\n375/364 SNPs were false positive (false discovery rate is 90%)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#KnockoffLASSO","page":"KnockoffScreen Knockoffs","title":"Knockoff+LASSO","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Now lets try applying the knockoff methodology. Recall that consists of a few steps ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Run LASSO on mathbfX mathbftildeX\nCompare coefficient difference statistic W_j for each j = 1p. Here we use W_j = beta_j - beta_j knockoff\nChoose target FDR 0 le q le 1 and compute ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"tau = min_tleftt  0 fracj W_j  -tj W_j  t le qright","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"note: Note\nIn step 1, mathbfX mathbftildeX is written for notational convenience. In practice one must interleave knockoffs with the original variables, where either the knockoff come first or the original genotype come first with equal probability. This is due to the inherent bias of LASSO solvers: when the original and knockoff variable are equally valid, the one listed first will be selected. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# interleave knockoffs with originals\nXfull, original, knockoff = merge_knockoffs_with_original(mouse_path,\n    \"knockoffs/mouse.imputed.fastphase.knockoffs\",\n    des=\"knockoffs/merged\") \nXfull = convert(Matrix{Float64}, Xfull, center=true, scale=true)\n\n# step 1\nknockoff_cv = glmnetcv(Xfull, y)                         # cross validation step\nλbest = knockoff_cv.lambda[argmin(knockoff_cv.meanloss)] # find lambda that minimizes MSE\nβestim = glmnet(Xfull, y, lambda=[λbest]).betas[:, 1]    # refit lasso with best lambda\n\n# target FDR is 0.05, 0.1, ..., 0.5\nFDR = collect(0.05:0.05:0.5)\nempirical_power = Float64[]\nempirical_fdr = Float64[]\nfor fdr in FDR\n    βknockoff = extract_beta(βestim, fdr, original, knockoff) # steps 2-3 happen here\n\n    # compute power and false discovery proportion\n    power = length(findall(!iszero, βknockoff) ∩ correct_position) / k\n    fdp = length(setdiff(findall(!iszero, βknockoff), correct_position)) / max(count(!iszero, βknockoff), 1)\n    push!(empirical_power, power)\n    push!(empirical_fdr, fdp)\nend\n\n# visualize FDR and power\npower_plot = plot(FDR, empirical_power, xlabel=\"Target FDR\", ylabel=\"Empirical power\", legend=false)\nfdr_plot = plot(FDR, empirical_fdr, xlabel=\"Target FDR\", ylabel=\"Empirical FDR\", legend=false)\nPlots.abline!(fdr_plot, 1, 0, line=:dash)\nplot(power_plot, fdr_plot)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Observe that","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"LASSO + knockoffs controls the false discovery rate at below the target (dashed line)\nControlled FDR is compensated by slight loss of power","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"The empirical FDR should hug the target FDR more closely once we repeated the simulation multiple times and generate the knockoffs in a way so that they are not so correlated with the original genotypes. ","category":"page"},{"location":"man/ghost_knockoffs/#Ghost-Knockoffs","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"","category":"section"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"This tutorial is for generating Ghost (summary statistics) Knockoffs for analyzing genome-wide association studies (GWAS). The methodology is described in ","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"He, Z., Liu, L., Belloy, M. E., Le Guen, Y., Sossin, A., Liu, X., ... & Ionita-Laza, I. (2021). Summary statistics knockoff inference empowers identification of putative causal variants in genome-wide association studies. bioRxiv.","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"It is assumed we do not have access to individual level genotype data mathbfG. Rather, for each SNP, we have the z-scores Z_j with respect to a phenotype mathbfY from a GWAS. Then we sample the knockoff z-scores as ","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"beginaligned\nmathbftildeZ  mathbfG mathbfY sim N(mathbfPmathbfZ mathbfV)\nendaligned","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"beginaligned\nmathbfP = mathbfI - mathbfDmathbfSigma^-1 quad mathbfV = 2mathbfD - mathbfDmathbfSigma^-1mathbfD\nendaligned","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"where mathbfI is a p times p identity matrix, mathbfSigma is the correlation matrix among genotypes (characterizing linkage disequilibrium), and mathbfD = diag(s_1  s_p) is a diagonal matrix given by solving the following convex optimization problem","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"beginaligned\ntextminimize   sum_j  1 - s_j \ntextsubject to   2mathbfSigma - mathbfD succeq 0\n                    s_j ge 0\nendaligned","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"In summary, we need to","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Estimate the correlation matrix mathbfSigma, and \nSolve for the vector mathbfs.","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"These operations define mathbfP and mathbfV which can be used to sample the knockoffs mathbftildeZ. We describe step 1 in detail below. Step 2 can be accomplished via standard SDP or MVR solvers.","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"# load package needed for this tutorial\nusing Knockoffs\nusing VCFTools\nusing StatsBase\nusing LinearAlgebra\nusing SnpArrays\nusing Random","category":"page"},{"location":"man/ghost_knockoffs/#Estimate-correlation-matrix-\\mathbf{\\Sigma}","page":"Ghost Knockoffs","title":"Estimate correlation matrix mathbfSigma","text":"","category":"section"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Recall the only data we have is the score statistic mathbfZ for each SNP (i.e. we do not have individual level data mathbfG). To obtain an estimate of mathbfSigma, one way is to leverage a reference haplotype panel, which we denote by mathbfH. For instance, the 1000 genomes phase 3 panel is freely availble to the public and contains 2504 samples of diverse ancestry and ~50 million SNPs. Since mathbfH is very dense, each SNP in mathbfZ either exist in mathbfH, or is close to one that is typed in mathbfH. Over 90% of SNPs in the UK Biobank can be mapped to this panel. Thus, we can roughly estimate mathbfSigma. ","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Of course, population structure may skew the estimation. If the GWAS samples are rather homogeneous, one may want include only ancestrally similar samples in the reference panel. Of course, using denser and larger reference panels such as the HRC or TOPMed will also improve approximation, but those panels has restricted public access. ","category":"page"},{"location":"man/ghost_knockoffs/#Obtain-reference-panel","page":"Ghost Knockoffs","title":"Obtain reference panel","text":"","category":"section"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"First download the 1000 genomes reference panel in standard VCF format (warning: requires sim 94 GB):","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"download_1000genomes(outdir = \"/scratch/users/bbchu\")","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Import chr22 data","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"vcffile = \"/scratch/users/bbchu/1000genomes/chr22.1kg.phase3.v5a.vcf.gz\"\nH, H_sampleID, H_chr, H_pos, H_ids, H_ref, H_alt = convert_gt(Float32, \n    vcffile, save_snp_info=true, msg=\"importing\");","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"\u001b[32mimporting 100%|██████████████████████████████████████████| Time: 0:02:36\u001b[39m","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Here H is the reference panel, each row is a sample and each column is a SNP. The type of H is Union{Missing, Float32}, which potentially allows for missing data. To conserve memory, one could specify UInt8 instead of Float32. Of course, a good reference panel such as the 1000 genomes featured here will have no missing data. ","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"H","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"2504×424147 Matrix{Union{Missing, Float32}}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  1.0  0.0  0.0\n ⋮                        ⋮              ⋱  ⋮                        ⋮    \n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  1.0  1.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Here H_pos contains the position for all SNPs present on chromosome 22 on the reference panel. ","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"H_pos","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"424147-element Vector{Int64}:\n 16050115\n 16050213\n 16050607\n 16050739\n 16050783\n 16050840\n 16050847\n 16050922\n 16050984\n 16051075\n 16051249\n 16051453\n 16051722\n        ⋮\n 51239651\n 51239652\n 51239678\n 51239794\n 51240084\n 51240820\n 51241101\n 51241102\n 51241285\n 51241386\n 51244163\n 51244237","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"On the UK Biobank, 9359 / 9537 SNPs can be mapped to the 1000 genomes on chromosome 22. Note when this number is low, check if the human genome build for the reference panel (here build 37) matches with the GWAS data.","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"xdata = SnpData(\"/scratch/users/bbchu/ukb_fastPHASE/subset/ukb.10k.chr22\")\nxdata.snp_info[!, \"position\"] ∩ H_pos","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"9359-element Vector{Int64}:\n 16495833\n 16870425\n 16888577\n 16952830\n 17054795\n 17056415\n 17057597\n 17068748\n 17070109\n 17072347\n 17079911\n 17080190\n 17091201\n        ⋮\n 51162059\n 51162850\n 51163138\n 51163910\n 51165664\n 51171497\n 51173542\n 51174939\n 51175626\n 51183255\n 51185848\n 51193629","category":"page"},{"location":"man/ghost_knockoffs/#Simulated-Example","page":"Ghost Knockoffs","title":"Simulated Example","text":"","category":"section"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Now suppose we were given the z-scores for 10000 SNPs and their position. Note that a GWAS summary stats file may not contain z-scores, but rather effect sizes, odds-ratios, or p-values. To convert different measures to the standard z-score, I found this reference to be very useful.  ","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Random.seed!(2022)\np = 10000 # number of SNPs\nZ = randn(p) # simulated z-scores\nZ_pos = sort!(rand(16050000:51244000, p)) # simulated position for each SNP","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"10000-element Vector{Int64}:\n 16051161\n 16051964\n 16058006\n 16061965\n 16062797\n 16066970\n 16070158\n 16071335\n 16076125\n 16078197\n 16078220\n 16080831\n 16082209\n        ⋮\n 51197030\n 51203484\n 51209420\n 51211742\n 51211790\n 51215620\n 51222784\n 51227760\n 51227831\n 51231582\n 51235924\n 51238476","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Generating ghost knockoffs is accomplished via the ghost_knockoffs function. Here we employ the MVR construction (which tends to have the highest power) with a moderate window size:","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Z̃ = ghost_knockoffs(Z, Z_pos, H_pos, H, :mvr, windowsize=500)","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"\u001b[32mApproximating covariance by blocks... 100%|██████████████| Time: 0:00:32\u001b[39m\n\n\n\n\n\n10000-element Vector{Float64}:\n  0.5410315696729918\n -0.4246081059629637\n -0.04956798334091112\n -1.5764005812497706\n  0.5281884350544112\n -0.02190687576925561\n  0.5249259412485039\n  1.0111906565388558\n -1.4466613758239868\n  0.2581548620476279\n  0.09210845466626205\n -0.4317124835746688\n  1.0672703288267222\n  ⋮\n  0.45921376701255845\n  1.202714589200995\n  0.6726136982607442\n -0.22241142386162988\n -0.05067713325684163\n -0.6315313886344935\n -0.20778832692909632\n  0.12586124372837243\n  0.37169961989672984\n -0.1551860169036035\n  1.7102480919504381\n -0.03192549553328507","category":"page"},{"location":"man/fixed/fixed/#Fixed-X-knockoffs","page":"Fixed-X Knockoffs","title":"Fixed-X knockoffs","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"This tutorial generates fixed-X knockoffs and checks some of its basic properties. The methodology is described in the following paper","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Barber, Rina Foygel, and Emmanuel J. Candès. \"Controlling the false discovery rate via knockoffs.\" The Annals of Statistics 43.5 (2015): 2055-2085.","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"note: Note\nFor fixed-X knockoffs, we assume n  2p where n is sample size and p is number of covariates, although in principle this method can be adapted to work for n  p case.","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# load packages needed for this tutorial\nusing Revise\nusing Knockoffs\nusing Plots\nusing Random\nusing GLMNet\nusing LinearAlgebra\nusing Distributions\ngr(fmt=:png);","category":"page"},{"location":"man/fixed/fixed/#Generate-knockoffs","page":"Fixed-X Knockoffs","title":"Generate knockoffs","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"We will","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Simulate Gaussian design matrix\nGenerate knockoffs. Here we generate minimum variance-based reconstructability (MVR) knockoffs as described in this paper. MVR and maximum entropy (ME) knockoffs tend to have higher power over SDP or equi-correlated knockoffs. For more options, see the fixed_knockoffs API.","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Random.seed!(2022)   # set random seed for reproducibility\nX = randn(1000, 200) # simulate Gaussian matrix\nnormalize_col!(X)    # normalize columns of X\n\n# make MVR knockoffs\n@time mvr = fixed_knockoffs(X, :mvr);","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"  0.787978 seconds (91 allocations: 21.617 MiB, 34.92% gc time)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"The return type is a Knockoff struct, which contains the following fields","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"struct GaussianKnockoff{T} <: Knockoff\n    X::Matrix{T} # n × p design matrix\n    X̃::Matrix{T} # n × p knockoff of X\n    s::Vector{T} # p × 1 vector. Diagonal(s) and 2Σ - Diagonal(s) are both psd\n    Σ::Symmetric{T, Matrix{T}} # p × p covariance matrix\n    method::Symbol # method for solving s\nend","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Thus, to access these fields, one can do","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"X̃ = mvr.X̃  # type X̃ by X\\tilde<tab>\ns = mvr.s\nΣ = mvr.Σ; # type Σ by \\Sigma<tab>","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"We can check some knockoff properties. For instance, is it true that XtildeX approx Sigma - diag(s)?","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# compare X'X and Σ-diag(s) visually\n[vec(X'*X̃) vec(Σ - Diagonal(s))]","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"40000×2 Matrix{Float64}:\n  0.479139     0.479139\n -0.0184072   -0.0184072\n -0.0274339   -0.0274339\n -0.0359705   -0.0359705\n  0.0202419    0.0202419\n  0.0514162    0.0514162\n  0.0154546    0.0154546\n -0.0250518   -0.0250518\n -0.0468651   -0.0468651\n -0.0358149   -0.0358149\n -0.00507354  -0.00507354\n -0.0238295   -0.0238295\n  0.0140797    0.0140797\n  ⋮           \n  0.0192772    0.0192772\n -0.0157356   -0.0157356\n -0.0116071   -0.0116071\n  0.0338745    0.0338745\n  0.029913     0.029913\n -0.03115     -0.03115\n  0.0437582    0.0437582\n  0.00350153   0.00350153\n  0.00382205   0.00382205\n -0.0072671   -0.0072671\n  0.00966888   0.00966888\n  0.493225     0.493225","category":"page"},{"location":"man/fixed/fixed/#LASSO-example","page":"Fixed-X Knockoffs","title":"LASSO example","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Let us apply the generated knockoffs to the model selection problem","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Given response mathbfy_n times 1, design matrix mathbfX_n times p, we want to select a subset S subset 1p of variables that are truly causal for mathbfy. ","category":"page"},{"location":"man/fixed/fixed/#Simulate-data","page":"Fixed-X Knockoffs","title":"Simulate data","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"We will simulate ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"mathbfy_n times 1 sim N(mathbfX_n times pmathbfbeta_p times 1    mathbfepsilon_n times 1) quad epsilon_i sim N(0 05)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"where k=50 positions of mathbfbeta is non-zero with effect size beta_j sim N(0 1). The goal is to recover those 50 positions using LASSO.","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# set seed for reproducibility\nRandom.seed!(2022)\n\n# simulate true beta\nn, p = size(X)\nk = 50\nβtrue = zeros(p)\nβtrue[1:k] .= 3randn(50)\nshuffle!(βtrue)\n\n# find true causal variables\ncorrect_position = findall(!iszero, βtrue)\n\n# simulate y using normalized X\ny = X * βtrue + rand(Normal(0, 0.5), n);","category":"page"},{"location":"man/fixed/fixed/#Standard-LASSO","page":"Fixed-X Knockoffs","title":"Standard LASSO","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Lets try running standard LASSO, which will produce hatmathbfbeta_p times 1 where we typically declare variable j to be selected if hatbeta_j ne 0. We use LASSO solver in GLMNet.jl package, which is just a Julia wrapper for the GLMnet Fortran code. ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"How well does LASSO perform in terms of power and FDR?","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# run 10-fold cross validation to find best λ minimizing MSE\nlasso_cv = glmnetcv(X, y)\nλbest = lasso_cv.lambda[argmin(lasso_cv.meanloss)]\n\n# use λbest to fit LASSO on full data\nβlasso = glmnet(X, y, lambda=[λbest]).betas[:, 1]\n\n# check power and false discovery rate\npower = length(findall(!iszero, βlasso) ∩ correct_position) / k\nFDR = length(setdiff(findall(!iszero, βlasso), correct_position)) / count(!iszero, βlasso)\nprintln(\"Lasso power = $power, FDR = $FDR\")","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Lasso power = 0.86, FDR = 0.5222222222222223","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Although LASSO have pretty high power, about half of all discoveries are false positives. ","category":"page"},{"location":"man/fixed/fixed/#KnockoffLASSO","page":"Fixed-X Knockoffs","title":"Knockoff+LASSO","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Now lets try applying the knockoff methodology. Recall that consists of a few steps ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Run LASSO on mathbfX mathbftildeX\nCompare feature importance score W_j = textscore(x_j) - textscore(tildex_j) for each j = 1p. Here we use W_j = beta_j - tildebeta_j\nChoose target FDR q in 0 1 and compute ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"tau = min_tleftt  0 fracj W_j  -tmax(1 j W_j  t) le qright","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"note: Note\nIn step 1, mathbfX mathbftildeX is written for notational convenience. In practice one must interleave knockoffs with the original variables, where either the knockoff come first or the original genotype come first with equal probability. This is due to the inherent bias of LASSO solvers: when the original and knockoff variable are equally valid, the one listed first will be selected. ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"@time knockoff_filter = fit_lasso(y, X, mvr.X̃);","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"  6.628466 seconds (6.79 M allocations: 526.499 MiB, 3.44% gc time, 59.50% compilation time)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"The return type is now a KnockoffFilter, which contains the following information","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"struct KnockoffFilter{T}\n    XX̃ :: Matrix{T} # n × 2p matrix of original X and its knockoff interleaved randomly\n    original :: Vector{Int} # p × 1 vector of indices of XX̃ that corresponds to X\n    knockoff :: Vector{Int} # p × 1 vector of indices of XX̃ that corresponds to X̃\n    W :: Vector{T} # p × 1 vector of feature-importance statistics for fdr level fdr\n    βs :: Vector{Vector{T}} # βs[i] is the p × 1 vector of effect sizes corresponding to fdr level fdr_target[i]\n    a0 :: Vector{T}   # intercepts for each model in βs\n    τs :: Vector{T}   # knockoff threshold for selecting Ws correponding to each FDR\n    fdr_target :: Vector{T} # target FDR level for each τs and βs\n    debiased :: Bool # whether βs and a0 have been debiased\nend","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Given these information, we can e.g. visualize power and FDR trade-off:","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"FDR = knockoff_filter.fdr_target\nempirical_power = Float64[]\nempirical_fdr = Float64[]\nfor i in eachindex(FDR)\n    # extract beta for current fdr\n    βknockoff = knockoff_filter.βs[i]\n    \n    # compute power and false discovery proportion\n    power = length(findall(!iszero, βknockoff) ∩ correct_position) / k\n    fdp = length(setdiff(findall(!iszero, βknockoff), correct_position)) / max(count(!iszero, βknockoff), 1)\n    push!(empirical_power, power)\n    push!(empirical_fdr, fdp)\nend\n\n# visualize FDR and power\npower_plot = plot(FDR, empirical_power, xlabel=\"Target FDR\", ylabel=\"Empirical power\", legend=false, w=2)\nfdr_plot = plot(FDR, empirical_fdr, xlabel=\"Target FDR\", ylabel=\"Empirical FDR\", legend=false, w=2)\nPlots.abline!(fdr_plot, 1, 0, line=:dash)\nplot(power_plot, fdr_plot)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Conclusion: ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"LASSO + knockoffs controls the false discovery rate at below the target (dashed line). Thus, one trade power for FDR control. \nThe power of standard LASSO is better, but it comes with high empirical FDR that one cannot control via cross validation. ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"If we repeated the simulation multiple times, we expect the empirical FDR to hug the target FDR more closely.","category":"page"},{"location":"#Knockoffs.jl","page":"Home","title":"Knockoffs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a Julia implementation of the knockoff filter. The knockoff filter is a general framework for controlling the false discovery rate when performing variable selection. As the name suggests, the knockoff filter operates by manufacturing knockoff variables that are cheap — their construction does not require collecting any new data — and are designed to mimic the correlation structure found within the original variables. The knockoffs serve as negative controls and they allow one to identify the truly important predictors, while controlling the false discovery rate (FDR) — the expected fraction of false discoveries among all discoveries.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Within Julia,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"add https://github.com/biona001/Knockoffs.jl\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package supports Julia v1.6+.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/fixed/fixed.md\",\n    \"man/modelX/modelX.md\",\n    \"man/fastphase_hmm/fastphase_hmm.md\",\n    \"man/shapeit_hmm.md\",\n    \"man/knockoffscreen/knockoffscreen.md\",\n    \"man/ghost_knockoffs.md\",\n    \"man/api.md\"\n]\nDepth = 2","category":"page"},{"location":"man/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"Here is a list of available function calls. A detailed description can be found below. ","category":"page"},{"location":"man/api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"man/api/#Generating-knockoffs","page":"API","title":"Generating knockoffs","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"  fixed_knockoffs\n  modelX_gaussian_knockoffs\n  approx_modelX_gaussian_knockoffs\n  hmm_knockoff\n  full_knockoffscreen\n  ghost_knockoffs\n  solve_s\n  solve_MVR\n  solve_max_entropy\n  solve_sdp_fast\n  solve_SDP","category":"page"},{"location":"man/api/#Knockoffs.fixed_knockoffs","page":"API","title":"Knockoffs.fixed_knockoffs","text":"fixed_knockoffs(X::Matrix{T}; method=:sdp)\n\nCreates fixed-X knockoffs. \n\nInputs\n\nX: A n × p numeric matrix, each row is a sample, and each column is covariate.\nmethod: Can be one of the following\n:mvr: Minimum variance-based reconstructability knockoffs (alg 1 in ref 2)\n:maxent: Maximum entropy knockoffs (alg 2 in ref 2)\n:equi: Equi-distant knockoffs (eq 2.3 in ref 1), \n:sdp: SDP knockoffs (eq 2.4 in ref 1)\n:sdp_fast: SDP knockoffs via coordiate descent (alg 2.2 in ref 3)\nkwargs...: Possible optional inputs to method, see solve_MVR,    solve_max_entropy, and solve_sdp_fast\n\nOutput\n\nKnockoff: A struct containing the original (column-normalized) X and its knockoff X̃,    in addition to other variables (e.g. s)\n\nReference\n\n\"Controlling the false discovery rate via Knockoffs\" by Barber and Candes (2015).\n\"Powerful knockoffs via minimizing reconstructability\" by Spector, Asher, and Lucas Janson (2020)\n\"FANOK: Knockoffs in Linear Time\" by Askari et al. (2020).\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.modelX_gaussian_knockoffs","page":"API","title":"Knockoffs.modelX_gaussian_knockoffs","text":"modelX_gaussian_knockoffs(X::Matrix, method::Symbol; [covariance_approximator], [kwargs...])\nmodelX_gaussian_knockoffs(X::Matrix, method::Symbol, μ::Vector, Σ::Matrix; [kwargs...])\n\nCreates model-free multivariate normal knockoffs by sequentially sampling from  conditional multivariate normal distributions. The true mean μ and covariance Σ is estimated from data if not supplied. \n\nInputs\n\nX: A n × p numeric matrix, each row is a sample, and each column is covariate.\nmethod: Can be one of the following\n:mvr for minimum variance-based reconstructability knockoffs (alg 1 in ref 2)\n:maxent for maximum entropy knockoffs (alg 2 in ref 2)\n:equi for equi-distant knockoffs (eq 2.3 in ref 1), \n:sdp for SDP knockoffs (eq 2.4 in ref 1)\n:sdp_fast for SDP knockoffs via coordiate descent (alg 2.2 in ref 3)\nμ: A p × 1 vector of column mean of X\nΣ: A p × p matrix of covariance of X\ncovariance_approximator: A covariance estimator, defaults to LinearShrinkage(DiagonalUnequalVariance(), :lw).   See CovarianceEstimation.jl for more options.\nkwargs...: Possible optional inputs to solvers specified in method, see    solve_MVR, solve_max_entropy, and solve_sdp_fast\n\nReference:\n\n\"Panning for Gold: Model-X Knockoffs for High-dimensional Controlled  Variable Selection\" by Candes, Fan, Janson, and Lv (2018)\n\"Powerful knockoffs via minimizing reconstructability\" by Spector, Asher, and Lucas Janson (2020)\n\"FANOK: Knockoffs in Linear Time\" by Askari et al. (2020).\n\nCovariance Approximation:\n\nThe covariance is approximated by a linear shrinkage estimator using  Ledoit-Wolf with DiagonalUnequalVariance target,  which seems to perform well for p>n cases. We do not simply use cov(X) since isposdef(cov(X)) is typically false. For comparison of various estimators, see: https://mateuszbaran.github.io/CovarianceEstimation.jl/dev/man/msecomp/#msecomp\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.approx_modelX_gaussian_knockoffs","page":"API","title":"Knockoffs.approx_modelX_gaussian_knockoffs","text":"approx_modelX_gaussian_knockoffs(X, method; [windowsize = 500], [covariance_approximator], kwargs...)\napprox_modelX_gaussian_knockoffs(X, method, window_ranges; [covariance_approximator], kwargs...)\n\nGenerates Gaussian knockoffs by approximating the covariance as a block diagonal matrix.  Each block contains windowsize consecutive features. \n\nInputs\n\nX: A n × p numeric matrix or SnpArray. Each row is a sample, and each column is covariate.\nmethod: Can be one of the following\n:mvr for minimum variance-based reconstructability knockoffs (alg 1 in ref 2)\n:maxent for maximum entropy knockoffs (alg 2 in ref 2)\n:equi for equi-distant knockoffs (eq 2.3 in ref 1), \n:sdp for SDP knockoffs (eq 2.4 in ref 1)\n:sdp_fast for SDP knockoffs via coordiate descent (alg 2.2 in ref 3)\nwindowsize: Number of covariates to be included in a block. Each block consists of   adjacent variables. The last block could contain less than windowsize variables. \nwindow_ranges: Vector of ranges for each window. e.g. [1:97, 98:200, 201:500]\ncovariance_approximator: A covariance estimator, defaults to LinearShrinkage(DiagonalUnequalVariance(), :lw).   See CovarianceEstimation.jl for more options.\nkwargs...: Possible optional inputs to solvers specified in method, see    solve_MVR, solve_max_entropy, and solve_sdp_fast\n\nMultithreading (todo)\n\nTo enable multiple threads, simply start Julia with >1 threads and this routine will run with all available threads. \n\nCovariance Approximation:\n\nThe covariance is approximated by a LinearShrinkageEstimator using  Ledoit-Wolf shrinkage with DiagonalUnequalVariance target,  which seems to perform well for p>n cases. We do not simply use cov(X) since isposdef(cov(X)) is typically false. For comparison of different estimators, see: https://mateuszbaran.github.io/CovarianceEstimation.jl/dev/man/msecomp/#msecomp\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.hmm_knockoff","page":"API","title":"Knockoffs.hmm_knockoff","text":"hmm_knockoff(plinkname; [datadir], [plink_outfile], [fastphase_outfile], [outdir], [verbose], args...)\n\nGenerates HMM knockoffs from binary PLINK formatted files. This is done by first running fastPHASE, then running Algorithm 2 of \"Gene hunting with hidden Markov model knockoffs\" by Sesia, Sabatti, and Candes\n\nInput\n\nplinkname: Binary PLINK file names without the .bed/.bim/.fam suffix. \n\nOptional arguments\n\ndatadir: Full path to the PLINK and fastPHASE files (default = current directory)\nplink_outfile: Output PLINK format name\nfastphase_outfile: The output file name from fastPHASE's alpha, theta, r files\nargs...: Any parameter that accepted in fastPHASE.fastphase_estim_param()\n\nOutput\n\nplink_outfile.bed: n × p knockoff genotypes\nplink_outfile.bim: SNP mapping file. Knockoff have SNP names ending in \".k\"\nplink_outfile.fam: Sample mapping file, this is a copy of the original plinkname.fam file\nfastphase_outfile_rhat.txt: averaged r hat file from fastPHASE\nfastphase_outfile_alphahat.txt: averaged alpha hat file from fastPHASE\nfastphase_outfile_thetahat.txt: averaged theta hat file from fastPHASE\n\n\n\n\n\nhmm_knockoff(snpdata::SnpData, r::AbstractVecOrMat, θ::AbstractMatrix, α::AbstractMatrix)\n\nGenerates knockoff of snpdata with loaded r, θ, α\n\nInput\n\nSnpData: A SnpData object from SnpArrays\nr: The r vector estimated by fastPHASE\nθ: The θ matrix estimated by fastPHASE\nα: The α matrix estimated by fastPHASE\n\nOptional Inputs\n\noutdir: Output directory for generated knockoffs\nplink_outfile: Output file name for knockoff genotypes\nestimate_δ: If true, will estimate pseudo-FDR by computing a δ value    for each SNP via likelihood ratio bound\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.full_knockoffscreen","page":"API","title":"Knockoffs.full_knockoffscreen","text":"full_knockoffscreen(x::SnpArray; windowsize::Int=100)\n\nGenerates knockoffs X̃ⱼ by on regressing Xⱼ on SNPs knockoffs within a sliding window of width windowsize. \n\nInputs\n\nx: A SnpArray or String for the path of the PLINK .bed file\nwindowsize: Int specifying window width. Defaults to 100\n\nOutputs\n\nX̃: A n × p dense matrix of Float64, each row is a sample.\n\nReferences\n\nHe, Zihuai, Linxi Liu, Chen Wang, Yann Le Guen, Justin Lee, Stephanie Gogarten, Fred Lu et al. \"Identification of putative causal loci in whole-genome sequencing data via knockoff statistics.\" Nature communications 12, no. 1 (2021): 1-18.\nHe, Zihuai, Yann Le Guen, Linxi Liu, Justin Lee, Shiyang Ma, Andrew C. Yang, Xiaoxia Liu et al. \"Genome-wide analysis of common and rare variants via multiple knockoffs at biobank scale, with an application to Alzheimer disease genetics.\" The American Journal of Human Genetics 108, no. 12 (2021): 2336-2353.\n\nTODO\n\nUse ElasticArrays.jl to avoid reallocating design matrix in each loop\nWrite iterator interface to avoid allocating and storing all knockoffs at once\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.ghost_knockoffs","page":"API","title":"Knockoffs.ghost_knockoffs","text":"ghost_knockoffs(Zscores, Z_pos, H_pos, H, method; [windowsize], [covariance_approximator], [kwargs])\n\nGenerate Ghost knockoffs given a list of z-scores (GWAS summary statistic). \n\nInputs\n\nZscores: List of z-score statistics\nZ_pos: A sorted list of SNP position for each SNP in Zscores\nH_pos: A sorted list of SNP position in the reference panel H\nH: A haplotype reference panel. Each row is a sample and each column is a variant.\nmethod: Can be any of the method in approx_modelX_gaussian_knockoffs\nwindowsize: Number of covariates to be included in a block. Each block consists of   adjacent variables. The last block could contain less than windowsize variables. \ncovariance_approximator: A covariance estimator, defaults to LinearShrinkage(DiagonalUnequalVariance(), :lw).   See CovarianceEstimation.jl for more options.\nkwargs...: Possible optional inputs to solvers specified in method, see    solve_MVR, solve_max_entropy, and solve_sdp_fast\n\nReference\n\nHe, Z., Liu, L., Belloy, M. E., Le Guen, Y., Sossin, A., Liu, X., ... & Ionita-Laza, I. (2021).  Summary statistics knockoff inference empowers identification of putative causal variants in  genome-wide association studies. \n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.solve_s","page":"API","title":"Knockoffs.solve_s","text":"solve_s(Σ::AbstractMatrix, method::Symbol; kwargs...)\n\nSolves the vector s for generating knockoffs. Σ can be a general  covariance matrix. \n\nInputs\n\nΣ: A covariance matrix (in general, it is better to supply Symmetric(Σ) explicitly)\nmethod: Can be one of the following\n:mvr for minimum variance-based reconstructability knockoffs (alg 1 in ref 2)\n:maxent for maximum entropy knockoffs (alg 2 in ref 2)\n:equi for equi-distant knockoffs (eq 2.3 in ref 1), \n:sdp for SDP knockoffs (eq 2.4 in ref 1)\n:sdp_fast for SDP knockoffs via coordiate descent (alg 2.2 in ref 3)\nkwargs...: Possible optional inputs to method, see solve_MVR, \nsolve_max_entropy, and solve_sdp_fast\n\nReference\n\n\"Controlling the false discovery rate via Knockoffs\" by Barber and Candes (2015).\n\"Powerful knockoffs via minimizing reconstructability\" by Spector, Asher, and Lucas Janson (2020)\n\"FANOK: Knockoffs in Linear Time\" by Askari et al. (2020).\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Regular-functions","page":"API","title":"Regular functions","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"  coefficient_diff\n  threshold\n  extract_beta\n  compare_correlation\n  compare_pairwise_correlation\n  merge_knockoffs_with_original\n  simulate_AR1\n  shift_until_PSD!\n  normalize_col!\n  decorrelate_knockoffs\n  sample_DMC\n  fit_lasso\n  predict","category":"page"},{"location":"man/api/#Knockoffs.coefficient_diff","page":"API","title":"Knockoffs.coefficient_diff","text":"coefficient_diff(β::AbstractVector, original::AbstractVector{Int}, knockoff::AbstractVector{Int})\n\nReturns the coefficient difference statistic W[j] = |β[j]| - |β[j + p]|  from a univariate (single response) regression, where the jth variable is stored in position original[j] of β, and its knockoff is stored in position knockoff[j]\n\nInputs\n\nβ: Vector of regression coefficients\noriginal: The index of original variables in β\nknockoff: The index of knockoff variables in β\n\n\n\n\n\ncoefficient_diff(β::AbstractVector, groups::Vector{Int}, original::Vector{Int}, knockoff::Vector{Int})\n\nReturns the coefficient difference statistic for grouped variables W[G] = sum{j in G} |β[j]| - sum{j in G} |β[j + p]|.\n\nInputs\n\nβ: 2p × 1 vector of regression coefficients, including original and knockoff effect sizes\ngroups: Vector storing group membership. groups[i] is the group of β[i]\noriginal: The index of original variables in β\nknockoff: The index of knockoff variables in β\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.threshold","page":"API","title":"Knockoffs.threshold","text":"threshold(w::AbstractVector, q::Number, method=:knockoff)\n\nChooses a threshold τ > 0 by setting τ = min{ t > 0 : {#j: w[j] ≤ -t} / {#j: w[j] ≥ t} ≤ q }.\n\nInputs\n\nw: Vector of feature important statistics\nq: target FDR (between 0 and 1)\nmethod: either :knockoff or :knockoff_plus\n\nReference:\n\nEquation 3.10 (method=:knockoff) or 3.11 (method=:knockoff_plus) of  \"Panning for Gold: Model-X Knockoffs for High-dimensional Controlled Variable Selection\" by Candes, Fan, Janson, and Lv (2018)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.extract_beta","page":"API","title":"Knockoffs.extract_beta","text":"extract_beta(β̂_knockoff::Vector, fdr::Number, original::Vector{Int}, knockoff::Vector{Int}, method=:knockoff)\nextract_beta(β̂_knockoff::Vector, fdr::Number, groups::Vector{Int}, original::Vector{Int}, knockoff::Vector{Int}, method=:knockoff)\n\nGiven estimated β of original variables and their knockoffs, compute β for the original design matrix that controls the FDR.\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.compare_correlation","page":"API","title":"Knockoffs.compare_correlation","text":"compare_correlation()\n\nComputes correlation between X[:, i] and X̃[:, i] for each i.\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.compare_pairwise_correlation","page":"API","title":"Knockoffs.compare_pairwise_correlation","text":"compare_pairwise_correlation(X::SnpArray, X̃::SnpArray, snps::Int = size(X, 2))\n\nComputes and returns\n\nr1: correlation between X[:, i] and X[:, j]\nr2: correlation between X[:, i] and X̃[:, i]\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.merge_knockoffs_with_original","page":"API","title":"Knockoffs.merge_knockoffs_with_original","text":"merge_knockoffs_with_original(xdata, x̃data; des::AbstractString = \"knockoff\")\n\nInterleaves the original PLINK genotypes with its knockoff into a single PLINK file.\n\nInputs\n\nxdata: A SnpData or Array{T, 2} of original covariates, or a String that points to the original PLINK file (without .bed/bim/fam suffix)\nx̃data: A SnpData or Array{T, 2} of knockoff covariates, or a String that points to the knockoff PLINK file (without .bed/bim/fam suffix)\ndes: A String for output PLINK file name (without .bed/bim/fam suffix)\n\nOutputs\n\nxfull: A n × 2p array of original and knockoff genotypes. \noriginal: Indices of original genotypes. original[i] is the column number for the ith SNP. \nknockoff: Indices of knockoff genotypes. knockoff[i] is the column number for the ith SNP. \n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.simulate_AR1","page":"API","title":"Knockoffs.simulate_AR1","text":"simulate_AR1(p::Int, a=1, b=1, tol=1e-3, max_corr=1, rho=nothing)\n\nGenerates p-dimensional correlation matrix for AR(1) Gaussian process, where successive correlations are drawn from Beta(a,b) independently. If rho is specified, then the process is stationary with correlation rho.\n\nSource\n\nhttps://github.com/amspector100/knockpy/blob/20eddb3eb60e0e82b206ec989cb936e3c3ee7939/knockpy/dgp.py#L61\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.normalize_col!","page":"API","title":"Knockoffs.normalize_col!","text":"normalize_col!(X::AbstractVecOrMat)\n\nNormalize each column of X so they sum to 1. \n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.decorrelate_knockoffs","page":"API","title":"Knockoffs.decorrelate_knockoffs","text":"decorrelate_knockoffs(plinkfile, original, knockoff, α)\n\nFor each knockoff x̃j, we will randomly choose α% samples uniformly and set  x̃j[i] ~ binomail(2, ρj) where ρj ∈ [0, 1] is the alternate allele frequency of SNP j.\n\nInputs\n\nxdata: A SnpArrays.SnpData storing original and knockoff genotypes from binary PLINK trios\n\nOptional inputs\n\nα: A number between 0 and 1 specifying how many samples for each knockoff should be resampled (defualt 0.1)\noriginal: Indices of original genotypes. @view(xdata.snparray[:, original]) would be the original genotype (default: entries in 2nd column bim file not ending with .k)\nknockoff: Indices of knockoff genotypes. @view(xdata.snparray[:, knockoff]) would be the knockoff genotype (default: entries in 2nd column bim file ending with .k)\noutfile: Output file name (defaults to \"decorrelated_knockoffs\")\noutdir: Directory for storing output file (defaults to current directory)\n\nOutput\n\nxnew: A n × 2p SnpArray where the knockoffs @view(xnew[:, knockoff]) have been decorrelated\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.fit_lasso","page":"API","title":"Knockoffs.fit_lasso","text":"fit_lasso(y, X, method=:mvr, ...)\n\nGenerates model-X knockoffs with method, runs Lasso,  then applies the knockoff-filter.\n\nInputs\n\ny: Response vector\nX: Design matrix\nmethod: Method for knockoff generation (defaults to :mvr)\nd: Distribution of response. Defaults Normal(), for binary response   (logistic regression) use Binomial().\nfdrs: Target FDRs, defaults to [0.01, 0.05, 0.1, 0.25, 0.5]\nfilter_method: Choices are :knockoff (default) or :knockoff_plus\ndebias: Defines how the selected coefficients are debiased. Specify :ls    for least squares (default) or :lasso for Lasso (only running on the    support). To not debias, specify debias=nothing\nkwargs: Additional arguments to input into glmnetcv and glmnet\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Wrapper-functions-for-SHAPEIT-HMM-knockoffs","page":"API","title":"Wrapper functions for SHAPEIT HMM knockoffs","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"There functions will eventually be replaced by Julia wrappers that no longer require user inputs. ","category":"page"},{"location":"man/api/","page":"API","title":"API","text":"  rapid","category":"page"},{"location":"man/api/#Knockoffs.rapid","page":"API","title":"Knockoffs.rapid","text":"rapid(rapid_exe, vcffile, mapfile, d, outfolder, w, r, s, [a])\n\nWrapper for the RaPID program. \n\nInputs\n\nrapid_exe: Full path to the RaPID_v.1.7 executable file\nvcffile: Phased VCF file name\nmapfile: Map file name\nd: Actual Minimum IBD length in cM\noutfolder: Output folder name\nw: Number of SNPs in a window for sub-sampling\nr: Number of runs\ns: Minimum number of successes to consider a hit\n\nOptional Inputs\n\na: If true, ignore MAFs. By default (a=false) the sites are selected at random weighted by their MAFs.\n\n\n\n\n\n","category":"function"}]
}
