var documenterSearchIndex = {"docs":
[{"location":"man/fastphase_hmm/fastphase_hmm/#fastPHASE-HMM-knockoffs","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM knockoffs","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"This is a tutorial for generating (fastPHASE) HMM knockoffs for genome-wide association studies. This kind of knockoffs is suitable for data without population admixture or cryptic relatedness. The methodology is described in the following paper:","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Sesia, Matteo, Chiara Sabatti, and Emmanuel J. Candès. \"Gene hunting with hidden Markov model knockoffs.\" Biometrika 106.1 (2019): 1-18.","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"If your samples have diverse ancestries and/or extensive relatedness, we recommend those samples to be filtered out, or use SHAPEIT-HMM knockoffs.","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# first load packages needed for this tutorial\nusing Revise\nusing SnpArrays\nusing Knockoffs\nusing Statistics\nusing Plots\nusing GLMNet\nusing Distributions\nusing Random\ngr(fmt=:png);","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Step-0:-Prepare-example-data","page":"fastPHASE HMM Knockoffs","title":"Step 0: Prepare example data","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"To illustrate we need example PLINK data, which are available in Knockoffs.jl/data/","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"mouse.(bed/bim/fam) are mouse genotypes with missing data\nmouse.imputed.(bed/bim/fam) are genotypes without missing","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# Path to PLINK data\nmouse_path = joinpath(normpath(Knockoffs.datadir()), \"mouse.imputed\")","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"\"/Users/biona001/.julia/dev/Knockoffs/data/mouse.imputed\"","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Step-1:-Generate-Knockoffs","page":"fastPHASE HMM Knockoffs","title":"Step 1: Generate Knockoffs","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Knockoffs are made using the wrapper function hmm_knockoff. This function does 3 steps sequentially:","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Run fastPHASE on mathbfX_ntimes p to estimate alpha theta r (this step takes 5-10 min for the example data)\nFit and generate knockoff copies of the HMM \nStore knockoffs tildemathbfX_ntimes p in binary PLINK format (by default under a new directory called knockoffs) and return it as a SnpArray","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"@time X̃ = hmm_knockoff(mouse_path, plink_outfile=\"mouse.imputed.fastphase.knockoffs\")","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"seed = 1644450675\n\nThis is fastPHASE 1.4.8\n\nCopyright 2005-2006.  University of Washington. All rights reserved.\nWritten by Paul Scheet, with algorithm developed by Paul Scheet and\nMatthew Stephens in the Department of Statistics at the University of\nWashington.  Please contact pscheet@alum.wustl.edu for questions, or to\nobtain the software visit\nhttp://stephenslab.uchicago.edu/software.html\n\nTotal proportion of missing genotypes: 0.000000\n1940 diploids below missingness threshold, 0 haplotypes\n data read successfully\n1940 diploid individuals, 10150 loci\n\nK selected (by user): \t\t 12\nseed: \t\t\t 1\nno. EM starts: \t\t 1\nEM iterations: \t\t 10\nno. haps from posterior: 0\nNOT using subpopulation labels\n\n\n this is random start no. 1 of 1 for the EM...\n\nseed for this start: 1\n-26738091.04286946\n-11720205.34566784\n-7171267.67432936\n-4803219.04014266\n-3887857.98290528\n-3526175.78761014\n-3347940.68266002\n-3246324.07127825\n-3183163.68989361\n-3139623.34004118\nfinal loglikelihood: -3108467.614822\niterations: 10\n\nwriting parameter estimates to disk\n\n  simulating 0 haplotype configurations for each individual... done.\n\n\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:05:06\u001b[39m\n\n\n\n\nsimulating 0 haplotypes from model: knockoffs/tmp1_hapsfrommodel.out\n1111.844531 seconds (169.60 M allocations: 8.091 GiB, 0.22% gc time, 2.71% compilation time)\n\n\n\n\n\n1940×10150 SnpArray:\n 0x02  0x02  0x02  0x02  0x03  0x02  …  0x03  0x03  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x03  0x03  0x03  0x03  0x03  0x03     0x03  0x03  0x03  0x03  0x03  0x03\n 0x02  0x02  0x03  0x02  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x03  0x03  0x03  0x03  0x03  0x03     0x02  0x02  0x02  0x02  0x02  0x02\n 0x02  0x02  0x02  0x02  0x03  0x02  …  0x03  0x03  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x03  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x03  0x03  0x03  0x03  0x03  0x03     0x02  0x02  0x02  0x02  0x02  0x02\n 0x03  0x03  0x03  0x03  0x03  0x03  …  0x00  0x00  0x00  0x00  0x00  0x00\n 0x02  0x02  0x02  0x02  0x03  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x03  0x03  0x03  0x03  0x03  0x03     0x00  0x00  0x00  0x00  0x00  0x00\n    ⋮                             ⋮  ⋱           ⋮                    \n 0x03  0x03  0x03  0x03  0x03  0x03     0x03  0x03  0x03  0x03  0x03  0x03\n 0x03  0x03  0x03  0x03  0x03  0x03     0x03  0x03  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02  …  0x03  0x03  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x03  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x03  0x03  0x03  0x03  0x03  0x03     0x03  0x03  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x03  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x03  0x03  0x03  0x03  0x03  0x03     0x03  0x03  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x03  0x02  …  0x03  0x03  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x02  0x02  0x03  0x02  0x02  0x02     0x00  0x00  0x00  0x00  0x00  0x00\n 0x00  0x00  0x00  0x00  0x03  0x00     0x03  0x03  0x03  0x03  0x03  0x03","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Optional-parameters","page":"fastPHASE HMM Knockoffs","title":"Optional parameters","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Here are some optional parameters one can tune when fitting the HMM procedure. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"K: Number of haplotype clusters. Defaults to 12\nC: Number of EM iterations before convergence. Defaults to 10.\nn: Number of samples used to fit HMM in fastPHASE. Defaults to using all samples","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"They can be specified via:","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"@time X̃ = hmm_knockoff(mouse_imputed_file,\n    plink_outfile=\"mouse.imputed.fastphase.knockoffs\",\n    K = 12,\n    C = 10,\n    n = 100)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Step-2:-Examine-knockoff-statistics","page":"fastPHASE HMM Knockoffs","title":"Step 2: Examine knockoff statistics","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Lets check if the knockoffs \"make sense\". We will use SnpArrays.jl to import the original and knockoff genotypes, and compare summary statistics using built-in functions comparepairwisecorrelation and compare_correlation","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# import original and knockoff genotypes\nX = SnpArray(mouse_path * \".bed\")\nX̃ = SnpArray(\"knockoffs/mouse.imputed.fastphase.knockoffs.bed\")\nn, p = size(X̃)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"(1940, 10150)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Compare cor(X_i X_j) and cor(X_i tildeX_j). If knockoffs satisfy exchangability, their correlation should be very similar and form a diagonal line. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# look at only pairwise correlation between first 200 snps\nr1, r2 = compare_pairwise_correlation(X, X̃, snps=200)\n\n# make plot\nscatter(r1, r2, xlabel = \"cor(Xi, Xj)\", ylabel=\"cor(Xi, X̃j)\", legend=false)\nPlots.abline!(1, 0, line=:dash)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Plots distribution of cor(X_j tildeX_j) for all j. Ideally, we want cor(X_j tildeX_j) to be small in magnitude (i.e. X and tildeX is very different). Here the knockoffs are tightly correlated with the original genotypes, so they will likely have low power. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"r2 = compare_correlation(X, X̃)\nhistogram(r2, legend=false, xlabel=\"cor(Xi, X̃i)\", ylabel=\"count\")","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#LASSO-example","page":"fastPHASE HMM Knockoffs","title":"LASSO example","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Let us apply the generated knockoffs to the model selection problem. In layman's term, it can be stated as","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Given response mathbfy_n times 1, design matrix mathbfX_n times p, we want to select a subset S subset 1p of variables that are truly causal for mathbfy. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Simulate-data","page":"fastPHASE HMM Knockoffs","title":"Simulate data","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"We will simulate ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"mathbfy_n times 1 sim N(mathbfX_n times pmathbfbeta_p times 1    mathbfepsilon_n times 1) quad epsilon_i sim N(0 1)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"where k=50 positions of mathbfbeta is non-zero with effect size beta_j sim N(0 1). The goal is to recover those 50 positions using LASSO.","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# set seed for reproducibility\nRandom.seed!(2022)\n\n# simulate true beta\nn, p = size(X)\nk = 50\nβtrue = zeros(p)\nβtrue[1:k] .= randn(k)\nshuffle!(βtrue)\n\n# find true causal variables\ncorrect_position = findall(!iszero, βtrue)\n\n# simulate y\ny = X * βtrue + randn(n);","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Standard-LASSO","page":"fastPHASE HMM Knockoffs","title":"Standard LASSO","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Lets try running standard LASSO, which will produce hatmathbfbeta_p times 1 where we typically declare SNP j to be selected if hatbeta_j ne 0. We use LASSO solver in GLMNet.jl package, which is just a Julia wrapper for the GLMnet Fortran code. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"How well does LASSO perform in terms of power and FDR?","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# run 10-fold cross validation to find best λ minimizing MSE\nlasso_cv = glmnetcv(X, y)\nλbest = lasso_cv.lambda[argmin(lasso_cv.meanloss)]\n\n# use λbest to fit LASSO on full data\nβlasso = glmnet(X, y, lambda=[λbest]).betas[:, 1]\n\n# check power and false discovery rate\npower = length(findall(!iszero, βlasso) ∩ correct_position) / k\nFDR = length(setdiff(findall(!iszero, βlasso), correct_position)) / count(!iszero, βlasso)\n\n#summarize\ncount(!iszero, βlasso), power, FDR","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"(356, 0.7, 0.901685393258427)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Observe that ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"LASSO found a total of 364 SNPs\nLASSO found 3550 = 70% of all true predictors\n329/364 SNPs were false positive (false discovery rate is 90%)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#KnockoffLASSO","page":"fastPHASE HMM Knockoffs","title":"Knockoff+LASSO","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Now lets try applying the knockoff methodology. Recall that consists of a few steps ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Run LASSO on mathbfX mathbftildeX\nCompare coefficient difference statistic W_j for each j = 1p. Here we use W_j = beta_j - beta_j knockoff\nChoose target FDR 0 le q le 1 and compute ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"tau = min_tleftt  0 fracj W_j  -tj W_j  t le qright","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"note: Note\nIn step 1, mathbfX mathbftildeX is written for notational convenience. In practice one must interleave knockoffs with the original variables, where either the knockoff come first or the original genotype come first with equal probability. This is due to the inherent bias of LASSO solvers: when the original and knockoff variable are equally valid, the one listed first will be selected. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"# interleave knockoffs with originals\nXfull, original, knockoff = merge_knockoffs_with_original(mouse_path,\n    \"knockoffs/mouse.imputed.fastphase.knockoffs\",\n    des=\"knockoffs/merged\") \nXfull = convert(Matrix{Float64}, Xfull, center=true, scale=true)\n\n# step 1\nknockoff_cv = glmnetcv(Xfull, y)                         # cross validation step\nλbest = knockoff_cv.lambda[argmin(knockoff_cv.meanloss)] # find lambda that minimizes MSE\nβestim = glmnet(Xfull, y, lambda=[λbest]).betas[:, 1]    # refit lasso with best lambda\n\n# target FDR is 0.05, 0.1, ..., 0.5\nFDR = collect(0.05:0.05:0.5)\nempirical_power = Float64[]\nempirical_fdr = Float64[]\nfor fdr in FDR\n    βknockoff = extract_beta(βestim, fdr, original, knockoff) # steps 2-3 happen here\n\n    # compute power and false discovery proportion\n    power = length(findall(!iszero, βknockoff) ∩ correct_position) / k\n    fdp = length(setdiff(findall(!iszero, βknockoff), correct_position)) / max(count(!iszero, βknockoff), 1)\n    push!(empirical_power, power)\n    push!(empirical_fdr, fdp)\nend\n\n# visualize FDR and power\npower_plot = plot(FDR, empirical_power, xlabel=\"Target FDR\", ylabel=\"Empirical power\", legend=false)\nfdr_plot = plot(FDR, empirical_fdr, xlabel=\"Target FDR\", ylabel=\"Empirical FDR\", legend=false)\nPlots.abline!(fdr_plot, 1, 0, line=:dash)\nplot(power_plot, fdr_plot)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"Observe that","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"LASSO + knockoffs controls the false discovery rate at below the target (dashed line)\nThe power of LASSO + knockoffs is lower than standard LASSO","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM Knockoffs","title":"fastPHASE HMM Knockoffs","text":"The empirical FDR should hug the target FDR more closely once we repeated the simulation multiple times and generate the knockoffs in a way so that they are not so correlated with the original genotypes. ","category":"page"},{"location":"man/shapeit_hmm/#SHAPEIT-HMM-knockoffs","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM knockoffs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"This page is a tutorial for generating (SHAPEIT) HMM knockoffs, which is good for controlling FDR in the presence of cryptic relatedness and diverse ancestries. The methodology is described in the following paper:","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Sesia, Matteo, et al. \"False discovery rate control in genome-wide association studies with population structure.\" Proceedings of the National Academy of Sciences 118.40 (2021). ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"This tutorial closely follows the original knockoffgwas tutorial. Currently users need to manually run and process various input/intermediate files, but eventually, we will write native Julia wrappers to circumvent these tedious procedures. Stay tuned. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"note: Note\nIt is highly recommended to run this tutorial on linux machines, because RaPID (for detecting IBD segments) only run on linux. Currently users of windows and macOS machines must assume no IBD segments exist. ","category":"page"},{"location":"man/shapeit_hmm/#Installation","page":"SHAPEIT HMM Knockoffs","title":"Installation","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Install knockoffgwas and its dependencies\nInstall qctools for converting between VCF and BGEN formats\nInstall RaPID for detecting IBD segments (this only run on linux)\nInstall the following Julia packages. Within julia, type","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"]add SnpArrays Distributions ProgressMeter MendelIHT VCFTools StatsBase CodecZlib\n]add https://github.com/biona001/Knockoffs.jl","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Finally, modify these executable path to the ones installed on your local computer. Here the partition_exe is located under the path you installed knockoffgwas: knockoffgwas/knockoffgwas/utils/partition.R.","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"qctools_exe = \"/scratch/users/bbchu/qctool/build/release/qctool_v2.0.7\"\nsnpknock2_exe = \"/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2\"\nrapid_exe = \"/scratch/users/bbchu/RaPID/RaPID_v.1.7\"\npartition_exe = \"/scratch/users/bbchu/knockoffgwas/knockoffgwas/utils/partition.R\";","category":"page"},{"location":"man/shapeit_hmm/#Required-inputs","page":"SHAPEIT HMM Knockoffs","title":"Required inputs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"We need multiple input files to generate knockoffs","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Unphased genotypes in binary PLINK format\nPhased genotypes in VCF and BGEN format: we will simulate haplotypes, store in VCF format, and convert to BGEN using qctools\nNote: knockoffgwas requires only BGEN format, but RaPID requires VCF formats. Hence, the extra conversion\nMap file (providing different group resolution): since data is simulated, we will generate fake map file\nIBD segment file (generated by RaPID which requires VCF inputs)\nVariant partition files (generated by snpknock2, i.e. module 2 of knockoffgwas) \nSample and variant QC files","category":"page"},{"location":"man/shapeit_hmm/#Simulate-genotypes","page":"SHAPEIT HMM Knockoffs","title":"Simulate genotypes","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Our simulation will try to follow","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Adding population structure (admixture & cryptic relatedness): New approaches to population stratification in genome-wide association studies\nHow to simulate siblings: Using Extended Genealogy to Estimate Components of Heritability for 23 Quantitative and Dichotomous Traits","category":"page"},{"location":"man/shapeit_hmm/#Population-structure","page":"SHAPEIT HMM Knockoffs","title":"Population structure","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Specifically, lets simulate genotypes with 2 populations. We simulate 49700 normally differentiated markers and 300 unusually differentiated markers based on allele frequency difference equal to 0.6. Let x_ij be the number of alternate allele count for sample i at SNP j with allele frequency p_j. Also let h_ij 1 denotype haplotype 1 of sample i at SNP j and h_ij 2 the second haplotype. Our simulation model is","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"h_ij 1 sim Bernoulli(p_j) quad h_ij 2 sim Bernoulli(p_j) quad x_ij = h_ij 1 + h_ij 2","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"which is equivalent to  ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"x_ij sim Binomial(2 p_j)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"for unphased data. The allele frequency is p_j = Uniform(0 1) for normally differentiated markers, and ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"p_pop1 j sim Uniform(0 04) quad p_pop2 j = p_pop1 j + 06","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"for abnormally differentiated markers. Each sample is randomly assigned to population 1 or 2. ","category":"page"},{"location":"man/shapeit_hmm/#Sibling-pairs","page":"SHAPEIT HMM Knockoffs","title":"Sibling pairs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Based on the simulated data above, we can randomly sample pairs of individuals and have them produce offspring. Here, half of all offsprings will be siblings with the other half. This is done by first randomly sampling 2 person to represent parent. Assume they have 2 children. Then generate offspring individuals by copying segments of one parent haplotype directly to the corresponding haplotype of the offspring. This recombination event will produce IBD segments. The number of recombination is 1 or 2 per chromosome, and is chosen uniformly across the chromosome. ","category":"page"},{"location":"man/shapeit_hmm/#Step-0:-simulate-genotypes","page":"SHAPEIT HMM Knockoffs","title":"Step 0: simulate genotypes","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Load Julia packages needed for this tutorial","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"using SnpArrays\nusing Knockoffs\nusing DelimitedFiles\nusing Random\nusing LinearAlgebra\nusing Distributions\nusing ProgressMeter\nusing MendelIHT\nusing VCFTools\nusing StatsBase\nusing CodecZlib","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Load helper functions needed for this tutorial (data simulation + some glue code). It is not crucial to understand what they are doing.  ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"\"\"\"\n    simulate_pop_structure(n, p)\n\nSimulate genotypes with K = 2 populations. 300 SNPs will have different allele \nfrequencies between the populations, where 50 of them will be causal\n\n# Inputs\n- `plinkfile`: Output plink file name. \n- `n`: Number of samples\n- `p`: Number of SNPs\n\n# Output\n- `x1`: n×p matrix of the 1st haplotype for each sample. Each row is a haplotype\n- `x2`: n×p matrix of the 2nd haplotype for each sample. `x = x1 + x2`\n- `populations`: Vector of length `n` indicating population membership for eachsample. \n- `diff_markers`: Indices of the differentially expressed alleles.\n\n# Reference\nhttps://www.nature.com/articles/nrg2813\n\"\"\"\nfunction simulate_pop_structure(n::Int, p::Int)\n    # first simulate genotypes treating all samples equally\n    x1 = BitMatrix(undef, n, p)\n    x2 = BitMatrix(undef, n, p)\n    pmeter = Progress(p, 0.1, \"Simulating genotypes...\")\n    @inbounds for j in 1:p\n        d = Bernoulli(rand())\n        for i in 1:n\n            x1[i, j] = rand(d)\n            x2[i, j] = rand(d)\n        end\n        next!(pmeter)\n    end\n    # assign populations and simulate 300 unually differentiated markers\n    populations = rand(1:2, n)\n    diff_markers = sample(1:p, 300, replace=false)\n    @inbounds for j in diff_markers\n        pop1_allele_freq = 0.4rand()\n        pop2_allele_freq = pop1_allele_freq + 0.6\n        pop1_dist = Bernoulli(pop1_allele_freq)\n        pop2_dist = Bernoulli(pop2_allele_freq)\n        for i in 1:n\n            d = isone(populations[i]) ? pop1_dist : pop2_dist\n            x1[i, j] = rand(d)\n            x2[i, j] = rand(d)\n        end\n    end\n    return x1, x2, populations, diff_markers\nend\n\n\"\"\"\n    simulate_IBD(h1::BitMatrix, h2::BitMatrix, k::Int)\n\nSimulate recombination events. Parent haplotypes `h1` and `h2` will be used to generate \n`k` children, then both parent and children haplotypes will be returned. \n\nIn offspring simulation, half of all offsprings will be siblings with the other half.\nThis is done by first randomly sampling 2 samples from to represent parent. Assume they have\n2 children. Then generate offspring individuals by copying segments of the parents haplotype\ndirectly to the offspring to represent IBD segments. The number of segments (i.e. places of\nrecombination) is 1 or 2 per chromosome, and is chosen uniformly across the chromosome. \n\n# Inputs\n- `h1`: `n × p` matrix of the 1st haplotype for each parent. Each row is a haplotype\n- `h2`: `n × p` matrix of the 2nd haplotype for each parent. `H = h1 + h2`\n- `k`: Total number of offsprings\n\n# Output\n- `H1`: `n+k × p` matrix of the 1st haplotype. The first `n` haplotypes are from parents\n    and the next `k` haplotypes are the offsprings. Each row is a haplotype\n- `H2`: `n+k × p` matrix of the 2nd haplotype. `x = x1 + x2`\n\n# References\nhttps://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1003520\n\"\"\"\nfunction simulate_IBD(h1::BitMatrix, h2::BitMatrix, k::Int)\n    n, p = size(h1)\n    iseven(k) || error(\"number of offsprings should be even\")\n    # randomly designate gender for parents\n    sex = bitrand(n)\n    male_idx = findall(x -> x == true, sex)\n    female_idx = findall(x -> x == false, sex)\n    # simulate new samples\n    x1 = falses(k, p)\n    x2 = falses(k, p)\n    fathers = Int[]\n    mothers = Int[]\n    pmeter = Progress(k, 0.1, \"Simulating IBD segments...\")\n    for i in 1:k\n        # assign parents\n        dad = rand(male_idx)\n        mom = rand(female_idx)\n        push!(fathers, dad)\n        push!(mothers, mom)\n        # recombination\n        recombine!(@view(x1[i, :]), @view(x2[i, :]), @view(h1[dad, :]),\n                   @view(h2[dad, :]), @view(h1[mom, :]), @view(h2[mom, :]))\n        # update progress\n        next!(pmeter)\n    end\n    # combine offsprings and parents\n    H1 = [h1; x1]\n    H2 = [h2; x2]\n    return H1, H2, fathers, mothers\nend\n\nfunction recombination_segments(breakpoints::Vector{Int}, snps::Int)\n    start = 1\n    result = UnitRange{Int}[]\n    for bkpt in breakpoints\n        push!(result, start:bkpt)\n        start = bkpt + 1\n    end\n    push!(result, breakpoints[end]+1:snps)\n    return result\nend\n\nfunction recombine!(child_h1, child_h2, dad_h1, dad_h2, mom_h1, mom_h2)\n    p = length(child_h1)\n    recombinations = rand(1:5)\n    breakpoints = sort!(sample(1:p, recombinations, replace=false))\n    segments = recombination_segments(breakpoints, p)\n    for segment in segments\n        dad_hap = rand() < 0.5 ? dad_h1 : dad_h2\n        mom_hap = rand() < 0.5 ? mom_h1 : mom_h2\n        copyto!(@view(child_h1[segment]), @view(dad_hap[segment]))\n        copyto!(@view(child_h2[segment]), @view(mom_hap[segment]))\n    end\nend\n\nfunction write_plink(outfile::AbstractString, x1::AbstractMatrix, x2::AbstractMatrix)\n    n, p = size(x1)\n    x = SnpArray(outfile * \".bed\", n, p)\n    for j in 1:p, i in 1:n\n        c = x1[i, j] + x2[i, j]\n        if c == 0\n            x[i, j] = 0x00\n        elseif c == 1\n            x[i, j] = 0x02\n        elseif c == 2\n            x[i, j] = 0x03\n        else\n            error(\"matrix entries should be 0, 1, or 2 but was $c!\")\n        end\n    end\n    # create .bim file structure: https://www.cog-genomics.org/plink2/formats#bim\n    open(outfile * \".bim\", \"w\") do f\n        for i in 1:p\n            println(f, \"1\\tsnp$i\\t0\\t$(100i)\\t1\\t2\")\n        end\n    end\n    # create .fam file structure: https://www.cog-genomics.org/plink2/formats#fam\n    open(outfile * \".fam\", \"w\") do f\n        for i in 1:n\n            println(f, \"$i\\t1\\t0\\t0\\t1\\t-9\")\n        end\n    end\n    return nothing\nend\n\nfunction make_partition_mapfile(filename, p::Int)\n    map_cM = LinRange(0.0, Int(p / 10000), p)\n    open(filename, \"w\") do io\n        println(io, \"Chromosome\\tPosition(bp)\\tRate(cM/Mb)\\tMap(cM)\")\n        for i in 1:p\n            println(io, \"chr1\\t\", 100i, '\\t', 0.01rand(), '\\t', map_cM[i])\n        end\n    end\nend\n\nfunction make_rapid_mapfile(filename, p::Int)\n    map_cM = LinRange(0.0, Int(p / 10000), p)\n    open(filename, \"w\") do io\n        for i in 1:p\n            println(io, i, '\\t', map_cM[i])\n        end\n    end\nend\n\nfunction process_rapid_output(inputfile, outputfile)\n    writer = open(outputfile, \"w\")\n    df = readdlm(inputfile)\n    println(writer, \"CHR ID1 HID1 ID2 HID2 BP.start BP.end site.start site.end cM FAM1 FAM2\")\n    for r in eachrow(df)\n        chr, id1, id2, hap1, hap2, start_pos, end_pos, genetic_len, start_site, end_site = \n            Int(r[1]), Int(r[2]), Int(r[3]), Int(r[4]), Int(r[5]), Int(r[6]), Int(r[7]),\n            r[8], Int(r[9]), Int(r[10])\n        println(writer, chr, ' ', id1, ' ', hap1, ' ', id2, ' ', hap2, ' ', \n            start_pos, ' ', end_pos, ' ', start_site, ' ', end_site, ' ', \n            genetic_len, ' ', 1, ' ', 1)\n    end\n    close(writer)\nend\n\nfunction make_bgen_samplefile(filename, n)\n    open(filename, \"w\") do io\n        println(io, \"ID_1 ID_2 missing sex\")\n        println(io, \"0 0 0 D\")\n        for i in 1:n\n            println(io, \"$i 1 0 1\")\n        end\n    end \nend","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"make_bgen_samplefile (generic function with 1 method)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Simulate phased data with 2 populations, 49700 usually differentiated markers, and 300 unusually differentiated markers. Then simulate mating, which generates IBD segments. Finally, make unphased data from offspring haplotypes. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"# simulate phased genotypes\nRandom.seed!(2021)\noutfile = \"sim\"\nn = 2000\np = 50000\nh1, h2, populations, diff_markers = simulate_pop_structure(n, p)\n\n# simulate random mating to get IBD segments\noffsprings = 100\nx1, x2 = simulate_IBD(h1, h2, offsprings)\n\n# write phased genotypes to VCF format\nwrite_vcf(\"sim.phased.vcf.gz\", x1, x2)\n\n# write unphased genotypes to PLINK binary format\nwrite_plink(outfile, x1, x2)\n\n# save pop1/pop2 index and unually differentiated marker indices\nwritedlm(\"populations.txt\", populations)\nwritedlm(\"diff_markers.txt\", diff_markers)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"\u001b[32mSimulating genotypes...100%|████████████████████████████| Time: 0:00:01\u001b[39m\n\u001b[32mWriting VCF...100%|█████████████████████████████████████| Time: 0:00:24\u001b[39m","category":"page"},{"location":"man/shapeit_hmm/#Step-1:-Partitions","page":"SHAPEIT HMM Knockoffs","title":"Step 1: Partitions","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"We need","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Map file (in particular the (cM) field will determine group resolution)\nPLINK's bim file\nQC file (all SNP names that pass QC)\noutput file name","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Since data is simulated, there are no genomic map file. Let us generate a fake one. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"# generate fake map file\nmake_partition_mapfile(\"sim.partition.map\", p)\n\n# also generate QC file that contains all SNPs and all samples\nsnpdata = SnpData(\"sim\")\nsnpIDs = snpdata.snp_info[!, :snpid]\nsampleIDs = Matrix(snpdata.person_info[!, 1:2])\nwritedlm(\"variants_qc.txt\", snpIDs)\nwritedlm(\"samples_qc.txt\", sampleIDs)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Now we run the partition script","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"plinkfile = \"sim\"\nmapfile = \"sim.partition.map\"\nqc_variants = \"variants_qc.txt\"\noutfile = \"sim.partition.txt\"\npartition(partition_exe, plinkfile, mapfile, qc_variants, outfile)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Mean group sizes: \n      res_7       res_6       res_5       res_4       res_3       res_2 \n    1.00000    67.75068   349.65035   694.44444  1351.35135  3333.33333 \n      res_1 \n10000.00000 \nPartitions written to: sim.partition.txt\n\n\n\n\n\nProcess(`\u001b[4mRscript\u001b[24m \u001b[4m--vanilla\u001b[24m \u001b[4m/scratch/users/bbchu/knockoffgwas/knockoffgwas/utils/partition.R\u001b[24m \u001b[4msim.partition.map\u001b[24m \u001b[4msim.bim\u001b[24m \u001b[4mvariants_qc.txt\u001b[24m \u001b[4msim.partition.txt\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/shapeit_hmm/#Step-2:-Generate-Knockoffs","page":"SHAPEIT HMM Knockoffs","title":"Step 2: Generate Knockoffs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"First generate IBD segment files. We need to generate RaPID's required map file","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"make_rapid_mapfile(\"sim.rapid.map\", p)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Next we run the RaPID software","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"vcffile = \"sim.phased.vcf.gz\"\nmapfile = \"sim.rapid.map\"\noutfolder = \"rapid\"\nd = 3    # minimum IBD length in cM\nw = 3    # number of SNPs per window\nr = 10   # number of runs\ns = 2    # Minimum number of successes to consider a hit\n@time rapid(rapid_exe, vcffile, mapfile, d, outfolder, w, r, s)\n\n# unzip output file\nrun(pipeline(`gunzip -c ./rapid/results.max.gz`, stdout=\"./rapid/results.max\"))","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"┌ Info: RaPID command:\n│ `/scratch/users/bbchu/RaPID/RaPID_v.1.7 -i sim.phased.vcf.gz -g sim.rapid.map -d 3 -o rapid -w 3 -r 10 -s 2`\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:55\n┌ Info: Output directory: rapid\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:56\n\n\nCreate sub-samples..\nDone!\n 43.120301 seconds (3.04 k allocations: 159.828 KiB)\n\n\n\n\n\nProcess(`\u001b[4mgunzip\u001b[24m \u001b[4m-c\u001b[24m \u001b[4m./rapid/results.max.gz\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"countlines(\"./rapid/results.max\") # d = 3, w = 3, r = 10, s = 9","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"140","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Here we identified 140 IBD segments. Because we only simulated 100 offsprings, and all 2000 parents are unrelated, the \"IBD related families\" are small. When there are too many segments, one might have to prune the IBD segments so that the families are not too connected. See this issue for details. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"where the column format is: ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"<chr_name> <sample_id1> <sample_id2> <hap_id1> <hap_id2> <starting_pos_genomic> <ending_pos_genomic> <genetic_length> <starting_site> <ending_site>","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Then we need to do some postprocessing to this output, as described here. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"process_rapid_output(\"./rapid/results.max\", \"sim.snpknock.ibdmap\")","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"The output looks like follows. The last 5 columns (site.start site.end cM FAM1 FAM2) are not actually currently used. They need to be there (the file should have 12 fields in total), but it doesn't matter what values you put in them.","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":";head sim.snpknock.ibdmap","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"CHR ID1 HID1 ID2 HID2 BP.start BP.end site.start site.end cM FAM1 FAM2\n1 29 0 2053 0 100 5000000 0 49999 4.9999 1 1\n1 64 0 2003 1 100 4712700 0 47126 4.71259 1 1\n1 97 1 2051 0 100 5000000 0 49999 4.9999 1 1\n1 99 1 2017 0 967300 5000000 9672 49999 4.03278 1 1\n1 106 1 2024 1 100 4078800 0 40787 4.07868 1 1\n1 151 1 2009 0 100 5000000 0 49999 4.9999 1 1\n1 155 1 2069 0 100 5000000 0 49999 4.9999 1 1\n1 163 1 2073 1 100 3309000 0 33089 3.30887 1 1\n1 231 1 2080 1 1153000 5000000 11529 49999 3.84708 1 1","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Next convert VCF file to BGEN format (note: sample file must be saved separately)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"# convert VCF to BGEN format\noutfile = \"sim.bgen\"\nrun(`$qctools_exe -g $vcffile -og $outfile`)\n\n# then save sample file separately\nmake_bgen_samplefile(\"sim.sample\", n + offsprings)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Welcome to qctool\n(version: 2.0.7, revision )\n\n(C) 2009-2017 University of Oxford\n\nOpening genotype files                                      : [******************************] (1/1,0.0s,32.2/s)\n========================================================================\n\nInput SAMPLE file(s):         Output SAMPLE file:             \"(n/a)\".\nSample exclusion output file:   \"(n/a)\".\n\nInput GEN file(s):\n                                                    (not computed)  \"sim.phased.vcf.gz\"\n                                         (total 1 sources, number of snps not computed).\n                      Number of samples: 2100\nOutput GEN file(s):             \"sim.bgen\"\nOutput SNP position file(s):    (n/a)\nSample filter:                  .\n# of samples in input files:    2100.\n# of samples after filtering:   2100 (0 filtered out).\n\n========================================================================\n\nProcessing SNPs                                             :  (50000/?,169.4s,295.2/s)60.3s,275.2/s)\nTotal: 50000SNPs.\n========================================================================\n\nNumber of SNPs:\n                     -- in input file(s):                 (not computed).\n -- in output file(s):                50000\n\nNumber of samples in input file(s):   2100.\n\nOutput GEN files:                     (50000  snps)  \"sim.bgen\"\n                                      (total 50000 snps).\n========================================================================\n\n\nThank you for using qctool.","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Finally, generate HMM knockoffs by running the following code in the command line directly. You may need to adjust file directories and change parameters. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"bgenfile = \"sim\"\nsample_qc = \"samples_qc.txt\"\nvariant_qc = \"variants_qc.txt\"\nmapfile = \"sim.partition.map\"\npartfile = \"sim.partition.txt\"\nibdfile = \"sim.snpknock.ibdmap\"\nK = 10\ncluster_size_min = 1000 \ncluster_size_max = 10000 \nhmm_rho = 1\nhmm_lambda = 1e-3 \nwindows = 0\nn_threads = 1\nseed = 2021\ncompute_references = true\ngenerate_knockoffs = true\noutfile = \"sim.knockoffs\"\n\n@time snpknock2(snpknock2_exe, bgenfile, sample_qc, variant_qc, mapfile, partfile, ibdfile, \n    K, cluster_size_min, cluster_size_max, hmm_rho, hmm_lambda, windows, n_threads, \n    seed, compute_references, generate_knockoffs, outfile)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"\t+----------------------+\n\t|                      |\n\t|  SNPKNOCK2, v0.3     |\n\t|  July 21, 2020       |\n\t|  Matteo Sesia        |\n\t|                      |\n\t+----------------------+\n\nCopyright (C) 2020 Stanford University.\nDistributed under the GNU GPLv3 open source license.\n\nUse --help for more information.\n\nCommand line arguments:\n  --bgen sim\n  --keep samples_qc.txt\n  --extract variants_qc.txt\n  --map sim.partition.map\n  --part sim.partition.txt\n  --ibd sim.snpknock.ibdmap\n  --K 10\n  --cluster_size_min 1000\n  --cluster_size_max 10000\n  --hmm-rho 1\n  --hmm-lambda 0.001\n  --windows 0\n  --n_threads 1\n  --seed 2021\n  --compute-references\n  --generate-knockoffs\n  --out ./knockoffs/sim.knockoffs\n\nRequested operations:\n  --compute-references\n  --generate_knockoffs\n\n\n\n┌ Info: snpknock2 command:\n│ `/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2 --bgen sim --keep samples_qc.txt --extract variants_qc.txt --map sim.partition.map --part sim.partition.txt --ibd sim.snpknock.ibdmap --K 10 --cluster_size_min 1000 --cluster_size_max 10000 --hmm-rho 1 --hmm-lambda 0.001 --windows 0 --n_threads 1 --seed 2021 --compute-references --generate-knockoffs --out ./knockoffs/sim.knockoffs`\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:100\n┌ Info: Output directory: /home/users/bbchu/hmm/knockoffs\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:101\n\n\n\n--------------------------------------------------------------------------------\nLoading metadata\n--------------------------------------------------------------------------------\nLoading sample information from:\n  sim.sample\nLoading legend from:\n  sim.bim\nLoading partitions from:\n  sim.partition.txt\nLoading IBD segments from:\n  sim.snpknock.ibdmap\nLoaded 140 IBD segments.\n\nPrinting summary of 1 windows:\n     0: 0--50000\nSummary of metadata for chromosome 1:\n  number of samples (after | before filtering) : 2100 | 2100\n  number of SNPs (after | before filtering)    : 50000 | 50000\n  number of variant partitions                 : 7\n  size of genomic windows                      : whole-chromosome\n  number of IBD segments                       : 140\n\n\n--------------------------------------------------------------------------------\nKinship (using only haplotype data)\n--------------------------------------------------------------------------------\nReached 1\nChromosome 1 will be loaded from:\n  haplotype file            : sim.bgen\n  sample file               : sim.sample\n  legend file               : sim.bim\n  thinning factor           : 10\n  sample filter file        : samples_qc.txt\n  variant filter file       : variants_qc.txt\n  number of SNPs            : 5000\n  number of haplotypes      : 4200\n\nReading BGEN file using 1 thread:\n|....................................................................................................|\n|====================================================================================================|\nSolving 1 bifurcating K-means problems using 1 threads.\n\nKinship clusters written to:\n  ./knockoffs/sim.knockoffs_clust.txt\n  ./knockoffs/sim.knockoffs.sample\n\nAssigning references for the whole chromosome using 1 threads: \n|....................................................................................................|\n|\n\n\nBifurcating K-means\nSmallest allowed cluster size: 1000\n step\t cluster\t    size\t    left\t   right\taccepted\nBifurcating K-means completed after 0 steps.\nNumber of clusters: 1.\n\n\n\n====================================================================================================|\n\nReached 2\nIndividual global references written to:\n  ./knockoffs/sim.knockoffs_lref.txt\n\nIndividual local references written to:\n  ./knockoffs/sim.knockoffs_ref.txt\n\n\n--------------------------------------------------------------------------------\nKnockoffs for chromosome 1\n--------------------------------------------------------------------------------\nChromosome 1 will be loaded from:\n  haplotype file            : sim\n  haplotype file format     : bgen\n  sample file               : sim.sample\n  legend file               : sim.bim\n  map file                  : sim.partition.map\n  sample filter file        : samples_qc.txt\n  variant filter file       : variants_qc.txt\n  number of SNPs            : 50000\n  number of windows         : 1\n  number of haplotypes      : 4200\n\nLoading data for chromosome 1\nReading BGEN file using 1 thread:\n|....................................................................................................|\n|====================================================================================================|\n\nInitializing HMM with user-supplied hyperparameters: rho = 1, lambda = 0.001.\n\nHMM parameters written to:\n  ./knockoffs/sim.knockoffs_hmm.txt\n\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res0_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res0_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 50000 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 50000 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res0.bed\n  ./knockoffs/sim.knockoffs_res0.bim\n  ./knockoffs/sim.knockoffs_res0.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res0_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res1_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res1_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 738 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 738 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res1.bed\n  ./knockoffs/sim.knockoffs_res1.bim\n  ./knockoffs/sim.knockoffs_res1.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res1_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res2_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res2_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 143 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 143 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res2.bed\n  ./knockoffs/sim.knockoffs_res2.bim\n  ./knockoffs/sim.knockoffs_res2.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res2_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res3_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res3_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 72 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 72 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res3.bed\n  ./knockoffs/sim.knockoffs_res3.bim\n  ./knockoffs/sim.knockoffs_res3.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res3_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res4_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res4_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 37 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 37 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res4.bed\n  ./knockoffs/sim.knockoffs_res4.bim\n  ./knockoffs/sim.knockoffs_res4.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res4_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res5_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res5_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 15 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 15 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res5.bed\n  ./knockoffs/sim.knockoffs_res5.bim\n  ./knockoffs/sim.knockoffs_res5.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res5_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res6_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res6_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res6.bed\n  ./knockoffs/sim.knockoffs_res6.bim\n  ./knockoffs/sim.knockoffs_res6.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res6_anc.txt\n\nFinished.\n\n1484.517148 seconds (409.38 k allocations: 24.636 MiB, 0.01% compilation time)\n\n\n\n\n\nProcess(`\u001b[4m/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2\u001b[24m \u001b[4m--bgen\u001b[24m \u001b[4msim\u001b[24m \u001b[4m--keep\u001b[24m \u001b[4msamples_qc.txt\u001b[24m \u001b[4m--extract\u001b[24m \u001b[4mvariants_qc.txt\u001b[24m \u001b[4m--map\u001b[24m \u001b[4msim.partition.map\u001b[24m \u001b[4m--part\u001b[24m \u001b[4msim.partition.txt\u001b[24m \u001b[4m--ibd\u001b[24m \u001b[4msim.snpknock.ibdmap\u001b[24m \u001b[4m--K\u001b[24m \u001b[4m10\u001b[24m \u001b[4m--cluster_size_min\u001b[24m \u001b[4m1000\u001b[24m \u001b[4m--cluster_size_max\u001b[24m \u001b[4m10000\u001b[24m \u001b[4m--hmm-rho\u001b[24m \u001b[4m1\u001b[24m \u001b[4m--hmm-lambda\u001b[24m \u001b[4m0.001\u001b[24m \u001b[4m--windows\u001b[24m \u001b[4m0\u001b[24m \u001b[4m--n_threads\u001b[24m \u001b[4m1\u001b[24m \u001b[4m--seed\u001b[24m \u001b[4m2021\u001b[24m \u001b[4m--compute-references\u001b[24m \u001b[4m--generate-knockoffs\u001b[24m \u001b[4m--out\u001b[24m \u001b[4m./knockoffs/sim.knockoffs\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/shapeit_hmm/#Step-3:-Examine-Generated-Knockoffs","page":"SHAPEIT HMM Knockoffs","title":"Step 3: Examine Generated Knockoffs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"The generated knockoffs are saved in binary PLINK format, we can import it using SnpArrays","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"x = SnpArray(\"knockoffs/sim.knockoffs_res0.bed\")","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"2100×100000 SnpArray:\n 0x03  0x03  0x02  0x02  0x03  0x03  …  0x02  0x02  0x02  0x03  0x03  0x03\n 0x02  0x02  0x03  0x03  0x00  0x02     0x02  0x02  0x03  0x03  0x02  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x00  0x03  0x02  0x02  0x02  0x02     0x03  0x02  0x03  0x03  0x03  0x03\n 0x03  0x03  0x00  0x00  0x03  0x02     0x02  0x02  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02  …  0x03  0x03  0x03  0x02  0x03  0x03\n 0x02  0x00  0x00  0x00  0x02  0x02     0x03  0x00  0x02  0x02  0x03  0x03\n 0x02  0x02  0x02  0x02  0x00  0x02     0x02  0x02  0x02  0x03  0x03  0x03\n 0x02  0x03  0x02  0x02  0x03  0x03     0x02  0x02  0x02  0x00  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x00     0x02  0x02  0x02  0x02  0x03  0x03\n 0x03  0x00  0x02  0x03  0x02  0x03  …  0x02  0x02  0x02  0x02  0x03  0x03\n 0x00  0x03  0x03  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x02  0x02  0x03  0x03  0x03  0x03     0x00  0x02  0x02  0x02  0x03  0x03\n    ⋮                             ⋮  ⋱           ⋮                    \n 0x00  0x00  0x03  0x03  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x00  0x02  0x03  0x03  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x00  0x02  0x03  0x03  0x02  0x02  …  0x00  0x00  0x02  0x00  0x03  0x03\n 0x00  0x00  0x02  0x02  0x03  0x03     0x02  0x02  0x03  0x03  0x03  0x03\n 0x00  0x02  0x03  0x03  0x02  0x02     0x00  0x00  0x02  0x02  0x03  0x03\n 0x00  0x00  0x02  0x02  0x03  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x02  0x03  0x02  0x00  0x03  0x02     0x03  0x03  0x00  0x00  0x03  0x03\n 0x03  0x02  0x03  0x00  0x03  0x03  …  0x02  0x02  0x02  0x02  0x03  0x03\n 0x03  0x03  0x02  0x02  0x03  0x03     0x02  0x02  0x03  0x03  0x02  0x02\n 0x03  0x00  0x00  0x00  0x02  0x02     0x02  0x02  0x03  0x03  0x03  0x03\n 0x00  0x03  0x03  0x02  0x02  0x02     0x00  0x00  0x00  0x00  0x03  0x03\n 0x02  0x00  0x00  0x00  0x02  0x02     0x02  0x02  0x02  0x02  0x03  0x03","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Notice there are 100k SNPs: the original 50k SNPs and their knockoffs. Reading the SNP names will tell us which are the originals:","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"snpid = SnpData(\"knockoffs/sim.knockoffs_res0\").snp_info.snpid","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"100000-element Vector{String}:\n \"snp1.k\"\n \"snp1\"\n \"snp2\"\n \"snp2.k\"\n \"snp3.k\"\n \"snp3\"\n \"snp4.k\"\n \"snp4\"\n \"snp5.k\"\n \"snp5\"\n \"snp6\"\n \"snp6.k\"\n \"snp7\"\n ⋮\n \"snp49995\"\n \"snp49995.k\"\n \"snp49996.k\"\n \"snp49996\"\n \"snp49997.k\"\n \"snp49997\"\n \"snp49998.k\"\n \"snp49998\"\n \"snp49999\"\n \"snp49999.k\"\n \"snp50000.k\"\n \"snp50000\"","category":"page"},{"location":"man/shapeit_hmm/#Step-4:-Model-selection-with-knockoffs","page":"SHAPEIT HMM Knockoffs","title":"Step 4: Model selection with knockoffs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"Tutorial for this part coming soon! Basically, one constructs a SnpLinAlg, feed that into MendelIHT.jl, and calculate knockoff statistics afterwards using built-in functions like coefficient_diff and threshold.","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"SnpLinAlg performs compressed linear algebra (often faster than double precision BLAS)\nMendelIHT.jl is a very efficient implementation of the iterative hard thresholding algorithm. For model selection, IHT is known to be superior to standard LASSO, elastic net, and MCP solvers. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"xla = SnpLinAlg{Float64}(x, center=true, scale=true, impute=true)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"2100×100000 SnpLinAlg{Float64}:\n  1.76602    1.68237   -0.311698  …   1.20757    0.0817861   0.12776\n  0.316766   0.246784   1.13646       1.20757  -12.1861      0.12776\n  0.316766   0.246784  -0.311698     -0.22433    0.0817861   0.12776\n -1.13249    1.68237   -0.311698      1.20757    0.0817861   0.12776\n  1.76602    1.68237   -1.75985       1.20757    0.0817861   0.12776\n  0.316766   0.246784  -0.311698  …  -0.22433    0.0817861   0.12776\n  0.316766  -1.1888    -1.75985      -0.22433    0.0817861   0.12776\n  0.316766   0.246784  -0.311698      1.20757    0.0817861   0.12776\n  0.316766   1.68237   -0.311698     -1.65623    0.0817861   0.12776\n  0.316766   0.246784  -0.311698     -0.22433    0.0817861   0.12776\n  1.76602   -1.1888    -0.311698  …  -0.22433    0.0817861   0.12776\n -1.13249    1.68237    1.13646      -0.22433    0.0817861   0.12776\n  0.316766   0.246784   1.13646      -0.22433    0.0817861   0.12776\n  ⋮                               ⋱                         \n -1.13249   -1.1888     1.13646       1.20757    0.0817861   0.12776\n -1.13249    0.246784   1.13646       1.20757    0.0817861   0.12776\n -1.13249    0.246784   1.13646   …  -1.65623    0.0817861   0.12776\n -1.13249   -1.1888    -0.311698      1.20757    0.0817861   0.12776\n -1.13249    0.246784   1.13646      -0.22433    0.0817861   0.12776\n -1.13249   -1.1888    -0.311698     -0.22433    0.0817861   0.12776\n  0.316766   1.68237   -0.311698     -1.65623    0.0817861   0.12776\n  1.76602    0.246784   1.13646   …  -0.22433    0.0817861   0.12776\n  1.76602    1.68237   -0.311698      1.20757  -12.1861     -7.7633\n  1.76602   -1.1888    -1.75985       1.20757    0.0817861   0.12776\n -1.13249    1.68237    1.13646      -1.65623    0.0817861   0.12776\n  0.316766  -1.1888    -1.75985      -0.22433    0.0817861   0.12776","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM Knockoffs","title":"SHAPEIT HMM Knockoffs","text":"","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#KnockoffScreen-knockoffs","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen knockoffs","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"This is a tutorial for generating KnockoffScreen knockoffs for genome-wide association studies. This kind of knockoffs is designed for sequence data that have a lot of rare variants. The methodology is described in the following papers","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"He, Zihuai, Linxi Liu, Chen Wang, Yann Le Guen, Justin Lee, Stephanie Gogarten, Fred Lu et al. \"Identification of putative causal loci in whole-genome sequencing data via knockoff statistics.\" Nature communications 12, no. 1 (2021): 1-18.","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"He, Zihuai, Yann Le Guen, Linxi Liu, Justin Lee, Shiyang Ma, Andrew C. Yang, Xiaoxia Liu et al. \"Genome-wide analysis of common and rare variants via multiple knockoffs at biobank scale, with an application to Alzheimer disease genetics.\" The American Journal of Human Genetics 108, no. 12 (2021): 2336-2353","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"In particular, we generate:","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"beginalign*\nhatX_j = hatbeta_0 + sum_k in B_jhatbeta_kX_k + sum_k in B_j k le j - 1hatgamma_ktildeX_k\nhatepsilon = permute(X_j - hatX_j)\ntildeX_j = hatX_j + hatepsilon\nendalign*","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"where B_j is a ball of variants near j and hatbeta_k hatgamma_k are estimated via least squares. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# first load packages needed for this tutorial\nusing Revise\nusing SnpArrays\nusing Knockoffs\nusing Statistics\nusing Plots\nusing GLMNet\nusing Distributions\nusing Random\ngr(fmt=:png);","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#Step-0:-Prepare-example-data","page":"KnockoffScreen Knockoffs","title":"Step 0: Prepare example data","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"To illustrate we need example PLINK data, which are available in Knockoffs/data/mouse.imputed.(bed/bim/fam)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# Path to PLINK data\nmouse_path = joinpath(normpath(Knockoffs.datadir()), \"mouse.imputed\")","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"\"/Users/biona001/.julia/dev/Knockoffs/data/mouse.imputed\"","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#Step-1:-Generate-Knockoffs","page":"KnockoffScreen Knockoffs","title":"Step 1: Generate Knockoffs","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Knockoffs are made using the wrapper function full_knockoffscreen. An iterator format that streams knockoffs one by one is coming soon.","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"warning: Warning\nThe output of full_knockoffscreen is a dense Float64 matrix, which requires 8np bytes of RAM. Do not call it on large PLINK files. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"@time X̃ = full_knockoffscreen(mouse_path, windowsize=50)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"\u001b[32mGenerating knockoffs100%|███████████████████████████████| Time: 0:01:40\u001b[39m\n\n\n129.793232 seconds (74.18 M allocations: 34.660 GiB, 5.35% gc time, 23.10% compilation time)\n\n\n\n\n\n1940×10150 Matrix{Float64}:\n -0.158027  -0.15993  -0.397849  …   0.663515   0.664671   0.668258\n -0.157256  -0.15993   1.07455       0.663515   0.664671   0.666508\n  1.26416    1.2633    0.914503      0.663515   0.664671   0.669306\n -0.158079  -0.15993  -0.412851      0.663515   0.664671   0.667707\n  1.2641     1.2633    1.05954      -1.17537   -1.17217   -1.16703\n -0.15979   -0.15993  -0.412641  …   0.663515   0.664671   0.66629\n -0.159042  -0.15993   0.258318      0.663515   0.664671   0.669239\n -0.158219  -0.15993   1.0255        0.663515   0.664671   0.665875\n -0.156292  -0.15993   1.07454       0.663515   0.664671   0.667836\n  1.26493    1.2633    1.07325      -1.17537   -1.17217   -1.16801\n  1.26685    1.2633    0.258326  …  -3.01425   -3.00901   -3.00042\n -0.157256  -0.15993  -0.397863      0.663515   0.664671   0.669154\n  1.26332    1.2633    1.06682      -3.01425   -3.00901   -3.00326\n  ⋮                              ⋱                        \n  1.26412    1.2633    1.0803        0.663515   0.664671   0.669112\n  1.26589    1.2633    1.02462       0.663515   0.664671   0.669181\n -0.158027  -0.15993  -0.411348  …   0.663515   0.664671   0.667478\n -0.158219  -0.15993  -0.470753      0.663515   0.664671   0.665076\n  1.26493    1.2633    1.04758       0.663515   0.664671   0.666428\n -0.158306  -0.15993  -0.399157      0.663515   0.664671   0.669292\n  1.26589    1.2633    0.258319      0.663515   0.664671   0.669402\n -0.158023  -0.15993  -0.446907  …   0.663515   0.664671   0.666399\n -0.15899   -0.15993   0.257012      0.663515   0.664671   0.668106\n -0.159269  -0.15993   1.07455       0.663515   0.664671   0.666293\n -0.156292  -0.15993  -0.576227     -3.01425   -3.00901   -3.00041\n -1.58241   -1.58316  -1.88373       0.663515   0.664671   0.66915","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#Step-2:-Examine-knockoff-statistics","page":"KnockoffScreen Knockoffs","title":"Step 2: Examine knockoff statistics","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Lets check if the knockoffs \"make sense\". For example, we can compare SNP 1 and its knockoff (which are very similar):","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# import original genotypes into numeric matrix\nX = convert(Matrix{Float64}, SnpArray(mouse_path * \".bed\"), center=true, scale=true)\n\n# compare SNP 1 with its knockoff\n[X[:, 1] X̃[:, 1]]","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"1940×2 Matrix{Float64}:\n -0.159187  -0.158027\n -0.159187  -0.157256\n  1.26396    1.26416\n -0.159187  -0.158079\n  1.26396    1.2641\n -0.159187  -0.15979\n -0.159187  -0.159042\n -0.159187  -0.158219\n -0.159187  -0.156292\n  1.26396    1.26493\n  1.26396    1.26685\n -0.159187  -0.157256\n  1.26396    1.26332\n  ⋮         \n  1.26396    1.26412\n  1.26396    1.26589\n -0.159187  -0.158027\n -0.159187  -0.158219\n  1.26396    1.26493\n -0.159187  -0.158306\n  1.26396    1.26589\n -0.159187  -0.158023\n -0.159187  -0.15899\n -0.159187  -0.159269\n -0.159187  -0.156292\n -1.58233   -1.58241","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Lets also compare cor(X_i X_j) and cor(X_i tildeX_j). If knockoffs satisfy exchangability, their correlation should be very similar and form a diagonal line. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# look at pairwise correlation (between first 200 snps)\nr1, r2 = Float64[], Float64[]\nfor i in 1:200, j in 1:i\n    push!(r1, cor(@view(X[:, i]), @view(X[:, j])))\n    push!(r2, cor(@view(X[:, i]), @view(X̃[:, j])))\nend\n\n# make plot\nscatter(r1, r2, xlabel = \"cor(Xi, Xj)\", ylabel=\"cor(Xi, X̃j)\", legend=false)\nPlots.abline!(1, 0, line=:dash)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Plots distribution of cor(X_j tildeX_j) for all j. Ideally, we want cor(X_j tildeX_j) to be small in magnitude (i.e. X and tildeX is very different). Here the knockoffs are tightly correlated with the original genotypes, so they will likely have low power. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"r2 = Float64[]\nfor j in 1:size(X, 2)\n    push!(r1, cor(@view(X[:, j]), @view(X[:, j])))\n    push!(r2, cor(@view(X[:, j]), @view(X̃[:, j])))\nend\nhistogram(r2, legend=false, xlabel=\"cor(Xj, X̃j)\", ylabel=\"count\")","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#LASSO-example","page":"KnockoffScreen Knockoffs","title":"LASSO example","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Let us apply the generated knockoffs to the model selection problem. In layman's term, it can be stated as","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Given response mathbfy_n times 1, design matrix mathbfX_n times p, we want to select a subset S subset 1p of variables that are truly causal for mathbfy. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#Simulate-data","page":"KnockoffScreen Knockoffs","title":"Simulate data","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"We will simulate ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"mathbfy_n times 1 sim N(mathbfX_n times pmathbfbeta_p times 1    mathbfepsilon_n times 1) quad epsilon_i sim N(0 1)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"where k=50 positions of mathbfbeta is non-zero with effect size beta_j sim N(0 1). The goal is to recover those 50 positions using LASSO.","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# set seed for reproducibility\nRandom.seed!(999)\n\n# simulate true beta\nn, p = size(X)\nk = 50\nβtrue = zeros(p)\nβtrue[1:k] .= randn(k)\nshuffle!(βtrue)\n\n# find true causal variables\ncorrect_position = findall(!iszero, βtrue)\n\n# simulate y\ny = X * βtrue + randn(n);","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#Standard-LASSO","page":"KnockoffScreen Knockoffs","title":"Standard LASSO","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Lets try running standard LASSO, which will produce hatmathbfbeta_p times 1 where we typically declare SNP j to be selected if hatbeta_j ne 0. We use LASSO solver in GLMNet.jl package, which is just a Julia wrapper for the GLMnet Fortran code. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"How well does LASSO perform in terms of power and FDR?","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# run 10-fold cross validation to find best λ minimizing MSE\nlasso_cv = glmnetcv(X, y)\nλbest = lasso_cv.lambda[argmin(lasso_cv.meanloss)]\n\n# use λbest to fit LASSO on full data\nβlasso = glmnet(X, y, lambda=[λbest]).betas[:, 1]\n\n# check power and false discovery rate\npower = length(findall(!iszero, βlasso) ∩ correct_position) / k\nFDR = length(setdiff(findall(!iszero, βlasso), correct_position)) / count(!iszero, βlasso)\n\n#summarize\ncount(!iszero, βlasso), power, FDR","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"(414, 0.78, 0.9057971014492754)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Observe that ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"LASSO found a total of 414 SNPs\nLASSO found 3950 = 70% of all true predictors\n375/364 SNPs were false positive (false discovery rate is 90%)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#KnockoffLASSO","page":"KnockoffScreen Knockoffs","title":"Knockoff+LASSO","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Now lets try applying the knockoff methodology. Recall that consists of a few steps ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Run LASSO on mathbfX mathbftildeX\nCompare coefficient difference statistic W_j for each j = 1p. Here we use W_j = beta_j - beta_j knockoff\nChoose target FDR 0 le q le 1 and compute ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"tau = min_tleftt  0 fracj W_j  -tj W_j  t le qright","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"note: Note\nIn step 1, mathbfX mathbftildeX is written for notational convenience. In practice one must interleave knockoffs with the original variables, where either the knockoff come first or the original genotype come first with equal probability. This is due to the inherent bias of LASSO solvers: when the original and knockoff variable are equally valid, the one listed first will be selected. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# interleave knockoffs with originals\nXfull, original, knockoff = merge_knockoffs_with_original(mouse_path,\n    \"knockoffs/mouse.imputed.fastphase.knockoffs\",\n    des=\"knockoffs/merged\") \nXfull = convert(Matrix{Float64}, Xfull, center=true, scale=true)\n\n# step 1\nknockoff_cv = glmnetcv(Xfull, y)                         # cross validation step\nλbest = knockoff_cv.lambda[argmin(knockoff_cv.meanloss)] # find lambda that minimizes MSE\nβestim = glmnet(Xfull, y, lambda=[λbest]).betas[:, 1]    # refit lasso with best lambda\n\n# target FDR is 0.05, 0.1, ..., 0.5\nFDR = collect(0.05:0.05:0.5)\nempirical_power = Float64[]\nempirical_fdr = Float64[]\nfor fdr in FDR\n    βknockoff = extract_beta(βestim, fdr, original, knockoff) # steps 2-3 happen here\n\n    # compute power and false discovery proportion\n    power = length(findall(!iszero, βknockoff) ∩ correct_position) / k\n    fdp = length(setdiff(findall(!iszero, βknockoff), correct_position)) / max(count(!iszero, βknockoff), 1)\n    push!(empirical_power, power)\n    push!(empirical_fdr, fdp)\nend\n\n# visualize FDR and power\npower_plot = plot(FDR, empirical_power, xlabel=\"Target FDR\", ylabel=\"Empirical power\", legend=false)\nfdr_plot = plot(FDR, empirical_fdr, xlabel=\"Target FDR\", ylabel=\"Empirical FDR\", legend=false)\nPlots.abline!(fdr_plot, 1, 0, line=:dash)\nplot(power_plot, fdr_plot)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Observe that","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"LASSO + knockoffs controls the false discovery rate at below the target (dashed line)\nControlled FDR is compensated by slight loss of power","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"The empirical FDR should hug the target FDR more closely once we repeated the simulation multiple times and generate the knockoffs in a way so that they are not so correlated with the original genotypes. ","category":"page"},{"location":"man/fixed/fixed/#Fixed-X-knockoffs","page":"Fixed-X Knockoffs","title":"Fixed-X knockoffs","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"This tutorial generates fixed-X knockoffs and checks some of its basic properties. The methodology is described in the following paper","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Barber, Rina Foygel, and Emmanuel J. Candès. \"Controlling the false discovery rate via knockoffs.\" The Annals of Statistics 43.5 (2015): 2055-2085.","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"note: Note\nFor fixed-X knockoffs, we assume n  2p where n is sample size and p is number of covariates, although in principle this method can be adapted to work for n  p case.","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# load packages needed for this tutorial\nusing Revise\nusing Knockoffs\nusing Plots\nusing Random\nusing GLMNet\nusing LinearAlgebra\ngr(fmt=:png);","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"┌ Info: Precompiling Knockoffs [878bf26d-0c49-448a-9df5-b057c815d613]\n└ @ Base loading.jl:1423","category":"page"},{"location":"man/fixed/fixed/#Generate-knockoffs","page":"Fixed-X Knockoffs","title":"Generate knockoffs","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"We will","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Simulate Gaussian design matrix\nStandardize the columns to mean 0 variance 1\nGenerate knockoffs","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Both equi-correlated and SDP knockoffs are supported. ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Random.seed!(2022)   # set random seed for reproducibility\nX = randn(1000, 200) # simulate Gaussian matrix\nstandardize!(X)      # normalize columns\n\n# make equi-correlated and SDP knockoffs\nAequi = fixed_knockoffs(X, :equi)\nAsdp = fixed_knockoffs(X, :sdp);","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"The return type is a Knockoff struct, which contains the following fields","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"struct Knockoff{T}\n    X::Matrix{T}    # n × p original design matrix\n    X̃::Matrix{T}    # n × p knockoff of X\n    s::Vector{T}    # p × 1 vector. Diagonal(s) and 2Σ - Diagonal(s) are both psd\n    Σ::Matrix{T}    # p × p gram matrix X'X\n    Σinv::Matrix{T} # p × p inv(X'X)\nend","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Thus, to access these fields, one can do","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"X̃ = Asdp.X̃\ns = Asdp.s\nΣ = Asdp.Σ\nΣinv = Asdp.Σinv;","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"We can check some knockoff properties. For instance, is it true that XtildeX approx Sigma - diag(s)?","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# compare X'X and Σ-diag(s) visually\n[vec(X'*X̃) vec(Σ - Diagonal(s))]","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"40000×2 Matrix{Float64}:\n 998.0      998.0\n -18.5421   -18.5421\n -25.4908   -25.4908\n -34.946    -34.946\n  20.1673    20.1673\n  51.0641    51.0641\n  14.7028    14.7028\n -24.1644   -24.1644\n -46.411    -46.411\n -33.7503   -33.7503\n  -4.25934   -4.25934\n -24.1531   -24.1531\n  13.1971    13.1971\n   ⋮        \n  20.4727    20.4727\n -13.4668   -13.4668\n -13.3521   -13.3521\n  33.889     33.889\n  30.8905    30.8905\n -30.8344   -30.8344\n  42.4959    42.4959\n   4.39748    4.39748\n   2.57332    2.57332\n  -7.19466   -7.19466\n   9.84951    9.84951\n 998.0      998.0","category":"page"},{"location":"man/fixed/fixed/#LASSO-example","page":"Fixed-X Knockoffs","title":"LASSO example","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Let us apply the generated knockoffs to the model selection problem. In layman's term, it can be stated as","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Given response mathbfy_n times 1, design matrix mathbfX_n times p, we want to select a subset S subset 1p of variables that are truly causal for mathbfy. ","category":"page"},{"location":"man/fixed/fixed/#Simulate-data","page":"Fixed-X Knockoffs","title":"Simulate data","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"We will simulate ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"mathbfy_n times 1 sim N(mathbfX_n times pmathbfbeta_p times 1    mathbfepsilon_n times 1) quad epsilon_i sim N(0 1)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"where k=50 positions of mathbfbeta is non-zero with effect size beta_j sim N(0 1). The goal is to recover those 50 positions using LASSO.","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# set seed for reproducibility\nRandom.seed!(100)\n\n# simulate true beta\nn, p = size(X)\nk = 50\nβtrue = zeros(p)\nβtrue[1:k] .= randn(50)\nshuffle!(βtrue)\n\n# find true causal variables\ncorrect_position = findall(!iszero, βtrue)\n\n# simulate y\ny = X * βtrue + randn(n);","category":"page"},{"location":"man/fixed/fixed/#Standard-LASSO","page":"Fixed-X Knockoffs","title":"Standard LASSO","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Lets try running standard LASSO, which will produce hatmathbfbeta_p times 1 where we typically declare SNP j to be selected if hatbeta_j ne 0. We use LASSO solver in GLMNet.jl package, which is just a Julia wrapper for the GLMnet Fortran code. ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"How well does LASSO perform in terms of power and FDR?","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# run 10-fold cross validation to find best λ minimizing MSE\nlasso_cv = glmnetcv(X, y)\nλbest = lasso_cv.lambda[argmin(lasso_cv.meanloss)]\n\n# use λbest to fit LASSO on full data\nβlasso = glmnet(X, y, lambda=[λbest]).betas[:, 1]\n\n# check power and false discovery rate\npower = length(findall(!iszero, βlasso) ∩ correct_position) / k\nFDR = length(setdiff(findall(!iszero, βlasso), correct_position)) / count(!iszero, βlasso)\npower, FDR","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"(1.0, 0.5370370370370371)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"It seems LASSO have power 96% (it missed only 2/50 predictors), but the false discovery rate is 54%. This means that although LASSO finds almost every predictor, more than half of all discoveries are false positives. ","category":"page"},{"location":"man/fixed/fixed/#KnockoffLASSO","page":"Fixed-X Knockoffs","title":"Knockoff+LASSO","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Now lets try applying the knockoff methodology. Recall that consists of a few steps ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Run LASSO on mathbfX mathbftildeX\nCompare coefficient difference statistic W_j for each j = 1p. Here we use W_j = beta_j - beta_j knockoff\nChoose target FDR 0 le q le 1 and compute ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"tau = min_tleftt  0 fracj W_j  -tj W_j  t le qright","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"note: Note\nIn step 1, mathbfX mathbftildeX is written for notational convenience. In practice one must interleave knockoffs with the original variables, where either the knockoff come first or the original genotype come first with equal probability. This is due to the inherent bias of LASSO solvers: when the original and knockoff variable are equally valid, the one listed first will be selected. ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# step 1\nXfull, original, knockoff = merge_knockoffs_with_original(X, X̃)\nknockoff_cv = glmnetcv(Xfull, y)\nλbest = knockoff_cv.lambda[argmin(knockoff_cv.meanloss)]\nβestim = glmnet(Xfull, y, lambda=[λbest]).betas[:, 1]\n\n# target FDR is 0.05, 0.1, ..., 0.5\nFDR = collect(0.05:0.05:0.5)\nempirical_power = Float64[]\nempirical_fdr = Float64[]\nfor fdr in FDR\n    βknockoff = extract_beta(βestim, fdr, original, knockoff) # steps 2-3 happen here\n\n    # compute power and false discovery proportion\n    power = length(findall(!iszero, βknockoff) ∩ correct_position) / k\n    fdp = length(setdiff(findall(!iszero, βknockoff), correct_position)) / max(count(!iszero, βknockoff), 1)\n    push!(empirical_power, power)\n    push!(empirical_fdr, fdp)\nend\n\n# visualize FDR and power\npower_plot = plot(FDR, empirical_power, xlabel=\"Target FDR\", ylabel=\"Empirical power\", legend=false)\nfdr_plot = plot(FDR, empirical_fdr, xlabel=\"Target FDR\", ylabel=\"Empirical FDR\", legend=false)\nPlots.abline!(fdr_plot, 1, 0, line=:dash)\nplot(power_plot, fdr_plot)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Observe that","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"LASSO + knockoffs controls the false discovery rate at below the target (dashed line)\nThe power of LASSO + knockoffs is lower than standard LASSO","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"If we repeated the simulation multiple times, we expect the empirical FDR to hug the target FDR more closely.","category":"page"},{"location":"#Knockoffs.jl","page":"Home","title":"Knockoffs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a Julia implementation of the knockoff filter. The knockoff filter is a general framework for controlling the false discovery rate when performing variable selection. As the name suggests, the knockoff filter operates by manufacturing knockoff variables that are cheap — their construction does not require collecting any new data — and are designed to mimic the correlation structure found within the original variables. The knockoffs serve as negative controls and they allow one to identify the truly important predictors, while controlling the false discovery rate (FDR) — the expected fraction of false discoveries among all discoveries.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Within Julia,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"add https://github.com/biona001/Knockoffs.jl\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package supports Julia v1.6+.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/fixed/fixed.md\",\n    \"man/fastphase_hmm/fastphase_hmm.md\",\n    \"man/shapeit_hmm.md\",\n    \"man/knockoffscreen/knockoffscreen.md\",\n    \"man/api.md\"\n]\nDepth = 2","category":"page"},{"location":"man/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"Here is a list of available function calls. A detailed description can be found below. ","category":"page"},{"location":"man/api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"man/api/#Generating-knockoffs","page":"API","title":"Generating knockoffs","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"  fixed_knockoffs\n  modelX_gaussian_knockoffs\n  hmm_knockoff\n  full_knockoffscreen","category":"page"},{"location":"man/api/#Knockoffs.fixed_knockoffs","page":"API","title":"Knockoffs.fixed_knockoffs","text":"fixed_knockoffs(X::Matrix{T}; method=:sdp)\n\nCreates fixed knockoffs based on equation (2.2)-(2.4) of  \"Controlling the false discovery rate via Knockoffs\" by Barber and Candes (2015)\n\nInputs\n\nX: A n × p numeric matrix, each row is a sample, and each column is normalized to mean 0 variance 1 with unit norm. \nmethod: :equi for equi-distant knockoffs (eq 2.3) or :sdp for SDP knockoffs (eq 2.4)\n\nOutput\n\nKnockoff: A struct containing the original X and its knockoff X̃, in addition to other variables (e.g. s)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.modelX_gaussian_knockoffs","page":"API","title":"Knockoffs.modelX_gaussian_knockoffs","text":"modelX_gaussian_knockoffs(X::Matrix{T}, method::Symbol)\n\nCreates model-free multivariate normal knockoffs by sequentially sampling from  conditional multivariate normal distributions. The mean and covariance is  estimated from X. \n\nInputs\n\nX: A n × p numeric matrix. Each row is a sample, and each column is standardized\n\nto mean 0 variance 1. \n\nmethod: Either :equi, :sdp, or :asdp\n\nReference:\n\n\"Panning for Gold: Model-X Knockoffs for High-dimensional Controlled Variable Selection\" by Candes, Fan, Janson, and Lv (2018)\n\ntodo: the SDP routine for this is quite slow for some reason. May need better\n\nway to estimate Σ\n\n\n\n\n\nmodelX_gaussian_knockoffs(X::Matrix{T}, method::Symbol)\n\nCreates model-free multivariate normal knockoffs by sequentially sampling from  conditional multivariate normal distributions. The mean and covariance is  estimated from X. \n\nInputs\n\nX: A n × p numeric matrix. Each row is a sample, and each column is standardized\n\nto mean 0 variance 1. \n\nmethod: Either :equi, :sdp, or :asdp\nμ: Length p vector for mean of each column\nΣ: p × p covariance matrix for each row of X\n\nReference:\n\n\"Panning for Gold: Model-X Knockoffs for High-dimensional Controlled Variable Selection\" by Candes, Fan, Janson, and Lv (2018)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.hmm_knockoff","page":"API","title":"Knockoffs.hmm_knockoff","text":"hmm_knockoff(plinkname; [datadir], [plink_outfile], [fastphase_outfile], [outdir], [verbose], args...)\n\nGenerates HMM knockoffs from binary PLINK formatted files. This is done by first running fastPHASE, then running Algorithm 2 of \"Gene hunting with hidden Markov model knockoffs\" by Sesia, Sabatti, and Candes\n\nInput\n\nplinkname: Binary PLINK file names without the .bed/.bim/.fam suffix. \n\nOptional arguments\n\ndatadir: Full path to the PLINK and fastPHASE files (default = current directory)\nplink_outfile: Output PLINK format name\nfastphase_outfile: The output file name from fastPHASE's alpha, theta, r files\nargs...: Any parameter that accepted in fastPHASE.fastphase_estim_param()\n\nOutput\n\nplink_outfile.bed: n × p knockoff genotypes\nplink_outfile.bim: SNP mapping file. Knockoff have SNP names ending in \".k\"\nplink_outfile.fam: Sample mapping file, this is a copy of the original plinkname.fam file\nfastphase_outfile_rhat.txt: averaged r hat file from fastPHASE\nfastphase_outfile_alphahat.txt: averaged alpha hat file from fastPHASE\nfastphase_outfile_thetahat.txt: averaged theta hat file from fastPHASE\n\n\n\n\n\nhmm_knockoff(snpdata::SnpData, r::AbstractVecOrMat, θ::AbstractMatrix, α::AbstractMatrix)\n\nGenerates knockoff of snpdata with loaded r, θ, α\n\nInput\n\nSnpData: A SnpData object from SnpArrays\nr: The r vector estimated by fastPHASE\nθ: The θ matrix estimated by fastPHASE\nα: The α matrix estimated by fastPHASE\n\nOptional Inputs\n\noutdir: Output directory for generated knockoffs\nplink_outfile: Output file name for knockoff genotypes\nestimate_δ: If true, will estimate pseudo-FDR by computing a δ value    for each SNP via likelihood ratio bound\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.full_knockoffscreen","page":"API","title":"Knockoffs.full_knockoffscreen","text":"full_knockoffscreen(x::SnpArray; windowsize::Int=100)\n\nGenerates knockoffs X̃ⱼ by on regressing Xⱼ on SNPs knockoffs within a sliding window of width windowsize. \n\nInputs\n\nx: A SnpArray or String for the path of the PLINK .bed file\nwindowsize: Int specifying window width. Defaults to 100\n\nOutputs\n\nX̃: A n × p dense matrix of Float64, each row is a sample.\n\nReferences\n\nHe, Zihuai, Linxi Liu, Chen Wang, Yann Le Guen, Justin Lee, Stephanie Gogarten, Fred Lu et al. \"Identification of putative causal loci in whole-genome sequencing data via knockoff statistics.\" Nature communications 12, no. 1 (2021): 1-18.\nHe, Zihuai, Yann Le Guen, Linxi Liu, Justin Lee, Shiyang Ma, Andrew C. Yang, Xiaoxia Liu et al. \"Genome-wide analysis of common and rare variants via multiple knockoffs at biobank scale, with an application to Alzheimer disease genetics.\" The American Journal of Human Genetics 108, no. 12 (2021): 2336-2353.\n\nTODO\n\nUse ElasticArrays.jl to avoid reallocating design matrix in each loop\nWrite iterator interface to avoid allocating and storing all knockoffs at once\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Regular-functions","page":"API","title":"Regular functions","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"  coefficient_diff\n  threshold\n  extract_beta\n  compare_correlation\n  compare_pairwise_correlation\n  merge_knockoffs_with_original\n  standardize!","category":"page"},{"location":"man/api/#Knockoffs.coefficient_diff","page":"API","title":"Knockoffs.coefficient_diff","text":"coefficient_diff(β::AbstractVector, original::AbstractVector{Int}, knockoff::AbstractVector{Int})\n\nReturns the coefficient difference statistic W[j] = |β[j]| - |β[j + p]|  from a univariate (single response) regression, where the jth variable is stored in position original[j] of β, and its knockoff is stored in position knockoff[j]\n\nInputs\n\nβ: Vector of regression coefficients\noriginal: The index of original variables in β\nknockoff: The index of knockoff variables in β\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.threshold","page":"API","title":"Knockoffs.threshold","text":"threshold(w::AbstractVector, q::Number, method=:knockoff)\n\nChooses a threshold τ > 0 by setting τ = min{ t > 0 : {#j: w[j] ≤ -t} / {#j: w[j] ≥ t} ≤ q }.\n\nInputs\n\nw: Vector of feature important statistics\nq: target FDR (between 0 and 1)\nmethod: either :knockoff or :knockoff_plus\n\nReference:\n\nEquation 3.10 (method=:knockoff) or 3.11 (method=:knockoff_plus) of  \"Panning for Gold: Model-X Knockoffs for High-dimensional Controlled Variable Selection\" by Candes, Fan, Janson, and Lv (2018)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.extract_beta","page":"API","title":"Knockoffs.extract_beta","text":"extract_beta(β̂_knockoff::Vector, fdr::Number, original::Vector{Int}, knockoff::Vector{Int}, method=:knockoff)\nextract_beta(β̂_knockoff::Vector, fdr::Number, groups::Vector{Int}, original::Vector{Int}, knockoff::Vector{Int}, method=:knockoff)\n\nGiven estimated β of original variables and their knockoffs, compute β for the original design matrix that controls the FDR.\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.compare_correlation","page":"API","title":"Knockoffs.compare_correlation","text":"compare_correlation()\n\nComputes correlation between X[:, i] and X̃[:, i] for each i.\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.compare_pairwise_correlation","page":"API","title":"Knockoffs.compare_pairwise_correlation","text":"compare_pairwise_correlation(X::SnpArray, X̃::SnpArray, snps::Int = size(X, 2))\n\nComputes and returns\n\nr1: correlation between X[:, i] and X[:, j]\nr2: correlation between X[:, i] and X̃[:, i]\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.merge_knockoffs_with_original","page":"API","title":"Knockoffs.merge_knockoffs_with_original","text":"merge_knockoffs_with_original(xdata, x̃data; des::AbstractString = \"knockoff\")\n\nInterleaves the original PLINK genotypes with its knockoff into a single PLINK file.\n\nInputs\n\nxdata: A SnpData or Array{T, 2} of original covariates, or a String that points to the original PLINK file (without .bed/bim/fam suffix)\nx̃data: A SnpData or Array{T, 2} of knockoff covariates, or a String that points to the knockoff PLINK file (without .bed/bim/fam suffix)\ndes: A String for output PLINK file name (without .bed/bim/fam suffix)\n\nOutputs\n\nxfull: A n × 2p array of original and knockoff genotypes. \noriginal: Indices of original genotypes. original[i] is the column number for the ith SNP. \nknockoff: Indices of knockoff genotypes. knockoff[i] is the column number for the ith SNP. \n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.standardize!","page":"API","title":"Knockoffs.standardize!","text":"standardize!(z::AbstractVecOrMat)\n\nStandardizes each column of z to mean 0 and variance 1. Make sure you  do not standardize the intercept. \n\n\n\n\n\n","category":"function"},{"location":"man/api/#Wrapper-functions-for-SHAPEIT-HMM-knockoffs","page":"API","title":"Wrapper functions for SHAPEIT HMM knockoffs","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"There functions will eventually be replaced by Julia wrappers that no longer require user inputs. ","category":"page"},{"location":"man/api/","page":"API","title":"API","text":"  rapid","category":"page"},{"location":"man/api/#Knockoffs.rapid","page":"API","title":"Knockoffs.rapid","text":"rapid(rapid_exe, vcffile, mapfile, d, outfolder, w, r, s, [a])\n\nWrapper for the RaPID program. \n\nInputs\n\nrapid_exe: Full path to the RaPID_v.1.7 executable file\nvcffile: Phased VCF file name\nmapfile: Map file name\nd: Actual Minimum IBD length in cM\noutfolder: Output folder name\nw: Number of SNPs in a window for sub-sampling\nr: Number of runs\ns: Minimum number of successes to consider a hit\n\nOptional Inputs\n\na: If true, ignore MAFs. By default (a=false) the sites are selected at random weighted by their MAFs.\n\n\n\n\n\n","category":"function"}]
}
