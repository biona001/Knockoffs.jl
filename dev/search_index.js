var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Knockoffs","category":"page"},{"location":"#Knockoffs","page":"Home","title":"Knockoffs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Knockoffs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Knockoffs]","category":"page"},{"location":"#Knockoffs.Knockoff","page":"Home","title":"Knockoffs.Knockoff","text":"A Knockoff is an AbstractMatrix, essentially the matrix [X X̃] of concatenating X̃ to X. If A is a Knockoff, A behaves like a regular matrix and can be inputted into any function that supports inputs of type AbstractMatrix. Basic operations like @view(A[:, 1]) are supported. \n\n\n\n\n\n","category":"type"},{"location":"#Knockoffs.coefficient_diff","page":"Home","title":"Knockoffs.coefficient_diff","text":"coefficient_diff(β::AbstractVector, method=:concat)\n\nReturns the coefficient difference statistic W[j] = |β[j]| - |β[j + p]|  from a univariate (single response) regression. \n\nInputs\n\nβ: Vector of regression coefficients\nmethod: Either :concatenated (default) if all knockoffs are concatenated   at the end (e.g. [XX̃]) or :interleaved if each variable is immediately   followed by its knockoff (e.g. [x₁x̃₁x₂x̃₂...])\n\n\n\n\n\n","category":"function"},{"location":"#Knockoffs.coefficient_diff-2","page":"Home","title":"Knockoffs.coefficient_diff","text":"coefficient_diff(B::AbstractMatrix)\n\nReturns the coefficient difference statistic W[j] = |B[j, 1]| - |B[j + p, 1]| + ... +  |B[j, r]| - |B[j + p, r]| from a multivariate (multiple response) regression. \n\nInputs\n\nβ: Matrix of regression coefficients. Each column is a vector of β. \nmethod: Either :concatenated if all knockoffs are concatenated at the end   (e.g. [XX̃]) or :interleaved if each variable is immediately followed by   its knockoff (e.g. [x₁x̃₁x₂x̃₂...])\n\n\n\n\n\n","category":"function"},{"location":"#Knockoffs.condition-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T, AbstractMatrix{T} where T, AbstractMatrix{T} where T}","page":"Home","title":"Knockoffs.condition","text":"condition(x::AbstractVector, μ::AbstractVector, Σinv::AbstractMatrix, D::AbstractMatrix)\n\nSamples a knockoff x̃ from Gaussian x using conditional distribution formulas:\n\nIf (x, x̃) ~ N((μ, μ), G) where G = [Σ  Σ - D; Σ - D  Σ], then we sample x̃ from  x̃|x = N(x - Dinv(Σ)(x - μ), 2D - Dinv(Σ)*D)\n\ntodo: efficiency\n\n\n\n\n\n","category":"method"},{"location":"#Knockoffs.fixed_knockoffs-Union{Tuple{T}, Tuple{Matrix{T}, Symbol}} where T<:AbstractFloat","page":"Home","title":"Knockoffs.fixed_knockoffs","text":"fixed_knockoffs(X::Matrix{T}; method=:sdp)\n\nCreates fixed knockoffs based on equation (2.2)-(2.4) of  \"Controlling the false discovery rate via Knockoffs\" by Barber and Candes (2015)\n\nInputs\n\nX: A n × p numeric matrix, each row is a sample, and each column is normalized\n\nto mean 0 variance 1 with unit norm. \n\nmethod: :equi for equi-distant knockoffs (eq 2.3) or :sdp for SDP\n\nknockoffs (eq 2.4)\n\nOutput\n\nKnockoff: A struct containing the original X and its knockoff X̃, \n\nin addition to other variables (e.g. s)\n\n\n\n\n\n","category":"method"},{"location":"#Knockoffs.markov_knockoffs-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Home","title":"Knockoffs.markov_knockoffs","text":"markov_knockoffs()\n\nGenerates knockoff of variables distributed as a discrete Markov Chain with K states.\n\nInputs\n\nX: n × p matrix, each row is a sample\nQ: p - 1 vector of matrices. Q[j] is a K × K matrix of transition   probabilities where Q[j][l, k] = P(X{j+1} = k | X{j} = l)\nq: K × 1 vector of initial probabilities\n\nReference\n\nEquations 4-5 of \"Gene hunting with hidden Markov model knockoffs\" by  Sesia, Sabatti, and Candes\n\n\n\n\n\n","category":"method"},{"location":"#Knockoffs.modelX_gaussian_knockoffs-Union{Tuple{T}, Tuple{Matrix{T}, Symbol, Vector{T}}} where T<:AbstractFloat","page":"Home","title":"Knockoffs.modelX_gaussian_knockoffs","text":"modelX_gaussian_knockoffs(X::Matrix{T})\n\nCreates model-free multivariate normal knockoffs by sequentially sampling from  conditional multivariate normal distributions.\n\nInputs\n\nX: A n × p numeric matrix. Each row is a sample, and each column is standardized\n\nto mean 0 variance 1. \n\nReference:\n\n\"Panning for Gold: Model-X Knockoffs for High-dimensional Controlled Variable Selection\" by Candes, Fan, Janson, and Lv (2018)\n\n\n\n\n\n","category":"method"},{"location":"#Knockoffs.threshold-Union{Tuple{T}, Tuple{AbstractVector{T}, Number}, Tuple{AbstractVector{T}, Number, Any}} where T<:AbstractFloat","page":"Home","title":"Knockoffs.threshold","text":"threshold(w::AbstractVector, q::Number, method=:knockoff)\n\nChooses a threshold τ > 0 by setting τ = min{ t > 0 : {#j: w[j] ≤ -t} / {#j: w[j] ≥ -t} ≤ q }.\n\nInputs\n\nw: Vector of feature important statistics\nq: target FDR (between 0 and 1)\nmethod: either :knockoff or :knockoff_plus\n\nReference:\n\nEquation 3.10 (method=:knockoff) or 3.11 (method=:knockoff_plus) of  \"Panning for Gold: Model-X Knockoffs for High-dimensional Controlled Variable Selection\" by Candes, Fan, Janson, and Lv (2018)\n\n\n\n\n\n","category":"method"},{"location":"#Knockoffs.update_normalizing_constants!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Home","title":"Knockoffs.update_normalizing_constants!","text":"update_normalizing_constants!(Q::AbstractMatrix{T}, q::AbstractVector{T})\n\nComputes normalizing constants recursively using equation (5).\n\nInputs\n\nQ: p - 1 vector of matrix. Q[j] is a K × K matrix of transition   probabilities where Q[j][l, k] = P(X{j+1} = k | X{j} = l)\nq: K × 1 vector of initial probabilities\n\ntodo: efficiency\n\n\n\n\n\n","category":"method"}]
}
