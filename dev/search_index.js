var documenterSearchIndex = {"docs":
[{"location":"man/hmm/#Generate-HMM-knockoffs","page":"HMM Knockoffs","title":"Generate HMM knockoffs","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"This tutorial closely follows the knockoffgwas tutorial. We go over how to generate (SHAPEIT) HMM knockoffs given (simulated) genotypes. ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"!!! note\nIt is highly recommended to run this tutorial on linux machines, because RaPID (for detecting IBD segments) only run on linux. Currently users of windows and macOS machines must assume no IBD segments exist.","category":"page"},{"location":"man/hmm/#Installation","page":"HMM Knockoffs","title":"Installation","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Install knockoffgwas and its dependencies\nInstall qctools for converting between VCF and BGEN formats\nInstall RaPID for detecting IBD segments\nInstall the following Julia packages. Within julia, type","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"]add SnpArrays Distributions ProgressMeter MendelIHT VCFTools StatsBase CodecZlib\n]add https://github.com/biona001/Knockoffs.jl","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Finally, modify these executable path to the ones installed on your local computer. Here the partition_exe is located under the path you installed knockoffgwas: knockoffgwas/knockoffgwas/utils/partition.R.","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"qctools_exe = \"/scratch/users/bbchu/qctool/build/release/qctool_v2.0.7\"\nsnpknock2_exe = \"/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2\"\nrapid_exe = \"/scratch/users/bbchu/RaPID/RaPID_v.1.7\"\npartition_exe = \"/scratch/users/bbchu/knockoffgwas/knockoffgwas/utils/partition.R\";","category":"page"},{"location":"man/hmm/#Required-inputs","page":"HMM Knockoffs","title":"Required inputs","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"We need multiple input files to generate knockoffs","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Unphased genotypes in binary PLINK format\nPhased genotypes in VCF and BGEN format: we will simulate haplotypes, store in VCF format, and convert to BGEN using qctools\nNote: knockoffgwas requires only BGEN format, but RaPID requires VCF formats. Hence, the extra conversion\nMap file (providing different group resolution): since data is simulated, we will generate fake map file\nIBD segment file (generated by RaPID which requires VCF inputs)\nVariant partition files (generated by snpknock2, i.e. module 2 of knockoffgwas) \nSample and variant QC files","category":"page"},{"location":"man/hmm/#Simulate-genotypes","page":"HMM Knockoffs","title":"Simulate genotypes","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Our simulation will try to follow","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Adding population structure (admixture & cryptic relatedness): New approaches to population stratification in genome-wide association studies\nHow to simulate siblings: Using Extended Genealogy to Estimate Components of Heritability for 23 Quantitative and Dichotomous Traits","category":"page"},{"location":"man/hmm/#Population-structure","page":"HMM Knockoffs","title":"Population structure","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Specifically, lets simulate genotypes with 2 populations. We simulate 49950 normally differentiated markers and 50 unusually differentiated markers based on allele frequency difference equal to 0.6. Let x_ij be the number of alternate allele count for sample i at SNP j with allele frequency p_j. Also let h_ij 1 denotype haplotype 1 of sample i at SNP j and h_ij 2 the second haplotype. Our simulation model is","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"h_ij 1 sim Bernoulli(p_j) quad h_ij 2 sim Bernoulli(p_j) quad x_ij = h_ij 1 + h_ij 2","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"which is equivalent to  ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"x_ij sim Binomial(2 p_j)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"for unphased data. The allele frequency is p_j = Uniform(0 1) for normally differentiated markers, and ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"p_pop1 j sim Uniform(0 04) quad p_pop2 j = p_pop1 j + 06","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"for abnormally differentiated markers. Each sample is randomly assigned to population 1 or 2. ","category":"page"},{"location":"man/hmm/#Sibling-pairs","page":"HMM Knockoffs","title":"Sibling pairs","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Based on the simulated data above, we can randomly sample pairs of individuals and have them produce offspring. Here, half of all offsprings will be siblings with the other half. This is done by first randomly sampling 2 samples from to represent parent. Assume they have 2 children. Then generate offspring individuals by copying segments of one parent haplotype directly to the corresponding haplotype of the offspring. This recombination event will produce IBD segments. The number of recombination is 1 or 2 per chromosome, and is chosen uniformly across the chromosome. ","category":"page"},{"location":"man/hmm/#Step-0","page":"HMM Knockoffs","title":"Step 0","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Load Julia packages needed for this tutorial","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"using SnpArrays\nusing Knockoffs\nusing DelimitedFiles\nusing Random\nusing LinearAlgebra\nusing Distributions\nusing ProgressMeter\nusing MendelIHT\nusing VCFTools\nusing StatsBase\nusing CodecZlib","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Load helper functions needed for this tutorial (data simulation + some glue code). It is not crucial to understand what they are doing.  ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"\"\"\"\n    simulate_pop_structure(n, p)\n\nSimulate genotypes with K = 2 populations. 300 SNPs will have different allele \nfrequencies between the populations, where 50 of them will be causal\n\n# Inputs\n- `plinkfile`: Output plink file name. \n- `n`: Number of samples\n- `p`: Number of SNPs\n\n# Output\n- `x1`: n×p matrix of the 1st haplotype for each sample. Each row is a haplotype\n- `x2`: n×p matrix of the 2nd haplotype for each sample. `x = x1 + x2`\n- `populations`: Vector of length `n` indicating population membership for eachsample. \n- `diff_markers`: Indices of the differentially expressed alleles.\n\n# Reference\nhttps://www.nature.com/articles/nrg2813\n\"\"\"\nfunction simulate_pop_structure(n::Int, p::Int)\n    # first simulate genotypes treating all samples equally\n    x1 = BitMatrix(undef, n, p)\n    x2 = BitMatrix(undef, n, p)\n    pmeter = Progress(p, 0.1, \"Simulating genotypes...\")\n    @inbounds for j in 1:p\n        d = Bernoulli(rand())\n        for i in 1:n\n            x1[i, j] = rand(d)\n            x2[i, j] = rand(d)\n        end\n        next!(pmeter)\n    end\n    # assign populations and simulate 300 unually differentiated markers\n    populations = rand(1:2, n)\n    diff_markers = sample(1:p, 300, replace=false)\n    @inbounds for j in diff_markers\n        pop1_allele_freq = 0.4rand()\n        pop2_allele_freq = pop1_allele_freq + 0.6\n        pop1_dist = Bernoulli(pop1_allele_freq)\n        pop2_dist = Bernoulli(pop2_allele_freq)\n        for i in 1:n\n            d = isone(populations[i]) ? pop1_dist : pop2_dist\n            x1[i, j] = rand(d)\n            x2[i, j] = rand(d)\n        end\n    end\n    return x1, x2, populations, diff_markers\nend\n\n\"\"\"\n    simulate_IBD(h1::AbstractMatrix, h2::AbstractMatrix, k::Int)\n\nSimulate recombination events. Parent haplotypes `h1` and `h2` will be used to generate \n`k` children, then both parent and children haplotypes will be returned. \n\nIn offspring simulation, half of all offsprings will be siblings with the other half.\nThis is done by first randomly sampling 2 samples from to represent parent. Assume they have\n2 children. Then generate offspring individuals by copying segments of the parents haplotype\ndirectly to the offspring to represent IBD segments. The number of segments (i.e. places of\nrecombination) is 1 or 2 per chromosome, and is chosen uniformly across the chromosome. \n\n# Inputs\n- `h1`: `n × p` matrix of the 1st haplotype for each parent. Each row is a haplotype\n- `h2`: `n × p` matrix of the 2nd haplotype for each parent. `H = h1 + h2`\n- `k`: Total number of offsprings\n\n# Output\n- `H1`: `n+k × p` matrix of the 1st haplotype. The first `n` haplotypes are from parents\n    and the next `k` haplotypes are the offsprings. Each row is a haplotype\n- `H2`: `n+k × p` matrix of the 2nd haplotype. `x = x1 + x2`\n\n# References\nhttps://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1003520\n\"\"\"\nfunction simulate_IBD(h1::AbstractMatrix, h2::AbstractMatrix, k::Int)\n    # first handle errors\n    n, p = size(h1)\n    iseven(k) || error(\"number of offsprings should be even\")\n    # randomly designate gender for parents\n    sex = bitrand(n)\n    male_idx = findall(x -> x == true, sex)\n    female_idx = findall(x -> x == false, sex)\n    # simulate new samples\n    x1 = falses(k, p)\n    x2 = falses(k, p)\n    fathers = Int[]\n    mothers = Int[]\n    pmeter = Progress(k >> 1, 0.1, \"Simulating IBD segments...\")\n    for i in 1:(k >> 1)\n        # assign parents\n        dad = rand(male_idx)\n        mom = rand(female_idx)\n        push!(fathers, dad)\n        push!(mothers, mom)\n        # child 1\n        recombinations = rand(1:2)\n        breakpoints = sort!(sample(1:p, recombinations, replace=false))\n        parent1, parent2 = rand() < 0.5 ? (dad, mom) : (mom, dad)\n        segments = recombination_segments(breakpoints, p)\n        for j in 1:length(segments)\n            parent = isodd(j) ? parent1 : parent2\n            segment = segments[j]\n            # perform recombination\n            parent_hap = rand() < 0.5 ? h1 : h2\n            child_hap = rand() < 0.5 ? x1 : x2\n            copyto!(@view(child_hap[2i - 1, segment]), @view(parent_hap[parent, segment]))\n        end\n        # child 2\n        recombinations = rand(1:2)\n        breakpoints = sort!(sample(1:p, recombinations, replace=false))\n        parent1, parent2 = rand() < 0.5 ? (dad, mom) : (mom, dad)\n        segments = recombination_segments(breakpoints, p)\n        for j in 1:length(segments)\n            parent = isodd(j) ? parent1 : parent2\n            segment = segments[j]\n            # perform recombination\n            parent_hap = rand() < 0.5 ? h1 : h2\n            child_hap = rand() < 0.5 ? x1 : x2\n            copyto!(@view(child_hap[2i - 1, segment]), @view(parent_hap[parent, segment]))\n        end\n        # update progress\n        next!(pmeter)\n    end\n    # combine offsprings and parents\n    H1 = [h1; x1]\n    H2 = [h2; x2]\n    return H1, H2\nend\n\nfunction recombination_segments(breakpoints::Vector{Int}, snps::Int)\n    start = 1\n    result = UnitRange{Int}[]\n    for bkpt in breakpoints\n        push!(result, start:bkpt)\n        start = bkpt + 1\n    end\n    push!(result, breakpoints[end]+1:snps)\n    return result\nend\n\nfunction write_plink(outfile::AbstractString, x1::AbstractMatrix, x2::AbstractMatrix)\n    n, p = size(x1)\n    x = SnpArray(outfile * \".bed\", n, p)\n    for j in 1:p, i in 1:n\n        c = x1[i, j] + x2[i, j]\n        if c == 0\n            x[i, j] = 0x00\n        elseif c == 1\n            x[i, j] = 0x02\n        elseif c == 2\n            x[i, j] = 0x03\n        else\n            error(\"matrix entries should be 0, 1, or 2 but was $c!\")\n        end\n    end\n    # create .bim file structure: https://www.cog-genomics.org/plink2/formats#bim\n    open(outfile * \".bim\", \"w\") do f\n        for i in 1:p\n            println(f, \"1\\tsnp$i\\t0\\t$(100i)\\t1\\t2\")\n        end\n    end\n    # create .fam file structure: https://www.cog-genomics.org/plink2/formats#fam\n    open(outfile * \".fam\", \"w\") do f\n        for i in 1:n\n            println(f, \"$i\\t1\\t0\\t0\\t1\\t-9\")\n        end\n    end\n    return nothing\nend\n\nfunction make_partition_mapfile(filename, p::Int)\n    map_cM = LinRange(0.0, Int(p / 10000), p)\n    open(filename, \"w\") do io\n        println(io, \"Chromosome\\tPosition(bp)\\tRate(cM/Mb)\\tMap(cM)\")\n        for i in 1:p\n            println(io, \"chr1\\t\", 100i, '\\t', 0.01rand(), '\\t', map_cM[i])\n        end\n    end\nend\n\nfunction make_rapid_mapfile(filename, p::Int)\n    map_cM = LinRange(0.0, Int(p / 10000), p)\n    open(filename, \"w\") do io\n        for i in 1:p\n            println(io, i, '\\t', map_cM[i])\n        end\n    end\nend\n\nfunction process_rapid_output(inputfile, outputfile)\n    writer = open(outputfile, \"w\")\n    df = readdlm(inputfile)\n    println(writer, \"CHR ID1 HID1 ID2 HID2 BP.start BP.end site.start site.end cM FAM1 FAM2\")\n    for r in eachrow(df)\n        chr, id1, id2, hap1, hap2, start_pos, end_pos, genetic_len, start_site, end_site = \n            Int(r[1]), Int(r[2]), Int(r[3]), Int(r[4]), Int(r[5]), Int(r[6]), Int(r[7]),\n            r[8], Int(r[9]), Int(r[10])\n        println(writer, chr, ' ', id1, ' ', hap1, ' ', id2, ' ', hap2, ' ', \n            start_pos, ' ', end_pos, ' ', start_site, ' ', end_site, ' ', \n            genetic_len, ' ', 1, ' ', 1)\n    end\n    close(writer)\nend\n\nfunction make_bgen_samplefile(filename, n)\n    open(filename, \"w\") do io\n        println(io, \"ID_1 ID_2 missing sex\")\n        println(io, \"0 0 0 D\")\n        for i in 1:n\n            println(io, \"$i 1 0 1\")\n        end\n    end \nend","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"make_bgen_samplefile (generic function with 1 method)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Simulate phased data with 2 populations, 49700 usually differentiated markers, and 300 unusually differentiated markers. Then simulate mating, which generates IBD segments. Finally, make unphased data from offspring haplotypes. ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# simulate phased genotypes\nRandom.seed!(2021)\noutfile = \"sim\"\nn = 2000\np = 50000\nh1, h2, populations, diff_markers = simulate_pop_structure(n, p)\n\n# simulate random mating to get IBD segments\noffsprings = 100\nx1, x2 = simulate_IBD(h1, h2, offsprings)\n\n# write phased genotypes to VCF format\nwrite_vcf(\"sim.phased.vcf.gz\", x1, x2)\n\n# write unphased genotypes to PLINK binary format\nwrite_plink(outfile, x1, x2)\n\n# save pop1/pop2 index and unually differentiated marker indices\nwritedlm(\"populations.txt\", populations)\nwritedlm(\"diff_markers.txt\", diff_markers)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"\u001b[32mSimulating genotypes...100%|████████████████████████████| Time: 0:00:00\u001b[39m\n\u001b[32mWriting VCF...100%|█████████████████████████████████████| Time: 0:00:24\u001b[39m","category":"page"},{"location":"man/hmm/#Step-1:-Partitions","page":"HMM Knockoffs","title":"Step 1: Partitions","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"We need","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Map file (in particular the (cM) field will determine group resolution)\nPLINK's bim file\nQC file (all SNP names that pass QC)\noutput file name","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Since data is simulated, there are no genomic map file. Let us generate a fake one. ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# generate fake map file\nmake_partition_mapfile(\"sim.partition.map\", p)\n\n# also generate QC file that contains all SNPs and all samples\nsnpdata = SnpData(\"sim\")\nsnpIDs = snpdata.snp_info[!, :snpid]\nsampleIDs = Matrix(snpdata.person_info[!, 1:2])\nwritedlm(\"variants_qc.txt\", snpIDs)\nwritedlm(\"samples_qc.txt\", sampleIDs)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Now we run the partition script","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"plinkfile = \"sim\"\nmapfile = \"sim.partition.map\"\nqc_variants = \"variants_qc.txt\"\noutfile = \"sim.partition.txt\"\npartition(partition_exe, plinkfile, mapfile, qc_variants, outfile)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Mean group sizes: \n      res_7       res_6       res_5       res_4       res_3       res_2 \n    1.00000    67.75068   349.65035   694.44444  1351.35135  3333.33333 \n      res_1 \n10000.00000 \nPartitions written to: sim.partition.txt\n\n\nWarning messages:\n1: Quick-TRANSfer stage steps exceeded maximum (= 2500000) \n2: Quick-TRANSfer stage steps exceeded maximum (= 2500000) \n3: Quick-TRANSfer stage steps exceeded maximum (= 2500000) \n4: Quick-TRANSfer stage steps exceeded maximum (= 2500000) \n\n\n\n\n\nProcess(`\u001b[4mRscript\u001b[24m \u001b[4m--vanilla\u001b[24m \u001b[4m/scratch/users/bbchu/knockoffgwas/knockoffgwas/utils/partition.R\u001b[24m \u001b[4msim.partition.map\u001b[24m \u001b[4msim.bim\u001b[24m \u001b[4mvariants_qc.txt\u001b[24m \u001b[4msim.partition.txt\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/hmm/#Step-2:-Generate-Knockoffs","page":"HMM Knockoffs","title":"Step 2: Generate Knockoffs","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"First generate IBD segment files. We need to generate RaPID's required map file","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"make_rapid_mapfile(\"sim.rapid.map\", p)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Next we run the RaPID software","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"vcffile = \"sim.phased.vcf.gz\"\nmapfile = \"sim.rapid.map\"\noutfolder = \"rapid\"\nd = 3    # minimum IBD length in cM\nw = 3    # number of SNPs per window\nr = 10   # number of runs\ns = 9    # Minimum number of successes to consider a hit\n@time rapid(rapid_exe, vcffile, mapfile, d, outfolder, w, r, s)\n\n# unzip output file\nrun(pipeline(`gunzip -c ./rapid/results.max.gz`, stdout=\"./rapid/results.max\"))","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Create sub-samples..\nDone!\n 42.199697 seconds (2.98 k allocations: 151.328 KiB)\n\n\n┌ Info: RaPID command:\n│ `/scratch/users/bbchu/RaPID/RaPID_v.1.7 -i sim.phased.vcf.gz -g sim.rapid.map -d 3 -o rapid -w 3 -r 10 -s 9`\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:55\n┌ Info: Output directory: rapid\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:56\n\n\n\n\n\nProcess(`\u001b[4mgunzip\u001b[24m \u001b[4m-c\u001b[24m \u001b[4m./rapid/results.max.gz\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"countlines(\"./rapid/results.max\") # d = 3, w = 3, r = 10, s = 9","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"6474","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"We identified >6000 IBD segments! The first few lines of the output IBD file looks like","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":";head ./rapid/results.max","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"1\t54\t2079\t1\t0\t100\t3406500\t3.40637\t0\t34064\n1\t344\t2053\t1\t1\t100\t3376200\t3.37607\t0\t33761\n1\t373\t2033\t1\t0\t100\t3303900\t3.30377\t0\t33038\n1\t389\t2081\t0\t1\t100\t4936200\t4.9361\t0\t49361\n1\t400\t2087\t1\t1\t100\t4923900\t4.9238\t0\t49238\n1\t605\t2039\t0\t0\t100\t3357600\t3.35747\t0\t33575\n1\t606\t2069\t1\t0\t850900\t5000000\t4.14918\t8508\t49999\n1\t608\t2057\t1\t0\t100\t3146400\t3.14626\t0\t31463\n1\t616\t2081\t0\t0\t100\t4072800\t4.07268\t0\t40727\n1\t636\t2029\t0\t1\t967000\t5000000\t4.03308\t9669\t49999","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"where the column format is: ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"<chr_name> <sample_id1> <sample_id2> <hap_id1> <hap_id2> <starting_pos_genomic> <ending_pos_genomic> <genetic_length> <starting_site> <ending_site>","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Then we need to do some postprocessing to this output, as described here. ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"process_rapid_output(\"./rapid/results.max\", \"sim.snpknock.ibdmap\")","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":";head sim.snpknock.ibdmap","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"CHR ID1 HID1 ID2 HID2 BP.start BP.end site.start site.end cM FAM1 FAM2\n1 54 1 2079 0 100 3406500 0 34064 3.40637 1 1\n1 344 1 2053 1 100 3376200 0 33761 3.37607 1 1\n1 373 1 2033 0 100 3303900 0 33038 3.30377 1 1\n1 389 0 2081 1 100 4936200 0 49361 4.9361 1 1\n1 400 1 2087 1 100 4923900 0 49238 4.9238 1 1\n1 605 0 2039 0 100 3357600 0 33575 3.35747 1 1\n1 606 1 2069 0 850900 5000000 8508 49999 4.14918 1 1\n1 608 1 2057 0 100 3146400 0 31463 3.14626 1 1\n1 616 0 2081 0 100 4072800 0 40727 4.07268 1 1","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Next convert VCF file to BGEN format (note: sample file must be saved separately)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# convert VCF to BGEN format\noutfile = \"sim.bgen\"\nrun(`$qctools_exe -g $vcffile -og $outfile`)\n\n# then save sample file separately\nmake_bgen_samplefile(\"sim.sample\", n + offsprings)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Welcome to qctool\n(version: 2.0.7, revision )\n\n(C) 2009-2017 University of Oxford\n\nOpening genotype files                                      : [******************************] (1/1,0.0s,76.8/s)\n========================================================================\n\nInput SAMPLE file(s):         Output SAMPLE file:             \"(n/a)\".\nSample exclusion output file:   \"(n/a)\".\n\nInput GEN file(s):\n                                                    (not computed)  \"sim.phased.vcf.gz\"\n                                         (total 1 sources, number of snps not computed).\n                      Number of samples: 2100\nOutput GEN file(s):             \"sim.bgen\"\nOutput SNP position file(s):    (n/a)\nSample filter:                  .\n# of samples in input files:    2100.\n# of samples after filtering:   2100 (0 filtered out).\n\n========================================================================\n\nProcessing SNPs                                             :  (50000/?,161.7s,309.2/s)\nTotal: 50000SNPs.\n========================================================================\n\nNumber of SNPs:\n                     -- in input file(s):                 (not computed).\n -- in output file(s):                50000\n\nNumber of samples in input file(s):   2100.\n\nOutput GEN files:                     (50000  snps)  \"sim.bgen\"\n                                      (total 50000 snps).\n========================================================================\n\n\nThank you for using qctool.","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Finally, generate HMM knockoffs by running the following code in the command line directly. You may need to adjust file directories and change parameters. ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"bgenfile = \"sim\"\nsample_qc = \"samples_qc.txt\"\nvariant_qc = \"variants_qc.txt\"\nmapfile = \"sim.partition.map\"\npartfile = \"sim.partition.txt\"\nibdfile = \"sim.snpknock.ibdmap\"\nK = 10\ncluster_size_min = 1000 \ncluster_size_max = 10000 \nhmm_rho = 1\nhmm_lambda = 1e-3 \nwindows = 0\nn_threads = 1\nseed = 2021\ncompute_references = true\ngenerate_knockoffs = true\noutfile = \"sim.knockoffs\"\n\n@time snpknock2(snpknock2_exe, bgenfile, sample_qc, variant_qc, mapfile, partfile, ibdfile, \n    K, cluster_size_min, cluster_size_max, hmm_rho, hmm_lambda, windows, n_threads, \n    seed, compute_references, generate_knockoffs, outfile)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"\t+----------------------+\n\t|                      |\n\t|  SNPKNOCK2, v0.3     |\n\t|  July 21, 2020       |\n\t|  Matteo Sesia        |\n\t|                      |\n\t+----------------------+\n\nCopyright (C) 2020 Stanford University.\nDistributed under the GNU GPLv3 open source license.\n\nUse --help for more information.\n\nCommand line arguments:\n  --bgen sim\n  --keep samples_qc.txt\n  --extract variants_qc.txt\n  --map sim.partition.map\n  --part sim.partition.txt\n  --ibd sim.snpknock.map\n  --K 10\n  --cluster_size_min 1000\n  --cluster_size_max 10000\n  --hmm-rho 1\n  --hmm-lambda 0.001\n  --windows 0\n  --n_threads 1\n  --seed 2021\n  --compute-references\n  --generate-knockoffs\n  --out ./knockoffs/sim.knockoffs\n\nRequested operations:\n  --compute-references\n  --generate_knockoffs\n\n\n--------------------------------------------------------------------------------\nLoading metadata\n--------------------------------------------------------------------------------\nLoading sample information from:\n  sim.sample\nLoading legend from:\n  sim.bim\n\n\n┌ Info: snpknock2 command:\n│ `/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2 --bgen sim --keep samples_qc.txt --extract variants_qc.txt --map sim.partition.map --part sim.partition.txt --ibd sim.snpknock.map --K 10 --cluster_size_min 1000 --cluster_size_max 10000 --hmm-rho 1 --hmm-lambda 0.001 --windows 0 --n_threads 1 --seed 2021 --compute-references --generate-knockoffs --out ./knockoffs/sim.knockoffs`\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:100\n┌ Info: Output directory: /home/users/bbchu/hmm/knockoffs\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:101\n\n\nLoading partitions from:\n  sim.partition.txt\nLoading IBD segments from:\n  sim.snpknock.map\nLoaded 21 IBD segments.\n\nPrinting summary of 1 windows:\n     0: 0--50000\nSummary of metadata for chromosome 1:\n  number of samples (after | before filtering) : 2100 | 2100\n  number of SNPs (after | before filtering)    : 50000 | 50000\n  number of variant partitions                 : 7\n  size of genomic windows                      : whole-chromosome\n  number of IBD segments                       : 21\n\n\n--------------------------------------------------------------------------------\nKinship (using only haplotype data)\n--------------------------------------------------------------------------------\nReached 1\nChromosome 1 will be loaded from:\n  haplotype file            : sim.bgen\n  sample file               : sim.sample\n  legend file               : sim.bim\n  thinning factor           : 10\n  sample filter file        : samples_qc.txt\n  variant filter file       : variants_qc.txt\n  number of SNPs            : 5000\n  number of haplotypes      : 4200\n\nReading BGEN file using 1 thread:\n|....................................................................................................|\n|====================================================================================================|\nSolving 1 bifurcating K-means problems using 1 threads.\n\nKinship clusters written to:\n  ./knockoffs/sim.knockoffs_clust.txt\n  ./knockoffs/sim.knockoffs.sample\n\nAssigning references for the whole chromosome using 1 threads: \n|....................................................................................................|\n|\n\n\nBifurcating K-means\nSmallest allowed cluster size: 1000\n step\t cluster\t    size\t    left\t   right\taccepted\nBifurcating K-means completed after 0 steps.\nNumber of clusters: 1.\n\n\n\n====================================================================================================|\n\nReached 2\nIndividual global references written to:\n  ./knockoffs/sim.knockoffs_lref.txt\n\nIndividual local references written to:\n  ./knockoffs/sim.knockoffs_ref.txt\n\n\n--------------------------------------------------------------------------------\nKnockoffs for chromosome 1\n--------------------------------------------------------------------------------\nChromosome 1 will be loaded from:\n  haplotype file            : sim\n  haplotype file format     : bgen\n  sample file               : sim.sample\n  legend file               : sim.bim\n  map file                  : sim.partition.map\n  sample filter file        : samples_qc.txt\n  variant filter file       : variants_qc.txt\n  number of SNPs            : 50000\n  number of windows         : 1\n  number of haplotypes      : 4200\n\nLoading data for chromosome 1\nReading BGEN file using 1 thread:\n|....................................................................................................|\n|====================================================================================================|\n\nInitializing HMM with user-supplied hyperparameters: rho = 1, lambda = 0.001.\n\nHMM parameters written to:\n  ./knockoffs/sim.knockoffs_hmm.txt\n\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res0_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res0_windows.txt\n\nGenerating related knockoffs for chromosome 1 (42 haplotypes in 21 families, 50000 variants in 50000 groups):\n|.....................|\n|=====================|\n\nGenerating unrelated knockoffs for chromosome 1 (4158 haplotypes; 50000 variants in 50000 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res0.bed\n  ./knockoffs/sim.knockoffs_res0.bim\n  ./knockoffs/sim.knockoffs_res0.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res0_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res1_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res1_windows.txt\n\nGenerating related knockoffs for chromosome 1 (42 haplotypes in 21 families, 50000 variants in 738 groups):\n|.....................|\n|=====================|\n\nGenerating unrelated knockoffs for chromosome 1 (4158 haplotypes; 50000 variants in 738 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res1.bed\n  ./knockoffs/sim.knockoffs_res1.bim\n  ./knockoffs/sim.knockoffs_res1.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res1_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res2_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res2_windows.txt\n\nGenerating related knockoffs for chromosome 1 (42 haplotypes in 21 families, 50000 variants in 143 groups):\n|.....................|\n|=====================|\n\nGenerating unrelated knockoffs for chromosome 1 (4158 haplotypes; 50000 variants in 143 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res2.bed\n  ./knockoffs/sim.knockoffs_res2.bim\n  ./knockoffs/sim.knockoffs_res2.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res2_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res3_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res3_windows.txt\n\nGenerating related knockoffs for chromosome 1 (42 haplotypes in 21 families, 50000 variants in 72 groups):\n|.....................|\n|=====================|\n\nGenerating unrelated knockoffs for chromosome 1 (4158 haplotypes; 50000 variants in 72 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res3.bed\n  ./knockoffs/sim.knockoffs_res3.bim\n  ./knockoffs/sim.knockoffs_res3.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res3_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res4_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res4_windows.txt\n\nGenerating related knockoffs for chromosome 1 (42 haplotypes in 21 families, 50000 variants in 37 groups):\n|.....................|\n|=====================|\n\nGenerating unrelated knockoffs for chromosome 1 (4158 haplotypes; 50000 variants in 37 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res4.bed\n  ./knockoffs/sim.knockoffs_res4.bim\n  ./knockoffs/sim.knockoffs_res4.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res4_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res5_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res5_windows.txt\n\nGenerating related knockoffs for chromosome 1 (42 haplotypes in 21 families, 50000 variants in 15 groups):\n|.....................|\n|=====================|\n\nGenerating unrelated knockoffs for chromosome 1 (4158 haplotypes; 50000 variants in 15 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res5.bed\n  ./knockoffs/sim.knockoffs_res5.bim\n  ./knockoffs/sim.knockoffs_res5.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res5_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res6_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res6_windows.txt\n\nGenerating related knockoffs for chromosome 1 (42 haplotypes in 21 families, 50000 variants in 5 groups):\n|.....................|\n|=====================|\n\nGenerating unrelated knockoffs for chromosome 1 (4158 haplotypes; 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res6.bed\n  ./knockoffs/sim.knockoffs_res6.bim\n  ./knockoffs/sim.knockoffs_res6.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res6_anc.txt\n\nFinished.\n\n842.037610 seconds (921.59 k allocations: 53.340 MiB, 0.00% gc time, 0.06% compilation time)\n\n\n\n\n\nProcess(`\u001b[4m/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2\u001b[24m \u001b[4m--bgen\u001b[24m \u001b[4msim\u001b[24m \u001b[4m--keep\u001b[24m \u001b[4msamples_qc.txt\u001b[24m \u001b[4m--extract\u001b[24m \u001b[4mvariants_qc.txt\u001b[24m \u001b[4m--map\u001b[24m \u001b[4msim.partition.map\u001b[24m \u001b[4m--part\u001b[24m \u001b[4msim.partition.txt\u001b[24m \u001b[4m--ibd\u001b[24m \u001b[4msim.snpknock.map\u001b[24m \u001b[4m--K\u001b[24m \u001b[4m10\u001b[24m \u001b[4m--cluster_size_min\u001b[24m \u001b[4m1000\u001b[24m \u001b[4m--cluster_size_max\u001b[24m \u001b[4m10000\u001b[24m \u001b[4m--hmm-rho\u001b[24m \u001b[4m1\u001b[24m \u001b[4m--hmm-lambda\u001b[24m \u001b[4m0.001\u001b[24m \u001b[4m--windows\u001b[24m \u001b[4m0\u001b[24m \u001b[4m--n_threads\u001b[24m \u001b[4m1\u001b[24m \u001b[4m--seed\u001b[24m \u001b[4m2021\u001b[24m \u001b[4m--compute-references\u001b[24m \u001b[4m--generate-knockoffs\u001b[24m \u001b[4m--out\u001b[24m \u001b[4m./knockoffs/sim.knockoffs\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/hmm/#Step-3:-Examine-Generated-Knockoffs","page":"HMM Knockoffs","title":"Step 3: Examine Generated Knockoffs","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"The generated knockoffs are saved in binary PLINK format, we can import it using SnpArrays","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"x = SnpArray(\"knockoffs/sim.knockoffs_res0.bed\")","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"2100×100000 SnpArray:\n 0x02  0x03  0x02  0x02  0x03  0x03  …  0x02  0x02  0x02  0x03  0x03  0x03\n 0x02  0x02  0x03  0x03  0x00  0x02     0x02  0x02  0x03  0x03  0x02  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x00  0x03  0x02  0x02  0x02  0x02     0x02  0x02  0x03  0x03  0x03  0x03\n 0x03  0x03  0x00  0x00  0x03  0x02     0x02  0x02  0x03  0x03  0x03  0x03\n 0x00  0x02  0x02  0x02  0x02  0x02  …  0x03  0x03  0x03  0x02  0x03  0x03\n 0x02  0x00  0x00  0x02  0x02  0x02     0x03  0x00  0x02  0x02  0x03  0x03\n 0x02  0x02  0x02  0x02  0x00  0x02     0x02  0x02  0x02  0x02  0x03  0x03\n 0x02  0x03  0x02  0x02  0x03  0x03     0x02  0x02  0x02  0x00  0x03  0x03\n 0x03  0x02  0x02  0x02  0x02  0x00     0x02  0x02  0x02  0x02  0x03  0x03\n 0x02  0x00  0x02  0x03  0x02  0x03  …  0x02  0x02  0x02  0x00  0x03  0x03\n 0x00  0x03  0x03  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x00  0x02  0x03  0x03  0x03  0x03     0x00  0x02  0x02  0x02  0x03  0x03\n    ⋮                             ⋮  ⋱           ⋮                    \n 0x00  0x00  0x00  0x00  0x03  0x03     0x02  0x02  0x02  0x02  0x02  0x02\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00\n 0x03  0x02  0x03  0x03  0x02  0x00  …  0x02  0x02  0x02  0x02  0x02  0x02\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00\n 0x00  0x00  0x02  0x02  0x00  0x00     0x03  0x03  0x03  0x03  0x03  0x03\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00\n 0x02  0x00  0x00  0x00  0x03  0x03     0x02  0x02  0x02  0x02  0x02  0x02\n 0x00  0x00  0x00  0x00  0x00  0x00  …  0x00  0x00  0x00  0x00  0x00  0x00\n 0x00  0x00  0x00  0x00  0x00  0x00     0x02  0x02  0x02  0x02  0x02  0x02\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00\n 0x00  0x02  0x02  0x02  0x02  0x02     0x00  0x00  0x02  0x02  0x02  0x02\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Notice there are 100k SNPs: the original 50k SNPs and their knockoffs. Reading the SNP names will tell us which are the originals:","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"snpid = SnpData(\"knockoffs/sim.knockoffs_res0\").snp_info.snpid","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"100000-element Vector{String}:\n \"snp1.k\"\n \"snp1\"\n \"snp2\"\n \"snp2.k\"\n \"snp3.k\"\n \"snp3\"\n \"snp4.k\"\n \"snp4\"\n \"snp5.k\"\n \"snp5\"\n \"snp6\"\n \"snp6.k\"\n \"snp7\"\n ⋮\n \"snp49995\"\n \"snp49995.k\"\n \"snp49996.k\"\n \"snp49996\"\n \"snp49997.k\"\n \"snp49997\"\n \"snp49998.k\"\n \"snp49998\"\n \"snp49999\"\n \"snp49999.k\"\n \"snp50000.k\"\n \"snp50000\"","category":"page"},{"location":"man/hmm/#Step-4:-Model-selection-with-knockoffs","page":"HMM Knockoffs","title":"Step 4: Model selection with knockoffs","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Tutorial for this part coming soon! Basically, one constructs a SnpLinAlg, feed that into MendelIHT.jl, and calculate knockoff statistics afterwards using built-in functions like coefficient_diff and threshold.","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"SnpLinAlg performs compressed linear algebra (often faster than double precision BLAS) and MendelIHT.jl is a very efficient implementation of the iterative hard thresholding algorithm. For model selection, IHT is known to be superior to standard LASSO, elastic net, and MCP solvers. ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"xla = SnpLinAlg{Float64}(x, center=true, scale=true, impute=true)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"2100×100000 SnpLinAlg{Float64}:\n  0.345218   1.73033   -0.261617  …   1.25296    0.257722   0.278685\n  0.345218   0.287244   1.17659       1.25296   -3.75129    0.278685\n  0.345218   0.287244  -0.261617     -0.171629   0.257722   0.278685\n -1.11052    1.73033   -0.261617      1.25296    0.257722   0.278685\n  1.80096    1.73033   -1.69983       1.25296    0.257722   0.278685\n -1.11052    0.287244  -0.261617  …  -0.171629   0.257722   0.278685\n  0.345218  -1.15585   -1.69983      -0.171629   0.257722   0.278685\n  0.345218   0.287244  -0.261617     -0.171629   0.257722   0.278685\n  0.345218   1.73033   -0.261617     -1.59622    0.257722   0.278685\n  1.80096    0.287244  -0.261617     -0.171629   0.257722   0.278685\n  0.345218  -1.15585   -0.261617  …  -1.59622    0.257722   0.278685\n -1.11052    1.73033    1.17659      -0.171629   0.257722   0.278685\n -1.11052    0.287244   1.17659      -0.171629   0.257722   0.278685\n  ⋮                               ⋱                        \n -1.11052   -1.15585   -1.69983      -0.171629  -3.75129   -3.44894\n -1.11052   -1.15585   -1.69983      -1.59622   -7.7603    -7.17657\n  1.80096    0.287244   1.17659   …  -0.171629  -3.75129   -3.44894\n -1.11052   -1.15585   -1.69983      -1.59622   -7.7603    -7.17657\n -1.11052   -1.15585   -0.261617      1.25296    0.257722   0.278685\n -1.11052   -1.15585   -1.69983      -1.59622   -7.7603    -7.17657\n  0.345218  -1.15585   -1.69983      -0.171629  -3.75129   -3.44894\n -1.11052   -1.15585   -1.69983   …  -1.59622   -7.7603    -7.17657\n -1.11052   -1.15585   -1.69983      -0.171629  -3.75129   -3.44894\n -1.11052   -1.15585   -1.69983      -1.59622   -7.7603    -7.17657\n -1.11052    0.287244  -0.261617     -0.171629  -3.75129   -3.44894\n -1.11052   -1.15585   -1.69983      -1.59622   -7.7603    -7.17657","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"","category":"page"},{"location":"#Knockoffs.jl","page":"Home","title":"Knockoffs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a Julia implementation of the knockoff filter. The knockoff filter is a general framework for controlling the false discovery rate when performing variable selection. As the name suggests, the knockoff filter operates by manufacturing knockoff variables that are cheap — their construction does not require collecting any new data — and are designed to mimic the correlation structure found within the original variables. The knockoffs serve as negative controls and they allow one to identify the truly important predictors, while controlling the false discovery rate (FDR) — the expected fraction of false discoveries among all discoveries.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Within Julia,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"add https://github.com/biona001/Knockoffs.jl\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package supports Julia v1.6+.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/hmm.md\",\n    \"man/api.md\"\n]\nDepth = 2","category":"page"},{"location":"man/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"Here is a list of available function calls. A detailed description can be found below. ","category":"page"},{"location":"man/api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"man/api/#Regular-functions","page":"API","title":"Regular functions","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"  fixed_knockoffs\n  modelX_gaussian_knockoffs\n  normalize_col!\n  coefficient_diff\n  threshold\n  extract_beta\n  extract_combine_beta","category":"page"},{"location":"man/api/#Knockoffs.fixed_knockoffs","page":"API","title":"Knockoffs.fixed_knockoffs","text":"fixed_knockoffs(X::Matrix{T}; method=:sdp)\n\nCreates fixed knockoffs based on equation (2.2)-(2.4) of  \"Controlling the false discovery rate via Knockoffs\" by Barber and Candes (2015)\n\nInputs\n\nX: A n × p numeric matrix, each row is a sample, and each column is normalized\n\nto mean 0 variance 1 with unit norm. \n\nmethod: :equi for equi-distant knockoffs (eq 2.3) or :sdp for SDP\n\nknockoffs (eq 2.4)\n\nOutput\n\nKnockoff: A struct containing the original X and its knockoff X̃, \n\nin addition to other variables (e.g. s)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.modelX_gaussian_knockoffs","page":"API","title":"Knockoffs.modelX_gaussian_knockoffs","text":"modelX_gaussian_knockoffs(X::Matrix{T})\n\nCreates model-free multivariate normal knockoffs by sequentially sampling from  conditional multivariate normal distributions.\n\nInputs\n\nX: A n × p numeric matrix. Each row is a sample, and each column is standardized\n\nto mean 0 variance 1. \n\nReference:\n\n\"Panning for Gold: Model-X Knockoffs for High-dimensional Controlled Variable Selection\" by Candes, Fan, Janson, and Lv (2018)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.coefficient_diff","page":"API","title":"Knockoffs.coefficient_diff","text":"coefficient_diff(β::AbstractVector, method=:concat)\n\nReturns the coefficient difference statistic W[j] = |β[j]| - |β[j + p]|  from a univariate (single response) regression. \n\nInputs\n\nβ: Vector of regression coefficients\nmethod: Either :concatenated (default) if all knockoffs are concatenated   at the end (e.g. [XX̃]) or :interleaved if each variable is immediately   followed by its knockoff (e.g. [x₁x̃₁x₂x̃₂...])\n\n\n\n\n\ncoefficient_diff(β::AbstractVector, original::AbstractVector{Int}, knockoff::AbstractVector{Int})\n\nReturns the coefficient difference statistic W[j] = |β[j]| - |β[j + p]|  from a univariate (single response) regression, where the jth variable is stored in position original[j] of β, and its knockoff is stored in position knockoff[j]\n\nInputs\n\nβ: Vector of regression coefficients\noriginal: The index of original variables in β\nknockoff: The index of knockoff variables in β\n\n\n\n\n\ncoefficient_diff(β::AbstractVector, original::AbstractVector{Int}, knockoff::AbstractVector{Int})\n\nReturns the coefficient difference statistic for grouped variables W[G] = sum{j in G} |β[j]| - sum{j in G} |β[j + p]|.\n\nInputs\n\nβ: Vector of regression coefficients\ngroups: Vector storing group membership. groups[i] is the group of β[i]\noriginal: The index of original variables in β\nknockoff: The index of knockoff variables in β\n\n\n\n\n\ncoefficient_diff(B::AbstractMatrix)\n\nReturns the coefficient difference statistic W[j] = |B[j, 1]| - |B[j + p, 1]| + ... +  |B[j, r]| - |B[j + p, r]| from a multivariate (multiple response) regression. \n\nInputs\n\nβ: Matrix of regression coefficients. Each column is a vector of β. \nmethod: Either :concatenated if all knockoffs are concatenated at the end   (e.g. [XX̃]) or :interleaved if each variable is immediately followed by   its knockoff (e.g. [x₁x̃₁x₂x̃₂...])\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.threshold","page":"API","title":"Knockoffs.threshold","text":"threshold(w::AbstractVector, q::Number, method=:knockoff)\n\nChooses a threshold τ > 0 by setting τ = min{ t > 0 : {#j: w[j] ≤ -t} / {#j: w[j] ≥ t} ≤ q }.\n\nInputs\n\nw: Vector of feature important statistics\nq: target FDR (between 0 and 1)\nmethod: either :knockoff or :knockoff_plus\n\nReference:\n\nEquation 3.10 (method=:knockoff) or 3.11 (method=:knockoff_plus) of  \"Panning for Gold: Model-X Knockoffs for High-dimensional Controlled Variable Selection\" by Candes, Fan, Janson, and Lv (2018)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.extract_beta","page":"API","title":"Knockoffs.extract_beta","text":"extract_beta(β̂_knockoff::AbstractVector, fdr::Number, method::Symbol=:concatenated)\n\nGiven estimated β of original variables and their knockoffs, compute β for the original design matrix that controls the FDR.\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Wrapper-functions-for-HMM-knockoffs","page":"API","title":"Wrapper functions for HMM knockoffs","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"  partition\n  rapid\n  snpknock2","category":"page"},{"location":"man/api/#Knockoffs.rapid","page":"API","title":"Knockoffs.rapid","text":"rapid(rapid_exe, vcffile, mapfile, d, outfolder, w, r, s, [a])\n\nWrapper for the RaPID program. \n\nInputs\n\nrapid_exe: Full path to the RaPID_v.1.7 executable file\nvcffile: Phased VCF file name\nmapfile: Map file name\nd: Actual Minimum IBD length in cM\noutfolder: Output folder name\nw: Number of SNPs in a window for sub-sampling\nr: Number of runs\ns: Minimum number of successes to consider a hit\n\nOptional Inputs\n\na: If true, ignore MAFs. By default (a=false) the sites are selected at random weighted   by their MAFs.\n\n\n\n\n\n","category":"function"}]
}
