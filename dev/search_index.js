var documenterSearchIndex = {"docs":
[{"location":"man/hmm/#Generate-HMM-knockoffs","page":"HMM Knockoffs","title":"Generate HMM knockoffs","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"This tutorial closely follows the knockoffgwas tutorial. We go over how to generate (SHAPEIT) HMM knockoffs given (simulated) binary PLINK formatted data. ","category":"page"},{"location":"man/hmm/#Installation","page":"HMM Knockoffs","title":"Installation","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Install knockoffgwas and its dependencies\nInstall qctools for converting between VCF and BGEN formats\nInstall RaPID for detecting IBD segments (this only run on linux)\nInstall the following Julia packages. Within julia, type","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"]add SnpArrays Distributions ProgressMeter MendelIHT VCFTools StatsBase\n]add https://github.com/biona001/Knockoffs.jl","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Modify these executable path to the ones installed on your local computer. Here the partition_script is located under the path you installed knockoffgwas: knockoffgwas/knockoffgwas/utils/partition.R.","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"qctools_exe = \"/scratch/users/bbchu/qctool/build/release/qctool_v2.0.7\"\nsnpknock2_exe = \"/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2\"\nrapid_exe = \"/scratch/users/bbchu/RaPID/RaPID_v.1.7\"\npartition_script = \"/scratch/users/bbchu/knockoffgwas/knockoffgwas/utils/partition.R\";","category":"page"},{"location":"man/hmm/#Required-inputs","page":"HMM Knockoffs","title":"Required inputs","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"We need multiple input files to generate knockoffs","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Unphased genotypes in binary PLINK format\nPhased genotypes in VCF and BGEN format: we will simulate haplotypes, store in VCF format, and convert to BGEN using qctools\nNote: knockoffgwas requires only BGEN format, but RaPID requires VCF formats. Hence, the extra conversion\nMap file (providing different group resolution): since data is simulated, we will generate fake map file where every snp is 1cM apart\nIBD segment file (generated by RaPID which requires VCF inputs)\nVariant partition files (generated by snpknock2, i.e. module 2 of knockoffgwas) \nSample and variant QC files","category":"page"},{"location":"man/hmm/#Simulate-genotypes","page":"HMM Knockoffs","title":"Simulate genotypes","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Our simulation will try to follow","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Adding population structure (admixture & cryptic relatedness): New approaches to population stratification in genome-wide association studies\nHow to simulate siblings: [Using Extended Genealogy to Estimate Components of Heritability for 23 Quantitative and Dichotomous Traits","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"](https://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1003520)","category":"page"},{"location":"man/hmm/#Population-structure","page":"HMM Knockoffs","title":"Population structure","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Specifically, lets simulate genotypes with 2 populations. We simulate 49950 normally differentiated markers and 50 unusually differentiated markers based on allele frequency difference equal to 0.6. Let x_ij be the number of alternate allele count for sample i at SNP j with allele frequency p_j. Also let h_ij 1 denotype haplotype 1 of sample i at SNP j and h_ij 2 the second haplotype. Our simulation model is","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"h_ij 1 sim Bernoulli(p_j) quad h_ij 2 sim Bernoulli(p_j) quad x_ij = h_ij 1 + h_ij 2","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"which is equivalent to  ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"x_ij sim Binomial(2 p_j)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"for unphased data. The allele frequency is p_j = Uniform(0 1) for normally differentiated markers, and ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"p_pop1 j sim Uniform(0 04) quad p_pop2 j = p_pop1 j + 06","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"for abnormally differentiated markers. Each sample is randomly assigned to population 1 or 2. ","category":"page"},{"location":"man/hmm/#Sibling-pairs","page":"HMM Knockoffs","title":"Sibling pairs","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Based on the simulated data above, we can randomly sample pairs of individuals and have them produce offspring. Here, half of all offsprings will be siblings with the other half. This is done by first randomly sampling 2 samples from to represent parent. Assume they have 2 children. Then generate offspring individuals by copying segments of one parent haplotype directly to the corresponding haplotype of the offspring. This recombination event will produce IBD segments. The number of recombination is 1 or 2 per chromosome, and is chosen uniformly across the chromosome. ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# load Julia packages and some helper functions\nusing SnpArrays\nusing Knockoffs\nusing DelimitedFiles\nusing Random\nusing LinearAlgebra\nusing Distributions\nusing ProgressMeter\nusing MendelIHT\nusing VCFTools\nusing StatsBase","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"These are helper functions needed for this tutorial (essentially data simulation + some glue code). It is not crucial users understand what they are doing.  ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"\"\"\"\n    simulate_pop_structure(n, p)\n\nSimulate genotypes with K = 2 populations. 300 SNPs will have different allele \nfrequencies between the populations, where 50 of them will be causal\n\n# Inputs\n- `plinkfile`: Output plink file name. \n- `n`: Number of samples\n- `p`: Number of SNPs\n\n# Output\n- `x1`: n×p matrix of the 1st haplotype for each sample. Each row is a haplotype\n- `x2`: n×p matrix of the 2nd haplotype for each sample. `x = x1 + x2`\n- `populations`: Vector of length `n` indicating population membership for eachsample. \n- `diff_markers`: Indices of the differentially expressed alleles.\n\n# Reference\nhttps://www.nature.com/articles/nrg2813\n\"\"\"\nfunction simulate_pop_structure(n::Int, p::Int)\n    # first simulate genotypes treating all samples equally\n    x1 = BitMatrix(undef, n, p)\n    x2 = BitMatrix(undef, n, p)\n    pmeter = Progress(p, 0.1, \"Simulating genotypes...\")\n    @inbounds for j in 1:p\n        d = Bernoulli(rand())\n        for i in 1:n\n            x1[i, j] = rand(d)\n            x2[i, j] = rand(d)\n        end\n        next!(pmeter)\n    end\n    # assign populations and simulate 300 unually differentiated markers\n    populations = rand(1:2, n)\n    diff_markers = sample(1:p, 300, replace=false)\n    @inbounds for j in diff_markers\n        pop1_allele_freq = 0.4rand()\n        pop2_allele_freq = pop1_allele_freq + 0.6\n        pop1_dist = Bernoulli(pop1_allele_freq)\n        pop2_dist = Bernoulli(pop2_allele_freq)\n        for i in 1:n\n            d = isone(populations[i]) ? pop1_dist : pop2_dist\n            x1[i, j] = rand(d)\n            x2[i, j] = rand(d)\n        end\n    end\n    return x1, x2, populations, diff_markers\nend\n\n\"\"\"\n    simulate_IBD(parent_plinkfile, offsprings)\n\nSimulate recombination events. Half of all offsprings will be siblings with the other half.\nThis is done by first randomly sampling 2 samples from to represent parent. Assume they have\n2 children. Then generate offspring individuals by copying segments of the parents haplotype\ndirectly to the offspring to represent IBD segments. The number of segments (i.e. places of\nrecombination) is 1 or 2 per chromosome, and is chosen uniformly across the chromosome. \n\n# Inputs\n- `h1`: `n × p` matrix of the 1st haplotype for each parent. Each row is a haplotype\n- `h2`: `n × p` matrix of the 2nd haplotype for each parent. `H = h1 + h2`\n- `offsprings`: Total number of offsprings\n\n# Output\n- `x1`: `offsprings × p` matrix of the 1st haplotype for each offspring. Each row is a haplotype\n- `x2`: `offsprings × p` matrix of the 2nd haplotype for each offspring. `x = x1 + x2`\n\n# References\nhttps://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1003520\n\"\"\"\nfunction simulate_IBD(h1::AbstractMatrix, h2::AbstractMatrix, offsprings::Int)\n    # first handle errors\n    n, p = size(h1)\n    iseven(offsprings) || error(\"number of offsprings should be even\")\n    # randomly designate gender for parents\n    sex = bitrand(n)\n    male_idx = findall(x -> x == true, sex)\n    female_idx = findall(x -> x == false, sex)\n    # simulate new samples\n    x1 = falses(n, p)\n    x2 = falses(n, p)\n    fathers = Int[]\n    mothers = Int[]\n    pmeter = Progress(offsprings >> 1, 0.1, \"Simulating IBD segments...\")\n    for i in 1:(offsprings >> 1)\n        # assign parents\n        dad = rand(male_idx)\n        mom = rand(female_idx)\n        push!(fathers, dad)\n        push!(mothers, mom)\n        # child 1\n        recombinations = rand(1:2)\n        breakpoints = sort!(sample(1:p, recombinations, replace=false))\n        parent1, parent2 = rand() < 0.5 ? (dad, mom) : (mom, dad)\n        segments = recombination_segments(breakpoints, p)\n        for j in 1:length(segments)\n            parent = isodd(j) ? parent1 : parent2\n            segment = segments[j]\n            # perform recombination\n            parent_hap = rand() < 0.5 ? h1 : h2\n            child_hap = rand() < 0.5 ? x1 : x2\n            copyto!(@view(child_hap[2i - 1, segment]), @view(parent_hap[parent, segment]))\n        end\n        # child 2\n        recombinations = rand(1:2)\n        breakpoints = sort!(sample(1:p, recombinations, replace=false))\n        parent1, parent2 = rand() < 0.5 ? (dad, mom) : (mom, dad)\n        segments = recombination_segments(breakpoints, p)\n        for j in 1:length(segments)\n            parent = isodd(j) ? parent1 : parent2\n            segment = segments[j]\n            # perform recombination\n            parent_hap = rand() < 0.5 ? h1 : h2\n            child_hap = rand() < 0.5 ? x1 : x2\n            copyto!(@view(child_hap[2i - 1, segment]), @view(parent_hap[parent, segment]))\n        end\n        # update progress\n        next!(pmeter)\n    end\n    return x1, x2, fathers, mothers\nend\n\nfunction recombination_segments(breakpoints::Vector{Int}, snps::Int)\n    start = 1\n    result = UnitRange{Int}[]\n    for bkpt in breakpoints\n        push!(result, start:bkpt)\n        start = bkpt + 1\n    end\n    push!(result, breakpoints[end]+1:snps)\n    return result\nend\n\nfunction write_plink(outfile::AbstractString, x1::AbstractMatrix, x2::AbstractMatrix)\n    n, p = size(x1)\n    x = SnpArray(outfile * \".bed\", n, p)\n    for j in 1:p, i in 1:n\n        c = x1[i, j] + x2[i, j]\n        if c == 0\n            x[i, j] = 0x00\n        elseif c == 1\n            x[i, j] = 0x02\n        elseif c == 2\n            x[i, j] = 0x03\n        else\n            error(\"matrix entries should be 0, 1, or 2 but was $c!\")\n        end\n    end\n    # create .bim file structure: https://www.cog-genomics.org/plink2/formats#bim\n    open(outfile * \".bim\", \"w\") do f\n        for i in 1:p\n            println(f, \"1\\tsnp$i\\t0\\t$(100i)\\t1\\t2\")\n        end\n    end\n    # create .fam file structure: https://www.cog-genomics.org/plink2/formats#fam\n    open(outfile * \".fam\", \"w\") do f\n        for i in 1:n\n            println(f, \"$i\\t1\\t0\\t0\\t1\\t-9\")\n        end\n    end\n    return nothing\nend\n\nfunction make_fake_mapfile(filename, p::Int)\n    open(filename, \"w\") do io\n        println(io, \"Chromosome\\tPosition(bp)\\tRate(cM/Mb)\\tMap(cM)\")\n        for i in 1:p\n            println(io, \"chr1\\t\", 100i, \"\\t1.0\\t1.0\")\n        end\n    end\nend","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"make_fake_mapfile (generic function with 1 method)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Simulate phased data with 2 populations, 49700 usually differentiated markers, and 300 unusually differentiated markers. Then simulate mating, which generates IBD segments. Finally, make unphased data from offspring haplotypes. ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# simulate phased genotypes\nRandom.seed!(2021)\noutfile = \"sim\"\nn = 2000\np = 50000\nh1, h2, populations, diff_markers = simulate_pop_structure(n, p)\n\n# simulate random mating to get IBD segments\noffsprings = 2000\nx1, x2, fathers, mothers = simulate_IBD(h1, h2, offsprings)\n\n# write phased genotypes to VCF format\nwrite_vcf(\"sim.phased.vcf.gz\", x1, x2)\n\n# write unphased genotypes to PLINK binary format\nwrite_plink(outfile, x1, x2)\n\n# save pop1/pop2 index and unually differentiated marker indices\nwritedlm(\"populations.txt\", populations)\nwritedlm(\"diff_markers.txt\", diff_markers)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"\u001b[32mSimulating genotypes...100%|████████████████████████████| Time: 0:00:02\u001b[39m\n\u001b[32mSimulating IBD segments...100%|█████████████████████████| Time: 0:00:03\u001b[39m\n\u001b[32mWriting VCF...100%|█████████████████████████████████████| Time: 0:00:21\u001b[39m","category":"page"},{"location":"man/hmm/#Step-1:-Partitions","page":"HMM Knockoffs","title":"Step 1: Partitions","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"We need","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Map file (in particular the (cM) field will determine group resolution)\nPLINK's bim file\nQC file (all SNP names that pass QC)\noutput file name","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Since data is simulated, there are no genomic map file. Let us generate a fake one. ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# generate fake map file\nmake_fake_mapfile(\"sim.map\", p)\n\n# also generate QC file that contains all SNPs and all samples\nsnpdata = SnpData(\"sim\")\nsnpIDs = snpdata.snp_info[!, :snpid]\nsampleIDs = Matrix(snpdata.person_info[!, 1:2])\nwritedlm(\"variants_qc.txt\", snpIDs)\nwritedlm(\"samples_qc.txt\", sampleIDs)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Now we run the partition script","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"plinkfile = \"sim\"\nmapfile = \"sim.map\"\nqc_variants = \"variants_qc.txt\"\noutfile = \"sim.partition.txt\"\npartition(partition_script, plinkfile, mapfile, qc_variants, outfile)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Warning messages:\n1: Quick-TRANSfer stage steps exceeded maximum (= 2500000) \n2: Quick-TRANSfer stage steps exceeded maximum (= 2500000) \n3: Quick-TRANSfer stage steps exceeded maximum (= 2500000) \n\n\nMean group sizes: \nres_7 res_6 res_5 res_4 res_3 res_2 res_1 \n    1 10000 10000 10000 10000 10000 10000 \nPartitions written to: sim.partition.txt\n\n\n\n\n\nProcess(`\u001b[4mRscript\u001b[24m \u001b[4m--vanilla\u001b[24m \u001b[4m/scratch/users/bbchu/knockoffgwas/knockoffgwas/utils/partition.R\u001b[24m \u001b[4msim.map\u001b[24m \u001b[4msim.bim\u001b[24m \u001b[4mvariants_qc.txt\u001b[24m \u001b[4msim.partition.txt\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/hmm/#Step-2:-Generate-Knockoffs","page":"HMM Knockoffs","title":"Step 2: Generate Knockoffs","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"First generate IBD segment files. This requires postprocessing the output of RapID, as described here. ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"vcffile = \"sim.phased.vcf.gz\"\nmapfile = \"sim.map\"\nmin_length = 1    # minimum IBD length in cM\noutfolder = \"rapid\"\nwindow_size = 5     # number of SNPs per window\nr = 1              # number of runs\ns = 10               # number of successes\nrapid(rapid_exe, vcffile, mapfile, min_length, outfolder, window_size, r, s)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Create sub-samples..\nDone!\n100 %\r\n\n\n\n\nProcess(`\u001b[4m/scratch/users/bbchu/RaPID/RaPID_v.1.7\u001b[24m \u001b[4m-i\u001b[24m \u001b[4msim.phased.vcf.gz\u001b[24m \u001b[4m-g\u001b[24m \u001b[4msim.map\u001b[24m \u001b[4m-d\u001b[24m \u001b[4m1\u001b[24m \u001b[4m-o\u001b[24m \u001b[4mrapid\u001b[24m \u001b[4m-w\u001b[24m \u001b[4m5\u001b[24m \u001b[4m-r\u001b[24m \u001b[4m1\u001b[24m \u001b[4m-s\u001b[24m \u001b[4m10\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Next convert VCF file to BGEN format (note: sample file must be saved separately)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# convert VCF to BGEN format\noutfile = \"sim.bgen\"\nrun(`$qctools_exe -g $vcffile -og $outfile`)\n\n# then save sample file separately\nopen(\"sim.sample\", \"w\") do io\n    println(io, \"ID_1 ID_2 missing sex\")\n    println(io, \"0 0 0 D\")\n    for i in 1:n\n        println(io, \"$i 1 0 1\")\n    end\nend","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Welcome to qctool\n(version: 2.0.7, revision )\n\n(C) 2009-2017 University of Oxford\n\nOpening genotype files                                      : [******************************] (1/1,0.0s,41.3/s)\n========================================================================\n\nInput SAMPLE file(s):         Output SAMPLE file:             \"(n/a)\".\nSample exclusion output file:   \"(n/a)\".\n\nInput GEN file(s):\n                                                    (not computed)  \"sim.phased.vcf.gz\"\n                                         (total 1 sources, number of snps not computed).\n                      Number of samples: 2000\nOutput GEN file(s):             \"sim.bgen\"\nOutput SNP position file(s):    (n/a)\nSample filter:                  .\n# of samples in input files:    2000.\n# of samples after filtering:   2000 (0 filtered out).\n\n========================================================================\n\nProcessing SNPs                                             :  (50000/?,142.7s,350.4/s)39809/?,119.8s,332.3/s):  (42338/?,126.9s,333.7/s)\nTotal: 50000SNPs.\n========================================================================\n\nNumber of SNPs:\n                     -- in input file(s):                 (not computed).\n -- in output file(s):                50000\n\nNumber of samples in input file(s):   2000.\n\nOutput GEN files:                     (50000  snps)  \"sim.bgen\"\n                                      (total 50000 snps).\n========================================================================\n\n\nThank you for using qctool.","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"The first few lines of the BGEN .sample file looks like:","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":";head sim.sample","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"ID_1 ID_2 missing sex\n0 0 0 D\n1 1 0 1\n2 1 0 1\n3 1 0 1\n4 1 0 1\n5 1 0 1\n6 1 0 1\n7 1 0 1\n8 1 0 1","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Finally, generate HMM knockoffs by running the following code in the command line directly. You may need to adjust file directories and change parameters. ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"bgenfile = \"sim\"\nsample_qc = \"samples_qc.txt\"\nvariant_qc = \"variants_qc.txt\"\nmapfile = \"sim.map\"\npartfile = \"sim.partition.txt\"\nibdfile = \"rapid/results.max\"\nK = 10\ncluster_size_min = 1000 \ncluster_size_max = 10000 \nhmm_rho = 1\nhmm_lambda = 1e-3 \nwindows = 0\nn_threads = 1\nseed = 2020\ncompute_references = true\ngenerate_knockoffs = true\noutfile = \"sim.knockoffs\"\n\n@time snpknock2(snpknock2_exe, bgenfile, sample_qc, variant_qc, mapfile, partfile, ibdfile, \n    K, cluster_size_min, cluster_size_max, hmm_rho, hmm_lambda, windows, n_threads, \n    seed, compute_references, generate_knockoffs, outfile)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"\t+----------------------+\n\t|                      |\n\t|  SNPKNOCK2, v0.3     |\n\t|  July 21, 2020       |\n\t|  Matteo Sesia        |\n\t|                      |\n\t+----------------------+\n\nCopyright (C) 2020 Stanford University.\nDistributed under the GNU GPLv3 open source license.\n\nUse --help for more information.\n\nCommand line arguments:\n  --bgen sim\n  --keep samples_qc.txt\n  --extract variants_qc.txt\n  --map sim.map\n  --part sim.partition.txt\n  --ibd rapid/results.max\n  --K 10\n  --cluster_size_min 1000\n  --cluster_size_max 10000\n  --hmm-rho 1\n  --hmm-lambda 0.001\n  --windows 0\n  --n_threads 1\n  --seed 2020\n  --compute-references\n  --generate-knockoffs\n  --out ./knockoffs/sim.knockoffs\n\nRequested operations:\n  --compute-references\n  --generate_knockoffs\n\n\n--------------------------------------------------------------------------------\nLoading metadata\n--------------------------------------------------------------------------------\nLoading sample information from:\n  sim.sample\nLoading legend from:\n  sim.bim\n\n\n┌ Info: snpknock2 command:\n│ `/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2 --bgen sim --keep samples_qc.txt --extract variants_qc.txt --map sim.map --part sim.partition.txt --ibd rapid/results.max --K 10 --cluster_size_min 1000 --cluster_size_max 10000 --hmm-rho 1 --hmm-lambda 0.001 --windows 0 --n_threads 1 --seed 2020 --compute-references --generate-knockoffs --out ./knockoffs/sim.knockoffs`\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/A1mdh/src/hmm_wrapper.jl:66\n┌ Info: Output directory: /home/users/bbchu/hmm/knockoffs\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/A1mdh/src/hmm_wrapper.jl:67\n\n\nLoading partitions from:\n  sim.partition.txt\nLoading IBD segments from:\n  rapid/results.max\nLoaded 0 IBD segments.\n\nPrinting summary of 1 windows:\n     0: 0--50000\nSummary of metadata for chromosome 1:\n  number of samples (after | before filtering) : 2000 | 2000\n  number of SNPs (after | before filtering)    : 50000 | 50000\n  number of variant partitions                 : 7\n  size of genomic windows                      : whole-chromosome\n  number of IBD segments                       : 0\n\n\n--------------------------------------------------------------------------------\nKinship (using only haplotype data)\n--------------------------------------------------------------------------------\nReached 1\nChromosome 1 will be loaded from:\n  haplotype file            : sim.bgen\n  sample file               : sim.sample\n  legend file               : sim.bim\n  thinning factor           : 10\n  sample filter file        : samples_qc.txt\n  variant filter file       : variants_qc.txt\n  number of SNPs            : 5000\n  number of haplotypes      : 4000\n\nReading BGEN file using 1 thread:\n|....................................................................................................|\n|====================================================================================================|\nSolving 1 bifurcating K-means problems using 1 threads.\n\nKinship clusters written to:\n  ./knockoffs/sim.knockoffs_clust.txt\n  ./knockoffs/sim.knockoffs.sample\n\nAssigning references for the whole chromosome using 1 threads: \n|....................................................................................................|\n|\n\n\nBifurcating K-means\nSmallest allowed cluster size: 1000\n step\t cluster\t    size\t    left\t   right\taccepted\nBifurcating K-means completed after 0 steps.\nNumber of clusters: 1.\n\n\n\n====================================================================================================|\n\nReached 2\nIndividual global references written to:\n  ./knockoffs/sim.knockoffs_lref.txt\n\nIndividual local references written to:\n  ./knockoffs/sim.knockoffs_ref.txt\n\n\n--------------------------------------------------------------------------------\nKnockoffs for chromosome 1\n--------------------------------------------------------------------------------\nChromosome 1 will be loaded from:\n  haplotype file            : sim\n  haplotype file format     : bgen\n  sample file               : sim.sample\n  legend file               : sim.bim\n  map file                  : sim.map\n  sample filter file        : samples_qc.txt\n  variant filter file       : variants_qc.txt\n  number of SNPs            : 50000\n  number of windows         : 1\n  number of haplotypes      : 4000\n\nLoading data for chromosome 1\nReading BGEN file using 1 thread:\n|....................................................................................................|\n|====================================================================================================|\n\nInitializing HMM with user-supplied hyperparameters: rho = 1, lambda = 0.001.\n\nHMM parameters written to:\n  ./knockoffs/sim.knockoffs_hmm.txt\n\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res0_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res0_windows.txt\n\nGenerating unrelated knockoffs for chromosome 1 (4000 haplotypes; 50000 variants in 50000 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res0.bed\n  ./knockoffs/sim.knockoffs_res0.bim\n  ./knockoffs/sim.knockoffs_res0.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res0_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res1_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res1_windows.txt\n\nGenerating unrelated knockoffs for chromosome 1 (4000 haplotypes; 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res1.bed\n  ./knockoffs/sim.knockoffs_res1.bim\n  ./knockoffs/sim.knockoffs_res1.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res1_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res2_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res2_windows.txt\n\nGenerating unrelated knockoffs for chromosome 1 (4000 haplotypes; 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res2.bed\n  ./knockoffs/sim.knockoffs_res2.bim\n  ./knockoffs/sim.knockoffs_res2.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res2_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res3_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res3_windows.txt\n\nGenerating unrelated knockoffs for chromosome 1 (4000 haplotypes; 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res3.bed\n  ./knockoffs/sim.knockoffs_res3.bim\n  ./knockoffs/sim.knockoffs_res3.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res3_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res4_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res4_windows.txt\n\nGenerating unrelated knockoffs for chromosome 1 (4000 haplotypes; 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res4.bed\n  ./knockoffs/sim.knockoffs_res4.bim\n  ./knockoffs/sim.knockoffs_res4.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res4_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res5_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res5_windows.txt\n\nGenerating unrelated knockoffs for chromosome 1 (4000 haplotypes; 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res5.bed\n  ./knockoffs/sim.knockoffs_res5.bim\n  ./knockoffs/sim.knockoffs_res5.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res5_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res6_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res6_windows.txt\n\nGenerating unrelated knockoffs for chromosome 1 (4000 haplotypes; 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res6.bed\n  ./knockoffs/sim.knockoffs_res6.bim\n  ./knockoffs/sim.knockoffs_res6.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res6_anc.txt\n\nFinished.\n\n661.571222 seconds (141.40 k allocations: 9.255 MiB)\n\n\n\n\n\nProcess(`\u001b[4m/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2\u001b[24m \u001b[4m--bgen\u001b[24m \u001b[4msim\u001b[24m \u001b[4m--keep\u001b[24m \u001b[4msamples_qc.txt\u001b[24m \u001b[4m--extract\u001b[24m \u001b[4mvariants_qc.txt\u001b[24m \u001b[4m--map\u001b[24m \u001b[4msim.map\u001b[24m \u001b[4m--part\u001b[24m \u001b[4msim.partition.txt\u001b[24m \u001b[4m--ibd\u001b[24m \u001b[4mrapid/results.max\u001b[24m \u001b[4m--K\u001b[24m \u001b[4m10\u001b[24m \u001b[4m--cluster_size_min\u001b[24m \u001b[4m1000\u001b[24m \u001b[4m--cluster_size_max\u001b[24m \u001b[4m10000\u001b[24m \u001b[4m--hmm-rho\u001b[24m \u001b[4m1\u001b[24m \u001b[4m--hmm-lambda\u001b[24m \u001b[4m0.001\u001b[24m \u001b[4m--windows\u001b[24m \u001b[4m0\u001b[24m \u001b[4m--n_threads\u001b[24m \u001b[4m1\u001b[24m \u001b[4m--seed\u001b[24m \u001b[4m2020\u001b[24m \u001b[4m--compute-references\u001b[24m \u001b[4m--generate-knockoffs\u001b[24m \u001b[4m--out\u001b[24m \u001b[4m./knockoffs/sim.knockoffs\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/hmm/#Examine-Generated-Knockoffs","page":"HMM Knockoffs","title":"Examine Generated Knockoffs","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"The generated knockoffs are saved in binary PLINK format, we can import it using SnpArrays","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"x = SnpArray(\"knockoffs/sim.knockoffs_res0.bed\")","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"2000×100000 SnpArray:\n 0x02  0x02  0x02  0x02  0x02  0x02  …  0x02  0x02  0x02  0x02  0x02  0x02\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00\n 0x02  0x02  0x00  0x02  0x02  0x02     0x00  0x00  0x03  0x03  0x03  0x03\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00\n 0x00  0x00  0x00  0x00  0x02  0x02     0x00  0x00  0x00  0x02  0x02  0x02\n 0x00  0x00  0x00  0x00  0x00  0x00  …  0x00  0x00  0x00  0x00  0x00  0x00\n 0x00  0x00  0x02  0x00  0x02  0x02     0x02  0x02  0x00  0x02  0x02  0x00\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00\n 0x00  0x00  0x00  0x02  0x00  0x00     0x02  0x02  0x02  0x02  0x03  0x03\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00\n 0x02  0x02  0x02  0x02  0x02  0x02  …  0x02  0x02  0x03  0x03  0x03  0x03\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00\n 0x00  0x02  0x02  0x02  0x03  0x03     0x02  0x02  0x02  0x02  0x02  0x02\n    ⋮                             ⋮  ⋱           ⋮                    \n 0x02  0x00  0x03  0x03  0x00  0x02     0x00  0x00  0x00  0x00  0x02  0x02\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00\n 0x00  0x02  0x03  0x03  0x02  0x02  …  0x02  0x02  0x03  0x02  0x03  0x03\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00\n 0x02  0x00  0x02  0x02  0x02  0x02     0x00  0x02  0x00  0x02  0x02  0x02\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00\n 0x00  0x02  0x02  0x02  0x03  0x03     0x03  0x03  0x03  0x03  0x03  0x03\n 0x00  0x00  0x00  0x00  0x00  0x00  …  0x00  0x00  0x00  0x00  0x00  0x00\n 0x00  0x00  0x00  0x00  0x02  0x00     0x00  0x02  0x02  0x02  0x02  0x02\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00\n 0x00  0x00  0x00  0x00  0x00  0x03     0x00  0x00  0x00  0x02  0x02  0x02\n 0x00  0x00  0x00  0x00  0x00  0x00     0x00  0x00  0x00  0x00  0x00  0x00","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Notice there are 100k SNPs: the original 50k SNPs and their knockoffs. Reading the SNP names will tell us which are the originals:","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"snpid = SnpData(\"knockoffs/sim.knockoffs_res0\").snp_info.snpid","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"100000-element Vector{String}:\n \"snp1.k\"\n \"snp1\"\n \"snp2\"\n \"snp2.k\"\n \"snp3.k\"\n \"snp3\"\n \"snp4.k\"\n \"snp4\"\n \"snp5.k\"\n \"snp5\"\n \"snp6\"\n \"snp6.k\"\n \"snp7\"\n ⋮\n \"snp49995\"\n \"snp49995.k\"\n \"snp49996.k\"\n \"snp49996\"\n \"snp49997.k\"\n \"snp49997\"\n \"snp49998.k\"\n \"snp49998\"\n \"snp49999\"\n \"snp49999.k\"\n \"snp50000.k\"\n \"snp50000\"","category":"page"},{"location":"man/hmm/#Step-3:-Model-selection-with-knockoffs","page":"HMM Knockoffs","title":"Step 3: Model selection with knockoffs","text":"","category":"section"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Tutorial for this part coming soon! Basically, one constructs a SnpLinAlg, feed that into MendelIHT.jl, and calculate knockoff statistics afterwards using built-in functions like coefficient_diff and threshold.","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"SnpLinAlg performs compressed linear algebra (often faster than double precision BLAS) and MendelIHT.jl is a very efficient implementation of the iterative hard thresholding algorithm. For model selection, IHT is known to be superior to standard LASSO, elastic net, and MCP solvers. ","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"xla = SnpLinAlg{Float64}(x, center=true, scale=true, impute=true)","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"2000×100000 SnpLinAlg{Float64}:\n  1.53523    1.40781    0.908525  …   0.892035   0.37139   0.376085\n -0.552097  -0.587668  -0.772373     -0.780008  -1.09078  -1.08728\n  1.53523    1.40781   -0.772373      2.56408    1.83356   1.83945\n -0.552097  -0.587668  -0.772373     -0.780008  -1.09078  -1.08728\n -0.552097  -0.587668  -0.772373      0.892035   0.37139   0.376085\n -0.552097  -0.587668  -0.772373  …  -0.780008  -1.09078  -1.08728\n -0.552097  -0.587668   0.908525      0.892035   0.37139  -1.08728\n -0.552097  -0.587668  -0.772373     -0.780008  -1.09078  -1.08728\n -0.552097  -0.587668  -0.772373      0.892035   1.83356   1.83945\n -0.552097  -0.587668  -0.772373     -0.780008  -1.09078  -1.08728\n  1.53523    1.40781    0.908525  …   2.56408    1.83356   1.83945\n -0.552097  -0.587668  -0.772373     -0.780008  -1.09078  -1.08728\n -0.552097   1.40781    0.908525      0.892035   0.37139   0.376085\n  ⋮                               ⋱                       \n  1.53523   -0.587668   2.58942      -0.780008   0.37139   0.376085\n -0.552097  -0.587668  -0.772373     -0.780008  -1.09078  -1.08728\n -0.552097   1.40781    2.58942   …   0.892035   1.83356   1.83945\n -0.552097  -0.587668  -0.772373     -0.780008  -1.09078  -1.08728\n  1.53523   -0.587668   0.908525      0.892035   0.37139   0.376085\n -0.552097  -0.587668  -0.772373     -0.780008  -1.09078  -1.08728\n -0.552097   1.40781    0.908525      2.56408    1.83356   1.83945\n -0.552097  -0.587668  -0.772373  …  -0.780008  -1.09078  -1.08728\n -0.552097  -0.587668  -0.772373      0.892035   0.37139   0.376085\n -0.552097  -0.587668  -0.772373     -0.780008  -1.09078  -1.08728\n -0.552097  -0.587668  -0.772373      0.892035   0.37139   0.376085\n -0.552097  -0.587668  -0.772373     -0.780008  -1.09078  -1.08728","category":"page"},{"location":"man/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"","category":"page"},{"location":"#Knockoffs.jl","page":"Home","title":"Knockoffs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a Julia implementation of the knockoff filter. The knockoff filter is a general framework for controlling the false discovery rate when performing variable selection. As the name suggests, the knockoff filter operates by manufacturing knockoff variables that are cheap — their construction does not require collecting any new data — and are designed to mimic the correlation structure found within the original variables. The knockoffs serve as negative controls and they allow one to identify the truly important predictors, while controlling the false discovery rate (FDR) — the expected fraction of false discoveries among all discoveries.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Within Julia,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"add https://github.com/biona001/Knockoffs.jl\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package supports Julia v1.6+.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/hmm.md\",\n    \"man/api.md\"\n]\nDepth = 2","category":"page"},{"location":"man/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"Here is a list of available function calls. A detailed description can be found below. ","category":"page"},{"location":"man/api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"man/api/#Regular-functions","page":"API","title":"Regular functions","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"  fixed_knockoffs\n  modelX_gaussian_knockoffs\n  normalize_col!\n  coefficient_diff\n  threshold\n  extract_beta\n  extract_combine_beta","category":"page"},{"location":"man/api/#Knockoffs.fixed_knockoffs","page":"API","title":"Knockoffs.fixed_knockoffs","text":"fixed_knockoffs(X::Matrix{T}; method=:sdp)\n\nCreates fixed knockoffs based on equation (2.2)-(2.4) of  \"Controlling the false discovery rate via Knockoffs\" by Barber and Candes (2015)\n\nInputs\n\nX: A n × p numeric matrix, each row is a sample, and each column is normalized\n\nto mean 0 variance 1 with unit norm. \n\nmethod: :equi for equi-distant knockoffs (eq 2.3) or :sdp for SDP\n\nknockoffs (eq 2.4)\n\nOutput\n\nKnockoff: A struct containing the original X and its knockoff X̃, \n\nin addition to other variables (e.g. s)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.modelX_gaussian_knockoffs","page":"API","title":"Knockoffs.modelX_gaussian_knockoffs","text":"modelX_gaussian_knockoffs(X::Matrix{T})\n\nCreates model-free multivariate normal knockoffs by sequentially sampling from  conditional multivariate normal distributions.\n\nInputs\n\nX: A n × p numeric matrix. Each row is a sample, and each column is standardized\n\nto mean 0 variance 1. \n\nReference:\n\n\"Panning for Gold: Model-X Knockoffs for High-dimensional Controlled Variable Selection\" by Candes, Fan, Janson, and Lv (2018)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.coefficient_diff","page":"API","title":"Knockoffs.coefficient_diff","text":"coefficient_diff(β::AbstractVector, method=:concat)\n\nReturns the coefficient difference statistic W[j] = |β[j]| - |β[j + p]|  from a univariate (single response) regression. \n\nInputs\n\nβ: Vector of regression coefficients\nmethod: Either :concatenated (default) if all knockoffs are concatenated   at the end (e.g. [XX̃]) or :interleaved if each variable is immediately   followed by its knockoff (e.g. [x₁x̃₁x₂x̃₂...])\n\n\n\n\n\ncoefficient_diff(β::AbstractVector, original::AbstractVector{Int}, knockoff::AbstractVector{Int})\n\nReturns the coefficient difference statistic W[j] = |β[j]| - |β[j + p]|  from a univariate (single response) regression, where the jth variable is stored in position original[j] of β, and its knockoff is stored in position knockoff[j]\n\nInputs\n\nβ: Vector of regression coefficients\noriginal: The index of original variables in β\nknockoff: The index of knockoff variables in β\n\n\n\n\n\ncoefficient_diff(β::AbstractVector, original::AbstractVector{Int}, knockoff::AbstractVector{Int})\n\nReturns the coefficient difference statistic for grouped variables W[G] = sum{j in G} |β[j]| - sum{j in G} |β[j + p]|.\n\nInputs\n\nβ: Vector of regression coefficients\ngroups: Vector storing group membership. groups[i] is the group of β[i]\noriginal: The index of original variables in β\nknockoff: The index of knockoff variables in β\n\n\n\n\n\ncoefficient_diff(B::AbstractMatrix)\n\nReturns the coefficient difference statistic W[j] = |B[j, 1]| - |B[j + p, 1]| + ... +  |B[j, r]| - |B[j + p, r]| from a multivariate (multiple response) regression. \n\nInputs\n\nβ: Matrix of regression coefficients. Each column is a vector of β. \nmethod: Either :concatenated if all knockoffs are concatenated at the end   (e.g. [XX̃]) or :interleaved if each variable is immediately followed by   its knockoff (e.g. [x₁x̃₁x₂x̃₂...])\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.threshold","page":"API","title":"Knockoffs.threshold","text":"threshold(w::AbstractVector, q::Number, method=:knockoff)\n\nChooses a threshold τ > 0 by setting τ = min{ t > 0 : {#j: w[j] ≤ -t} / {#j: w[j] ≥ t} ≤ q }.\n\nInputs\n\nw: Vector of feature important statistics\nq: target FDR (between 0 and 1)\nmethod: either :knockoff or :knockoff_plus\n\nReference:\n\nEquation 3.10 (method=:knockoff) or 3.11 (method=:knockoff_plus) of  \"Panning for Gold: Model-X Knockoffs for High-dimensional Controlled Variable Selection\" by Candes, Fan, Janson, and Lv (2018)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.extract_beta","page":"API","title":"Knockoffs.extract_beta","text":"extract_beta(β̂_knockoff::AbstractVector, fdr::Number, method::Symbol=:concatenated)\n\nGiven estimated β of original variables and their knockoffs, compute β for the original design matrix that controls the FDR.\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Wrapper-functions-for-HMM-knockoffs","page":"API","title":"Wrapper functions for HMM knockoffs","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"  partition\n  rapid\n  snpknock2","category":"page"}]
}
