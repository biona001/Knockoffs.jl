var documenterSearchIndex = {"docs":
[{"location":"man/group/#Group-Knockoffs","page":"Group Knockoffs","title":"Group Knockoffs","text":"","category":"section"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"This tutorial generates group (model-X) knockoffs, which is useful when predictors are highly correlated. The methodology is described in the following paper","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Dai R, Barber R. The knockoff filter for FDR control in group-sparse and multitask regression. InInternational conference on machine learning 2016 Jun 11 (pp. 1851-1859). PMLR.","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"note: Note\nIn the original paper, Dai and Barber only describes how to construct a suboptimal equi-correlated group knockoffs. Here we implement fully generalized alternatives.","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Currently available options for group knockoffs:","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":":maxent: Fully general maximum entropy (maxent) group knockoff, based on coordinate descent.\n:mvr: Fully general minimum variance-based reconstructability (MVR) group knockoff, based on coordinate descent.\n:sdp: Fully general SDP group knockoffs, based on coordinate descent. In general MVR/ME knockoffs tends to perform better than SDP in terms of power, and SDP generally converges slower. \n:equi: This implements the equi-correlated idea proposed in Barber and Dai, which lets S_j = gamma Sigma_(G_j G_j) where Sigma_(G_j G_j) is the block of Sigma containing variables in the jth group. Thus, instead of optimizing over all variables in S, we optimize a scalar gamma. Conveniently, there a simple closed form solution for gamma. For mvr and maxent group knockoffs, we initialize S using this construction. \n:sdp_subopt: This generalizes the equi-correlated group knockoff idea by having S_j = gamma_j Sigma_(G_j G_j). Instead of optimizing over all variables in S, we optimize over a vector gamma_1gamma_G. Note this functionality is mainly provided for testing purposes. ","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"# load packages for this tutorial\nusing Knockoffs\nusing LinearAlgebra\nusing Random\nusing StatsKit\nusing ToeplitzMatrices\nusing Distributions","category":"page"},{"location":"man/group/#Gaussian-model-X-group-knockoffs-with-known-mean-and-covariance","page":"Group Knockoffs","title":"Gaussian model-X group knockoffs with known mean and covariance","text":"","category":"section"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"To illustrate, lets simulate data mathbfX with covariance Sigma and mean mu. Our model is","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"beginaligned\n    X_p times 1 sim N(mathbf0_p Sigma)\nendaligned","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"where","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"beginaligned\nSigma = \nbeginpmatrix\n    1  rho  rho^2    rho^p\n    rho  1     rho^p-1\n    vdots    1  vdots \n    rho^p  cdots    1\nendpmatrix\nendaligned","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Given n iid samples from the above distribution, we will generate knockoffs according to ","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"beginaligned\n(X tildeX) sim N\nleft(0  \nbeginpmatrix\n    Sigma  Sigma - S\n    Sigma - S  Sigma\nendpmatrix\nright)\nendaligned","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"where S is a block-diagonal matrix satisfying S succeq 0 and 2Sigma - S succeq 0. ","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Because variables are highly correlated with its neighbors (rho = 09), it becomes difficult to distinguish which among a bunch of highly correlated variables are truly causal. Thus, group knockoffs test whether a group of variables have any signal should have better power than standard (single-variable) knockoffs. ","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"First, lets simulate some data","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"# simulate data\nRandom.seed!(2023)\nn = 250 # sample size\np = 500 # number of features\nk = 10  # number of causal variables\nΣ = Matrix(SymmetricToeplitz(0.9.^(0:(p-1))))\n# Σ = simulate_AR1(p, a=3, b=1)\n# Σ = simulate_block_covariance(groups, 0.75, 0.25)\nμ = zeros(p)\nL = cholesky(Σ).L\nX = randn(n, p) * L # design matrix\nzscore!(X, mean(X, dims=1), std(X, dims=1)); # standardize columns of X","category":"page"},{"location":"man/group/#Define-group-memberships","page":"Group Knockoffs","title":"Define group memberships","text":"","category":"section"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"To generate group knockoffs, we need to vector specifying group membership. One can define this vector manually, or use the built-in functions hc_partition_groups or id_partition_groups. ","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"groups = hc_partition_groups(X, cutoff = 0.5)","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"500-element Vector{Int64}:\n  1\n  1\n  1\n  2\n  2\n  2\n  2\n  3\n  3\n  3\n  3\n  3\n  4\n  ⋮\n 93\n 93\n 93\n 93\n 94\n 94\n 94\n 95\n 95\n 96\n 96\n 96","category":"page"},{"location":"man/group/#Generating-group-knockoffs","page":"Group Knockoffs","title":"Generating group knockoffs","text":"","category":"section"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Generate group knockoffs with the exported function modelX_gaussian_group_knockoffs. Similar to non-group knockoffs, group knockoff accepts keyword arguments m, tol, method, and verbose which controls the algorithm's behavior. ","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"@time me = modelX_gaussian_group_knockoffs(\n    X, :maxent, groups, μ, Σ, \n    m = 5,              # number of knockoffs per variable to generate\n    tol = 0.001,        # convergence tolerance\n    inner_ccd_iter = 1, # optimize every entry of S exactly 1 time before moving on to PCA updates\n    inner_pca_iter = 1, # optimize S with respect to pre-computed eigenvectors 1 time before going to CCA updates\n    verbose=true);      # whether to print informative intermediate results","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Maxent initial obj = -12356.342528382938\nIter 1 (PCA): obj = -8052.261406317261, δ = 0.08590802942739098, t1 = 0.11, t2 = 0.06\nIter 2 (CCD): obj = -7794.572748302039, δ = 0.021168745196021146, t1 = 0.17, t2 = 0.18, t3 = 0.0\nIter 3 (PCA): obj = -7511.581367389803, δ = 0.051611315519312195, t1 = 0.28, t2 = 0.24\nIter 4 (CCD): obj = -7461.192156067141, δ = 0.012741504093028691, t1 = 0.32, t2 = 0.37, t3 = 0.0\nIter 5 (PCA): obj = -7338.128509045188, δ = 0.047892393422037396, t1 = 0.39, t2 = 0.43\nIter 6 (CCD): obj = -7308.932874229332, δ = 0.01053604459600144, t1 = 0.43, t2 = 0.55, t3 = 0.0\nIter 7 (PCA): obj = -7229.540018465837, δ = 0.036888999559287136, t1 = 0.51, t2 = 0.61\nIter 8 (CCD): obj = -7208.67612681877, δ = 0.009320045724745799, t1 = 0.55, t2 = 0.74, t3 = 0.0\nIter 9 (PCA): obj = -7154.410518552644, δ = 0.030821712350118435, t1 = 0.62, t2 = 0.79\nIter 10 (CCD): obj = -7137.772110915237, δ = 0.00853792672155702, t1 = 0.66, t2 = 0.93, t3 = 0.0\nIter 11 (PCA): obj = -7099.32785445378, δ = 0.03136109572323209, t1 = 0.77, t2 = 0.98\nIter 12 (CCD): obj = -7085.247398507887, δ = 0.007935922476527225, t1 = 0.81, t2 = 1.11, t3 = 0.0\nIter 13 (PCA): obj = -7057.1404838054295, δ = 0.03291205436687801, t1 = 0.92, t2 = 1.17\nIter 14 (CCD): obj = -7044.876172687204, δ = 0.007314871106654346, t1 = 0.96, t2 = 1.3, t3 = 0.01\nIter 15 (PCA): obj = -7023.629304760585, δ = 0.03250775080424084, t1 = 1.06, t2 = 1.36\nIter 16 (CCD): obj = -7012.850120947562, δ = 0.006854890650307599, t1 = 1.11, t2 = 1.49, t3 = 0.01\nIter 17 (PCA): obj = -6996.271858853715, δ = 0.030738229078674354, t1 = 1.21, t2 = 1.55\nIter 18 (CCD): obj = -6986.792631541152, δ = 0.006430704916053182, t1 = 1.25, t2 = 1.68, t3 = 0.01\nIter 19 (PCA): obj = -6973.531686161982, δ = 0.028115057674247407, t1 = 1.37, t2 = 1.74\nIter 20 (CCD): obj = -6965.156942284159, δ = 0.006029270847763139, t1 = 1.41, t2 = 1.87, t3 = 0.01\nIter 21 (PCA): obj = -6954.364877631323, δ = 0.02578275449508116, t1 = 1.48, t2 = 1.93\nIter 22 (CCD): obj = -6946.941292530288, δ = 0.005644470245583583, t1 = 1.52, t2 = 2.06, t3 = 0.01\nIter 23 (PCA): obj = -6938.0502511322275, δ = 0.023339824851938414, t1 = 1.58, t2 = 2.11\nIter 24 (CCD): obj = -6931.429620290818, δ = 0.005272863979625453, t1 = 1.62, t2 = 2.24, t3 = 0.01\nIter 25 (PCA): obj = -6924.0383562435045, δ = 0.02083871047261553, t1 = 1.67, t2 = 2.29\nIter 26 (CCD): obj = -6918.112876107218, δ = 0.004918165386397036, t1 = 1.71, t2 = 2.42, t3 = 0.01\nIter 27 (PCA): obj = -6911.905927691649, δ = 0.018590008447367395, t1 = 1.78, t2 = 2.48\nIter 28 (CCD): obj = -6906.577950472131, δ = 0.00457709162696512, t1 = 1.83, t2 = 2.61, t3 = 0.01\n  4.830540 seconds (42.09 k allocations: 236.493 MiB, 0.18% gc time)","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Here CCD corresponds to optimization each entry S_ij independently, while PCA is a faster update that updates S_new = S + delta vv. \nUsers can modify the default behavior by supplying the arguments inner_pca_iter and inner_ccd_iter. For instance, we can turn off inner_ccd_iter to achieve much faster convergence at the sacrifice small accuracy. \nt_1 t_2 t_3 are timers, which reveals that the computational bottleneck is in (2), which we dispatch to efficient LAPACK libraries, so the overall performance of our algorithm cannot really be improved. \nt_1: updating cholesky factors\nt_2: solving forward-backward equations\nt_3: solving off-diagonal 1D optimization problems using Brent's method","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"The output is a struct with the following fields","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"struct GaussianGroupKnockoff{T<:AbstractFloat, BD<:AbstractMatrix, S<:Symmetric} <: Knockoff\n    X::Matrix{T} # n × p design matrix\n    Xko::Matrix{T} # n × mp matrix storing knockoffs of X\n    groups::Vector{Int} # p × 1 vector of group membership\n    S::BD # p × p block-diagonal matrix of the same size as Sigma. S and (m+1)/m*Sigma - S are both psd\n    gammas::Vector{T} # for suboptimal group construction only. These are scalars chosen so that S_i = γ_i * Sigma_i\n    m::Int # number of knockoffs per feature generated\n    Sigma::S # p × p symmetric covariance matrix. \n    method::Symbol # method for solving s\n    obj::T # final objective value of group knockoff\nend","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Given this result, lets do a sanity check: is (m+1)mSigma - S positive semi-definite?","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"m = 5\neigmin((m+1)/m*me.Sigma - me.S)","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"0.007406506932664684","category":"page"},{"location":"man/group/#Second-order-group-knockoffs","page":"Group Knockoffs","title":"Second order group knockoffs","text":"","category":"section"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"In practice, we often do not have the true covariance matrix Sigma and the true means mu. In that case, we can generate second order group knockoffs via the 3 argument function","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"me_second_order = modelX_gaussian_group_knockoffs(X, :maxent, groups);","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"This will estimate the covariance matrix via a shrinkage estimator, see documentation API for more details. ","category":"page"},{"location":"man/group/#Group-knockoffs-based-on-conditional-independence-assumption","page":"Group Knockoffs","title":"Group knockoffs based on conditional independence assumption","text":"","category":"section"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"One can choose a few representatives from each group and generate representative group knockoffs via modelX_gaussian_rep_group_knockoffs. Its advantages include:","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Dramatically improved computational efficiency, since the group-knockoff optimization problem only needs to be carried out on the representative variables.\nImproved power over standard group knockoffs, since the exchangeability have to be satisfied for less variables, so the resulting knockoffs are more \"flexible\"","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"This model assume that conditional on the group representatives, remaining variables are independent by groups. Although this assumption is not always met, we find that group-FDR is never really violated when rep_threshold = 0.5 in our experiments with real or simulated data. ","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"@time rME = modelX_gaussian_rep_group_knockoffs(\n    X, :maxent, groups, μ, Σ, \n    m = 5,               # number of knockoffs per variable to generate\n    tol = 0.0001,        # convergence tolerance\n    rep_threshold = 0.5, # R2 threshold for choosing representatives\n    verbose=true);       # whether to print informative intermediate results","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"96 representatives for 500 variables, 96 optimization variables\nIter 1: δ = 0.1495328321789994\nIter 2: δ = 0.19916106242709308\nIter 3: δ = 0.019321694755150942\nIter 4: δ = 0.005068052646868659\nIter 5: δ = 0.0009112831450813208\nIter 6: δ = 0.00012302743183395526\nIter 7: δ = 2.467589395582781e-5\n  0.341659 seconds (15.35 k allocations: 214.558 MiB, 5.78% gc time)","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Observe the 96/500 variables were selected as representatives, resulting in 10 times speedup compared to standard group knockoffs. ","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Also, the resulting knockoffs is still n times mp, so we do sample knockoffs for each variable even though the optimization was only carried out on a subset.","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"rME.Xko","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"250×2500 Matrix{Float64}:\n -1.65214    -1.2264     -0.90357    …   2.37346      2.19603     1.85045\n  1.04509     0.742908    0.276858      -0.19256     -0.127092   -0.590027\n  0.202973   -1.17446    -0.66758       -0.493992    -0.240993    0.115518\n  0.718775    0.878739    0.538289       1.44572      1.66234     1.60899\n -0.432394    0.0979436   1.42076       -0.401493    -0.235617   -0.273724\n -1.06394    -1.1612     -0.668314   …   1.68086      0.518035    0.473119\n  1.51455     1.30363     0.229759       0.00686854   0.035861   -0.201092\n  0.0646647  -1.05129    -0.120897      -0.621302    -0.287705    0.248626\n -1.91251    -1.13833    -2.38578        1.17047      0.782406    0.256628\n  0.202989   -0.707357   -0.793931      -0.538658    -0.940356   -0.54821\n -0.143222   -0.617772   -0.667247   …  -0.582162     0.0561363  -0.0149074\n  1.99224     1.03271     0.248894      -0.101577    -0.766011   -1.01534\n -0.586636   -0.585003    0.0514114     -1.2039      -0.702172   -0.708949\n  ⋮                                  ⋱                           \n -0.643646   -0.0710437  -0.380527      -0.395322    -0.667184   -0.0555226\n -0.36097    -0.174519    1.15659        0.810179     0.23772     0.279265\n  1.00372     0.525153    0.509426   …   0.893199     0.391243    0.0832597\n  0.237773   -0.0549151  -1.04705       -1.05313     -1.19608    -0.863732\n  0.419572    0.611245    1.18161       -0.831543    -0.680479   -1.24888\n -1.82841    -1.42881    -1.34797        2.41993      2.69197     2.47547\n -1.0607     -0.798633   -0.798233      -0.578312    -0.510215   -0.0882358\n -0.622852   -0.0162713   0.743521   …  -0.132991    -0.514501   -0.962194\n -0.165246    1.11386     0.689408      -0.14881     -0.6484     -0.456806\n -0.500523   -0.421848   -0.481629       1.01061      0.982484    0.529933\n  2.10645     2.79504     2.12414        0.824754     0.530422    0.777875\n -0.391608   -0.45099    -0.856056       0.461328    -0.396119   -0.599234","category":"page"},{"location":"man/group/#Lasso-Example","page":"Group Knockoffs","title":"Lasso Example","text":"","category":"section"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Lets see the empirical power and FDR group knockoffs over 10 simulations when","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"the targer FDR is 10%\nwe generate m=5 knockoffs per feature\nbeta_j sim pm 025 for 10 causal js","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Note power and FDR is defined at the group level","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"group_powers, group_fdrs, group_times, group_s = Float64[], Float64[], Float64[], Float64[]\n\nRandom.seed!(2022)\nfor sim in 1:10\n    # simulate X\n    Random.seed!(sim)\n    n = 1000 # sample size\n    p = 200  # number of covariates\n    k = 10   # number of true predictors\n    Σ = Matrix(SymmetricToeplitz(0.9.^(0:(p-1)))) # true covariance matrix\n    μ = zeros(p)\n    L = cholesky(Σ).L\n    X = randn(n, p) * L\n    zscore!(X, mean(X, dims=1), std(X, dims=1)); # standardize columns of X\n\n    # define groups\n    groups = hc_partition_groups(X, cutoff=0.5)\n    \n    # simulate y\n    βtrue = zeros(p)\n    βtrue[1:k] .= rand(-1:2:1, k) .* 0.25\n    shuffle!(βtrue)\n    correct_groups = groups[findall(!iszero, βtrue)] |> unique\n    ϵ = randn(n)\n    y = X * βtrue + ϵ;\n\n    # group ME knockoffs\n    t = @elapsed ko_filter = fit_lasso(y, X, method=:maxent, groups=groups, m=5)\n    selected = ko_filter.selected[3]\n    power = length(intersect(correct_groups, selected)) / length(correct_groups)\n    fdr = length(setdiff(selected, correct_groups)) / max(1, length(selected))\n    println(\"Sim $sim group-knockoff power = $power, FDR = $fdr, time=$t\")\n    push!(group_powers, power); push!(group_fdrs, fdr); push!(group_times, t)\n    GC.gc();GC.gc();GC.gc();\nend\n\nprintln(\"\\nME group knockoffs have average group power $(mean(group_powers))\")\nprintln(\"ME group knockoffs have average group FDR $(mean(group_fdrs))\")\nprintln(\"ME group knockoffs took average $(mean(group_times)) seconds\");","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Sim 1 group-knockoff power = 1.0, FDR = 0.1, time=9.395477167\nSim 2 group-knockoff power = 0.7777777777777778, FDR = 0.0, time=8.08905475\nSim 3 group-knockoff power = 0.8888888888888888, FDR = 0.1111111111111111, time=6.093907333\nSim 4 group-knockoff power = 0.8, FDR = 0.0, time=8.676211084\nSim 5 group-knockoff power = 0.7, FDR = 0.0, time=10.33491675\nSim 6 group-knockoff power = 0.5, FDR = 0.0, time=10.055918625\nSim 7 group-knockoff power = 1.0, FDR = 0.0, time=6.909068458\nSim 8 group-knockoff power = 0.4444444444444444, FDR = 0.0, time=9.819233042\nSim 9 group-knockoff power = 0.7, FDR = 0.0, time=11.155753209\nSim 10 group-knockoff power = 0.5555555555555556, FDR = 0.0, time=7.340749875\n\nME group knockoffs have average group power 0.7366666666666667\nME group knockoffs have average group FDR 0.021111111111111112\nME group knockoffs took average 8.7870290293 seconds","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"For comparison, lets try the same simulation but we generate regular (non-grouped) knockoffs","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"regular_powers, regular_fdrs, regular_times = Float64[], Float64[], Float64[]\n\nRandom.seed!(2022)\nfor sim in 1:10\n    # simulate X\n    Random.seed!(sim)\n    n = 1000 # sample size\n    p = 200  # number of covariates\n    k = 10   # number of true predictors\n    Σ = Matrix(SymmetricToeplitz(0.9.^(0:(p-1)))) # true covariance matrix\n    μ = zeros(p)\n    L = cholesky(Σ).L\n    X = randn(n, p) * L\n    zscore!(X, mean(X, dims=1), std(X, dims=1)); # standardize columns of X\n    \n    # simulate y\n    βtrue = zeros(p)\n    βtrue[1:k] .= rand(-1:2:1, k) .* 0.25\n    shuffle!(βtrue)\n    correct_snps = findall(!iszero, βtrue)\n    ϵ = randn(n)\n    y = X * βtrue + ϵ;\n\n    # group ME knockoffs\n    t = @elapsed ko_filter = fit_lasso(y, X, method=:maxent, m=5)\n    selected = ko_filter.selected[3]\n    power = length(intersect(correct_snps, selected)) / length(correct_snps)\n    fdr = length(setdiff(selected, correct_snps)) / max(1, length(selected))\n    println(\"Sim $sim nongroup-knockoff power = $power, FDR = $fdr, time=$t\")\n    push!(regular_powers, power); push!(regular_fdrs, fdr); push!(regular_times, t)\n    GC.gc();GC.gc();GC.gc();\nend\n\nprintln(\"\\nME (standard) knockoffs have average group power $(mean(regular_powers))\")\nprintln(\"ME (standard) knockoffs have average group FDR $(mean(regular_fdrs))\")\nprintln(\"ME (standard) knockoffs took average $(mean(regular_times)) seconds\");","category":"page"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"Sim 1 nongroup-knockoff power = 0.7, FDR = 0.2222222222222222, time=7.151643042\nSim 2 nongroup-knockoff power = 0.7, FDR = 0.0, time=7.163531958\nSim 3 nongroup-knockoff power = 0.2, FDR = 0.0, time=5.438854459\nSim 4 nongroup-knockoff power = 0.0, FDR = 0.0, time=7.861218583\nSim 5 nongroup-knockoff power = 0.2, FDR = 0.0, time=9.57650625\nSim 6 nongroup-knockoff power = 0.0, FDR = 0.0, time=8.987028709\nSim 7 nongroup-knockoff power = 0.0, FDR = 0.0, time=5.27945125\nSim 8 nongroup-knockoff power = 0.0, FDR = 0.0, time=9.898184792\nSim 9 nongroup-knockoff power = 0.4, FDR = 0.0, time=10.721144208\nSim 10 nongroup-knockoff power = 0.5, FDR = 0.0, time=6.266258084\n\nME (standard) knockoffs have average group power 0.26999999999999996\nME (standard) knockoffs have average group FDR 0.02222222222222222\nME (standard) knockoffs took average 7.8343821335 seconds","category":"page"},{"location":"man/group/#Conclusion","page":"Group Knockoffs","title":"Conclusion","text":"","category":"section"},{"location":"man/group/","page":"Group Knockoffs","title":"Group Knockoffs","text":"When variables are highly correlated so that one cannot find exact discoveries, group knockoffs may be useful for improving power as it identifies whether a group of variables are non-null without having to pinpoint the exact discovery. It trades resolution to discover more causal signals.\nGroup knockoffs control the group FDR to be below the target FDR level. \nGroups do not have to be contiguous\nWith modest group sizes, group knockoff's compute time is roughly equivalent to standard (non-grouped) knockoffs\nWhen p is too large or group sizes are too large, one can employ representative group knockoff strategy. Empirically it has better power and much faster compute times. ","category":"page"},{"location":"man/shapeit_hmm/#SHAPEIT-HMM-knockoffs","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"This page is a tutorial for generating (SHAPEIT) HMM knockoffs, which is good for controlling FDR in the presence of cryptic relatedness and diverse ancestries. The methodology is described in the following paper:","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Sesia, Matteo, et al. \"False discovery rate control in genome-wide association studies with population structure.\" Proceedings of the National Academy of Sciences 118.40 (2021). ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"This tutorial closely follows the original knockoffgwas tutorial. Currently users need to manually run and process various input/intermediate files, but eventually, we will write native Julia wrappers to circumvent these tedious procedures. Stay tuned. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"note: Note\nIt is highly recommended to run this tutorial on linux machines, because RaPID (for detecting IBD segments) only run on linux. Currently users of windows and macOS machines must assume no IBD segments exist. ","category":"page"},{"location":"man/shapeit_hmm/#Installation","page":"SHAPEIT HMM knockoffs","title":"Installation","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Install knockoffgwas and its dependencies\nInstall qctools for converting between VCF and BGEN formats\nInstall RaPID for detecting IBD segments (this only run on linux)\nInstall the following Julia packages. Within julia, type","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"]add SnpArrays Distributions ProgressMeter MendelIHT VCFTools StatsBase CodecZlib\n]add https://github.com/biona001/Knockoffs.jl","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Finally, modify these executable path to the ones installed on your local computer. Here the partition_exe is located under the path you installed knockoffgwas: knockoffgwas/knockoffgwas/utils/partition.R.","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"qctools_exe = \"/scratch/users/bbchu/qctool/build/release/qctool_v2.0.7\"\nsnpknock2_exe = \"/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2\"\nrapid_exe = \"/scratch/users/bbchu/RaPID/RaPID_v.1.7\"\npartition_exe = \"/scratch/users/bbchu/knockoffgwas/knockoffgwas/utils/partition.R\";","category":"page"},{"location":"man/shapeit_hmm/#Required-inputs","page":"SHAPEIT HMM knockoffs","title":"Required inputs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"We need multiple input files to generate knockoffs","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Unphased genotypes in binary PLINK format\nPhased genotypes in VCF and BGEN format: we will simulate haplotypes, store in VCF format, and convert to BGEN using qctools\nNote: knockoffgwas requires only BGEN format, but RaPID requires VCF formats. Hence, the extra conversion\nMap file (providing different group resolution): since data is simulated, we will generate fake map file\nIBD segment file (generated by RaPID which requires VCF inputs)\nVariant partition files (generated by snpknock2, i.e. module 2 of knockoffgwas) \nSample and variant QC files","category":"page"},{"location":"man/shapeit_hmm/#Simulate-genotypes","page":"SHAPEIT HMM knockoffs","title":"Simulate genotypes","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Our simulation will try to follow","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Adding population structure (admixture & cryptic relatedness): New approaches to population stratification in genome-wide association studies\nHow to simulate siblings: Using Extended Genealogy to Estimate Components of Heritability for 23 Quantitative and Dichotomous Traits","category":"page"},{"location":"man/shapeit_hmm/#Population-structure","page":"SHAPEIT HMM knockoffs","title":"Population structure","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Specifically, lets simulate genotypes with 2 populations. We simulate 49700 normally differentiated markers and 300 unusually differentiated markers based on allele frequency difference equal to 0.6. Let x_ij be the number of alternate allele count for sample i at SNP j with allele frequency p_j. Also let h_ij 1 denotype haplotype 1 of sample i at SNP j and h_ij 2 the second haplotype. Our simulation model is","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"h_ij 1 sim Bernoulli(p_j) quad h_ij 2 sim Bernoulli(p_j) quad x_ij = h_ij 1 + h_ij 2","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"which is equivalent to  ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"x_ij sim Binomial(2 p_j)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"for unphased data. The allele frequency is p_j = Uniform(0 1) for normally differentiated markers, and ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"p_pop1 j sim Uniform(0 04) quad p_pop2 j = p_pop1 j + 06","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"for abnormally differentiated markers. Each sample is randomly assigned to population 1 or 2. ","category":"page"},{"location":"man/shapeit_hmm/#Sibling-pairs","page":"SHAPEIT HMM knockoffs","title":"Sibling pairs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Based on the simulated data above, we can randomly sample pairs of individuals and have them produce offspring. Here, half of all offsprings will be siblings with the other half. This is done by first randomly sampling 2 person to represent parent. Assume they have 2 children. Then generate offspring individuals by copying segments of one parent haplotype directly to the corresponding haplotype of the offspring. This recombination event will produce IBD segments. The number of recombination is 1 or 2 per chromosome, and is chosen uniformly across the chromosome. ","category":"page"},{"location":"man/shapeit_hmm/#Step-0:-simulate-genotypes","page":"SHAPEIT HMM knockoffs","title":"Step 0: simulate genotypes","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Load Julia packages needed for this tutorial","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"using SnpArrays\nusing Knockoffs\nusing DelimitedFiles\nusing Random\nusing LinearAlgebra\nusing Distributions\nusing ProgressMeter\nusing MendelIHT\nusing VCFTools\nusing StatsBase\nusing CodecZlib","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Load helper functions needed for this tutorial (data simulation + some glue code). It is not crucial to understand what they are doing.  ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"\"\"\"\n    simulate_pop_structure(n, p)\n\nSimulate genotypes with K = 2 populations. 300 SNPs will have different allele \nfrequencies between the populations, where 50 of them will be causal\n\n# Inputs\n- `plinkfile`: Output plink file name. \n- `n`: Number of samples\n- `p`: Number of SNPs\n\n# Output\n- `x1`: n×p matrix of the 1st haplotype for each sample. Each row is a haplotype\n- `x2`: n×p matrix of the 2nd haplotype for each sample. `x = x1 + x2`\n- `populations`: Vector of length `n` indicating population membership for eachsample. \n- `diff_markers`: Indices of the differentially expressed alleles.\n\n# Reference\nhttps://www.nature.com/articles/nrg2813\n\"\"\"\nfunction simulate_pop_structure(n::Int, p::Int)\n    # first simulate genotypes treating all samples equally\n    x1 = BitMatrix(undef, n, p)\n    x2 = BitMatrix(undef, n, p)\n    pmeter = Progress(p, 0.1, \"Simulating genotypes...\")\n    @inbounds for j in 1:p\n        d = Bernoulli(rand())\n        for i in 1:n\n            x1[i, j] = rand(d)\n            x2[i, j] = rand(d)\n        end\n        next!(pmeter)\n    end\n    # assign populations and simulate 300 unually differentiated markers\n    populations = rand(1:2, n)\n    diff_markers = sample(1:p, 300, replace=false)\n    @inbounds for j in diff_markers\n        pop1_allele_freq = 0.4rand()\n        pop2_allele_freq = pop1_allele_freq + 0.6\n        pop1_dist = Bernoulli(pop1_allele_freq)\n        pop2_dist = Bernoulli(pop2_allele_freq)\n        for i in 1:n\n            d = isone(populations[i]) ? pop1_dist : pop2_dist\n            x1[i, j] = rand(d)\n            x2[i, j] = rand(d)\n        end\n    end\n    return x1, x2, populations, diff_markers\nend\n\n\"\"\"\n    simulate_IBD(h1::BitMatrix, h2::BitMatrix, k::Int)\n\nSimulate recombination events. Parent haplotypes `h1` and `h2` will be used to generate \n`k` children, then both parent and children haplotypes will be returned. \n\nIn offspring simulation, half of all offsprings will be siblings with the other half.\nThis is done by first randomly sampling 2 samples from to represent parent. Assume they have\n2 children. Then generate offspring individuals by copying segments of the parents haplotype\ndirectly to the offspring to represent IBD segments. The number of segments (i.e. places of\nrecombination) is 1 or 2 per chromosome, and is chosen uniformly across the chromosome. \n\n# Inputs\n- `h1`: `n × p` matrix of the 1st haplotype for each parent. Each row is a haplotype\n- `h2`: `n × p` matrix of the 2nd haplotype for each parent. `H = h1 + h2`\n- `k`: Total number of offsprings\n\n# Output\n- `H1`: `n+k × p` matrix of the 1st haplotype. The first `n` haplotypes are from parents\n    and the next `k` haplotypes are the offsprings. Each row is a haplotype\n- `H2`: `n+k × p` matrix of the 2nd haplotype. `x = x1 + x2`\n\n# References\nhttps://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1003520\n\"\"\"\nfunction simulate_IBD(h1::BitMatrix, h2::BitMatrix, k::Int)\n    n, p = size(h1)\n    iseven(k) || error(\"number of offsprings should be even\")\n    # randomly designate gender for parents\n    sex = bitrand(n)\n    male_idx = findall(x -> x == true, sex)\n    female_idx = findall(x -> x == false, sex)\n    # simulate new samples\n    x1 = falses(k, p)\n    x2 = falses(k, p)\n    fathers = Int[]\n    mothers = Int[]\n    pmeter = Progress(k, 0.1, \"Simulating IBD segments...\")\n    for i in 1:k\n        # assign parents\n        dad = rand(male_idx)\n        mom = rand(female_idx)\n        push!(fathers, dad)\n        push!(mothers, mom)\n        # recombination\n        recombine!(@view(x1[i, :]), @view(x2[i, :]), @view(h1[dad, :]),\n                   @view(h2[dad, :]), @view(h1[mom, :]), @view(h2[mom, :]))\n        # update progress\n        next!(pmeter)\n    end\n    # combine offsprings and parents\n    H1 = [h1; x1]\n    H2 = [h2; x2]\n    return H1, H2, fathers, mothers\nend\n\nfunction recombination_segments(breakpoints::Vector{Int}, snps::Int)\n    start = 1\n    result = UnitRange{Int}[]\n    for bkpt in breakpoints\n        push!(result, start:bkpt)\n        start = bkpt + 1\n    end\n    push!(result, breakpoints[end]+1:snps)\n    return result\nend\n\nfunction recombine!(child_h1, child_h2, dad_h1, dad_h2, mom_h1, mom_h2)\n    p = length(child_h1)\n    recombinations = rand(1:5)\n    breakpoints = sort!(sample(1:p, recombinations, replace=false))\n    segments = recombination_segments(breakpoints, p)\n    for segment in segments\n        dad_hap = rand() < 0.5 ? dad_h1 : dad_h2\n        mom_hap = rand() < 0.5 ? mom_h1 : mom_h2\n        copyto!(@view(child_h1[segment]), @view(dad_hap[segment]))\n        copyto!(@view(child_h2[segment]), @view(mom_hap[segment]))\n    end\nend\n\nfunction write_plink(outfile::AbstractString, x1::AbstractMatrix, x2::AbstractMatrix)\n    n, p = size(x1)\n    x = SnpArray(outfile * \".bed\", n, p)\n    for j in 1:p, i in 1:n\n        c = x1[i, j] + x2[i, j]\n        if c == 0\n            x[i, j] = 0x00\n        elseif c == 1\n            x[i, j] = 0x02\n        elseif c == 2\n            x[i, j] = 0x03\n        else\n            error(\"matrix entries should be 0, 1, or 2 but was $c!\")\n        end\n    end\n    # create .bim file structure: https://www.cog-genomics.org/plink2/formats#bim\n    open(outfile * \".bim\", \"w\") do f\n        for i in 1:p\n            println(f, \"1\\tsnp$i\\t0\\t$(100i)\\t1\\t2\")\n        end\n    end\n    # create .fam file structure: https://www.cog-genomics.org/plink2/formats#fam\n    open(outfile * \".fam\", \"w\") do f\n        for i in 1:n\n            println(f, \"$i\\t1\\t0\\t0\\t1\\t-9\")\n        end\n    end\n    return nothing\nend\n\nfunction make_partition_mapfile(filename, p::Int)\n    map_cM = LinRange(0.0, Int(p / 10000), p)\n    open(filename, \"w\") do io\n        println(io, \"Chromosome\\tPosition(bp)\\tRate(cM/Mb)\\tMap(cM)\")\n        for i in 1:p\n            println(io, \"chr1\\t\", 100i, '\\t', 0.01rand(), '\\t', map_cM[i])\n        end\n    end\nend\n\nfunction make_rapid_mapfile(filename, p::Int)\n    map_cM = LinRange(0.0, Int(p / 10000), p)\n    open(filename, \"w\") do io\n        for i in 1:p\n            println(io, i, '\\t', map_cM[i])\n        end\n    end\nend\n\nfunction process_rapid_output(inputfile, outputfile)\n    writer = open(outputfile, \"w\")\n    df = readdlm(inputfile)\n    println(writer, \"CHR ID1 HID1 ID2 HID2 BP.start BP.end site.start site.end cM FAM1 FAM2\")\n    for r in eachrow(df)\n        chr, id1, id2, hap1, hap2, start_pos, end_pos, genetic_len, start_site, end_site = \n            Int(r[1]), Int(r[2]), Int(r[3]), Int(r[4]), Int(r[5]), Int(r[6]), Int(r[7]),\n            r[8], Int(r[9]), Int(r[10])\n        println(writer, chr, ' ', id1, ' ', hap1, ' ', id2, ' ', hap2, ' ', \n            start_pos, ' ', end_pos, ' ', start_site, ' ', end_site, ' ', \n            genetic_len, ' ', 1, ' ', 1)\n    end\n    close(writer)\nend\n\nfunction make_bgen_samplefile(filename, n)\n    open(filename, \"w\") do io\n        println(io, \"ID_1 ID_2 missing sex\")\n        println(io, \"0 0 0 D\")\n        for i in 1:n\n            println(io, \"$i 1 0 1\")\n        end\n    end \nend","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"make_bgen_samplefile (generic function with 1 method)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Simulate phased data with 2 populations, 49700 usually differentiated markers, and 300 unusually differentiated markers. Then simulate mating, which generates IBD segments. Finally, make unphased data from offspring haplotypes. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"# simulate phased genotypes\nRandom.seed!(2021)\noutfile = \"sim\"\nn = 2000\np = 50000\nh1, h2, populations, diff_markers = simulate_pop_structure(n, p)\n\n# simulate random mating to get IBD segments\noffsprings = 100\nx1, x2 = simulate_IBD(h1, h2, offsprings)\n\n# write phased genotypes to VCF format\nwrite_vcf(\"sim.phased.vcf.gz\", x1, x2)\n\n# write unphased genotypes to PLINK binary format\nwrite_plink(outfile, x1, x2)\n\n# save pop1/pop2 index and unually differentiated marker indices\nwritedlm(\"populations.txt\", populations)\nwritedlm(\"diff_markers.txt\", diff_markers)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"\u001b[32mSimulating genotypes...100%|████████████████████████████| Time: 0:00:01\u001b[39m\n\u001b[32mWriting VCF...100%|█████████████████████████████████████| Time: 0:00:24\u001b[39m","category":"page"},{"location":"man/shapeit_hmm/#Step-1:-Partitions","page":"SHAPEIT HMM knockoffs","title":"Step 1: Partitions","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"We need","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Map file (in particular the (cM) field will determine group resolution)\nPLINK's bim file\nQC file (all SNP names that pass QC)\noutput file name","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Since data is simulated, there are no genomic map file. Let us generate a fake one. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"# generate fake map file\nmake_partition_mapfile(\"sim.partition.map\", p)\n\n# also generate QC file that contains all SNPs and all samples\nsnpdata = SnpData(\"sim\")\nsnpIDs = snpdata.snp_info[!, :snpid]\nsampleIDs = Matrix(snpdata.person_info[!, 1:2])\nwritedlm(\"variants_qc.txt\", snpIDs)\nwritedlm(\"samples_qc.txt\", sampleIDs)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Now we run the partition script","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"plinkfile = \"sim\"\nmapfile = \"sim.partition.map\"\nqc_variants = \"variants_qc.txt\"\noutfile = \"sim.partition.txt\"\npartition(partition_exe, plinkfile, mapfile, qc_variants, outfile)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Mean group sizes: \n      res_7       res_6       res_5       res_4       res_3       res_2 \n    1.00000    67.75068   349.65035   694.44444  1351.35135  3333.33333 \n      res_1 \n10000.00000 \nPartitions written to: sim.partition.txt\n\n\n\n\n\nProcess(`\u001b[4mRscript\u001b[24m \u001b[4m--vanilla\u001b[24m \u001b[4m/scratch/users/bbchu/knockoffgwas/knockoffgwas/utils/partition.R\u001b[24m \u001b[4msim.partition.map\u001b[24m \u001b[4msim.bim\u001b[24m \u001b[4mvariants_qc.txt\u001b[24m \u001b[4msim.partition.txt\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/shapeit_hmm/#Step-2:-Generate-Knockoffs","page":"SHAPEIT HMM knockoffs","title":"Step 2: Generate Knockoffs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"First generate IBD segment files. We need to generate RaPID's required map file","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"make_rapid_mapfile(\"sim.rapid.map\", p)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Next we run the RaPID software","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"vcffile = \"sim.phased.vcf.gz\"\nmapfile = \"sim.rapid.map\"\noutfolder = \"rapid\"\nd = 3    # minimum IBD length in cM\nw = 3    # number of SNPs per window\nr = 10   # number of runs\ns = 2    # Minimum number of successes to consider a hit\n@time rapid(rapid_exe, vcffile, mapfile, d, outfolder, w, r, s)\n\n# unzip output file\nrun(pipeline(`gunzip -c ./rapid/results.max.gz`, stdout=\"./rapid/results.max\"))","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"┌ Info: RaPID command:\n│ `/scratch/users/bbchu/RaPID/RaPID_v.1.7 -i sim.phased.vcf.gz -g sim.rapid.map -d 3 -o rapid -w 3 -r 10 -s 2`\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:55\n┌ Info: Output directory: rapid\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:56\n\n\nCreate sub-samples..\nDone!\n 43.120301 seconds (3.04 k allocations: 159.828 KiB)\n\n\n\n\n\nProcess(`\u001b[4mgunzip\u001b[24m \u001b[4m-c\u001b[24m \u001b[4m./rapid/results.max.gz\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"countlines(\"./rapid/results.max\") # d = 3, w = 3, r = 10, s = 9","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"140","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Here we identified 140 IBD segments. Because we only simulated 100 offsprings, and all 2000 parents are unrelated, the \"IBD related families\" are small. When there are too many segments, one might have to prune the IBD segments so that the families are not too connected. See this issue for details. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"where the column format is: ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"<chr_name> <sample_id1> <sample_id2> <hap_id1> <hap_id2> <starting_pos_genomic> <ending_pos_genomic> <genetic_length> <starting_site> <ending_site>","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Then we need to do some postprocessing to this output, as described here. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"process_rapid_output(\"./rapid/results.max\", \"sim.snpknock.ibdmap\")","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"The output looks like follows. The last 5 columns (site.start site.end cM FAM1 FAM2) are not actually currently used. They need to be there (the file should have 12 fields in total), but it doesn't matter what values you put in them.","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":";head sim.snpknock.ibdmap","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"CHR ID1 HID1 ID2 HID2 BP.start BP.end site.start site.end cM FAM1 FAM2\n1 29 0 2053 0 100 5000000 0 49999 4.9999 1 1\n1 64 0 2003 1 100 4712700 0 47126 4.71259 1 1\n1 97 1 2051 0 100 5000000 0 49999 4.9999 1 1\n1 99 1 2017 0 967300 5000000 9672 49999 4.03278 1 1\n1 106 1 2024 1 100 4078800 0 40787 4.07868 1 1\n1 151 1 2009 0 100 5000000 0 49999 4.9999 1 1\n1 155 1 2069 0 100 5000000 0 49999 4.9999 1 1\n1 163 1 2073 1 100 3309000 0 33089 3.30887 1 1\n1 231 1 2080 1 1153000 5000000 11529 49999 3.84708 1 1","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Next convert VCF file to BGEN format (note: sample file must be saved separately)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"# convert VCF to BGEN format\noutfile = \"sim.bgen\"\nrun(`$qctools_exe -g $vcffile -og $outfile`)\n\n# then save sample file separately\nmake_bgen_samplefile(\"sim.sample\", n + offsprings)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Welcome to qctool\n(version: 2.0.7, revision )\n\n(C) 2009-2017 University of Oxford\n\nOpening genotype files                                      : [******************************] (1/1,0.0s,32.2/s)\n========================================================================\n\nInput SAMPLE file(s):         Output SAMPLE file:             \"(n/a)\".\nSample exclusion output file:   \"(n/a)\".\n\nInput GEN file(s):\n                                                    (not computed)  \"sim.phased.vcf.gz\"\n                                         (total 1 sources, number of snps not computed).\n                      Number of samples: 2100\nOutput GEN file(s):             \"sim.bgen\"\nOutput SNP position file(s):    (n/a)\nSample filter:                  .\n# of samples in input files:    2100.\n# of samples after filtering:   2100 (0 filtered out).\n\n========================================================================\n\nProcessing SNPs                                             :  (50000/?,169.4s,295.2/s)60.3s,275.2/s)\nTotal: 50000SNPs.\n========================================================================\n\nNumber of SNPs:\n                     -- in input file(s):                 (not computed).\n -- in output file(s):                50000\n\nNumber of samples in input file(s):   2100.\n\nOutput GEN files:                     (50000  snps)  \"sim.bgen\"\n                                      (total 50000 snps).\n========================================================================\n\n\nThank you for using qctool.","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Finally, generate HMM knockoffs by running the following code in the command line directly. You may need to adjust file directories and change parameters. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"bgenfile = \"sim\"\nsample_qc = \"samples_qc.txt\"\nvariant_qc = \"variants_qc.txt\"\nmapfile = \"sim.partition.map\"\npartfile = \"sim.partition.txt\"\nibdfile = \"sim.snpknock.ibdmap\"\nK = 10\ncluster_size_min = 1000 \ncluster_size_max = 10000 \nhmm_rho = 1\nhmm_lambda = 1e-3 \nwindows = 0\nn_threads = 1\nseed = 2021\ncompute_references = true\ngenerate_knockoffs = true\noutfile = \"sim.knockoffs\"\n\n@time snpknock2(snpknock2_exe, bgenfile, sample_qc, variant_qc, mapfile, partfile, ibdfile, \n    K, cluster_size_min, cluster_size_max, hmm_rho, hmm_lambda, windows, n_threads, \n    seed, compute_references, generate_knockoffs, outfile)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"\t+----------------------+\n\t|                      |\n\t|  SNPKNOCK2, v0.3     |\n\t|  July 21, 2020       |\n\t|  Matteo Sesia        |\n\t|                      |\n\t+----------------------+\n\nCopyright (C) 2020 Stanford University.\nDistributed under the GNU GPLv3 open source license.\n\nUse --help for more information.\n\nCommand line arguments:\n  --bgen sim\n  --keep samples_qc.txt\n  --extract variants_qc.txt\n  --map sim.partition.map\n  --part sim.partition.txt\n  --ibd sim.snpknock.ibdmap\n  --K 10\n  --cluster_size_min 1000\n  --cluster_size_max 10000\n  --hmm-rho 1\n  --hmm-lambda 0.001\n  --windows 0\n  --n_threads 1\n  --seed 2021\n  --compute-references\n  --generate-knockoffs\n  --out ./knockoffs/sim.knockoffs\n\nRequested operations:\n  --compute-references\n  --generate_knockoffs\n\n\n\n┌ Info: snpknock2 command:\n│ `/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2 --bgen sim --keep samples_qc.txt --extract variants_qc.txt --map sim.partition.map --part sim.partition.txt --ibd sim.snpknock.ibdmap --K 10 --cluster_size_min 1000 --cluster_size_max 10000 --hmm-rho 1 --hmm-lambda 0.001 --windows 0 --n_threads 1 --seed 2021 --compute-references --generate-knockoffs --out ./knockoffs/sim.knockoffs`\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:100\n┌ Info: Output directory: /home/users/bbchu/hmm/knockoffs\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:101\n\n\n\n--------------------------------------------------------------------------------\nLoading metadata\n--------------------------------------------------------------------------------\nLoading sample information from:\n  sim.sample\nLoading legend from:\n  sim.bim\nLoading partitions from:\n  sim.partition.txt\nLoading IBD segments from:\n  sim.snpknock.ibdmap\nLoaded 140 IBD segments.\n\nPrinting summary of 1 windows:\n     0: 0--50000\nSummary of metadata for chromosome 1:\n  number of samples (after | before filtering) : 2100 | 2100\n  number of SNPs (after | before filtering)    : 50000 | 50000\n  number of variant partitions                 : 7\n  size of genomic windows                      : whole-chromosome\n  number of IBD segments                       : 140\n\n\n--------------------------------------------------------------------------------\nKinship (using only haplotype data)\n--------------------------------------------------------------------------------\nReached 1\nChromosome 1 will be loaded from:\n  haplotype file            : sim.bgen\n  sample file               : sim.sample\n  legend file               : sim.bim\n  thinning factor           : 10\n  sample filter file        : samples_qc.txt\n  variant filter file       : variants_qc.txt\n  number of SNPs            : 5000\n  number of haplotypes      : 4200\n\nReading BGEN file using 1 thread:\n|....................................................................................................|\n|====================================================================================================|\nSolving 1 bifurcating K-means problems using 1 threads.\n\nKinship clusters written to:\n  ./knockoffs/sim.knockoffs_clust.txt\n  ./knockoffs/sim.knockoffs.sample\n\nAssigning references for the whole chromosome using 1 threads: \n|....................................................................................................|\n|\n\n\nBifurcating K-means\nSmallest allowed cluster size: 1000\n step\t cluster\t    size\t    left\t   right\taccepted\nBifurcating K-means completed after 0 steps.\nNumber of clusters: 1.\n\n\n\n====================================================================================================|\n\nReached 2\nIndividual global references written to:\n  ./knockoffs/sim.knockoffs_lref.txt\n\nIndividual local references written to:\n  ./knockoffs/sim.knockoffs_ref.txt\n\n\n--------------------------------------------------------------------------------\nKnockoffs for chromosome 1\n--------------------------------------------------------------------------------\nChromosome 1 will be loaded from:\n  haplotype file            : sim\n  haplotype file format     : bgen\n  sample file               : sim.sample\n  legend file               : sim.bim\n  map file                  : sim.partition.map\n  sample filter file        : samples_qc.txt\n  variant filter file       : variants_qc.txt\n  number of SNPs            : 50000\n  number of windows         : 1\n  number of haplotypes      : 4200\n\nLoading data for chromosome 1\nReading BGEN file using 1 thread:\n|....................................................................................................|\n|====================================================================================================|\n\nInitializing HMM with user-supplied hyperparameters: rho = 1, lambda = 0.001.\n\nHMM parameters written to:\n  ./knockoffs/sim.knockoffs_hmm.txt\n\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res0_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res0_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 50000 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 50000 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res0.bed\n  ./knockoffs/sim.knockoffs_res0.bim\n  ./knockoffs/sim.knockoffs_res0.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res0_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res1_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res1_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 738 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 738 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res1.bed\n  ./knockoffs/sim.knockoffs_res1.bim\n  ./knockoffs/sim.knockoffs_res1.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res1_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res2_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res2_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 143 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 143 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res2.bed\n  ./knockoffs/sim.knockoffs_res2.bim\n  ./knockoffs/sim.knockoffs_res2.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res2_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res3_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res3_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 72 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 72 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res3.bed\n  ./knockoffs/sim.knockoffs_res3.bim\n  ./knockoffs/sim.knockoffs_res3.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res3_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res4_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res4_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 37 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 37 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res4.bed\n  ./knockoffs/sim.knockoffs_res4.bim\n  ./knockoffs/sim.knockoffs_res4.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res4_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res5_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res5_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 15 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 15 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res5.bed\n  ./knockoffs/sim.knockoffs_res5.bim\n  ./knockoffs/sim.knockoffs_res5.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res5_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res6_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res6_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res6.bed\n  ./knockoffs/sim.knockoffs_res6.bim\n  ./knockoffs/sim.knockoffs_res6.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res6_anc.txt\n\nFinished.\n\n1484.517148 seconds (409.38 k allocations: 24.636 MiB, 0.01% compilation time)\n\n\n\n\n\nProcess(`\u001b[4m/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2\u001b[24m \u001b[4m--bgen\u001b[24m \u001b[4msim\u001b[24m \u001b[4m--keep\u001b[24m \u001b[4msamples_qc.txt\u001b[24m \u001b[4m--extract\u001b[24m \u001b[4mvariants_qc.txt\u001b[24m \u001b[4m--map\u001b[24m \u001b[4msim.partition.map\u001b[24m \u001b[4m--part\u001b[24m \u001b[4msim.partition.txt\u001b[24m \u001b[4m--ibd\u001b[24m \u001b[4msim.snpknock.ibdmap\u001b[24m \u001b[4m--K\u001b[24m \u001b[4m10\u001b[24m \u001b[4m--cluster_size_min\u001b[24m \u001b[4m1000\u001b[24m \u001b[4m--cluster_size_max\u001b[24m \u001b[4m10000\u001b[24m \u001b[4m--hmm-rho\u001b[24m \u001b[4m1\u001b[24m \u001b[4m--hmm-lambda\u001b[24m \u001b[4m0.001\u001b[24m \u001b[4m--windows\u001b[24m \u001b[4m0\u001b[24m \u001b[4m--n_threads\u001b[24m \u001b[4m1\u001b[24m \u001b[4m--seed\u001b[24m \u001b[4m2021\u001b[24m \u001b[4m--compute-references\u001b[24m \u001b[4m--generate-knockoffs\u001b[24m \u001b[4m--out\u001b[24m \u001b[4m./knockoffs/sim.knockoffs\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/shapeit_hmm/#Step-3:-Examine-Generated-Knockoffs","page":"SHAPEIT HMM knockoffs","title":"Step 3: Examine Generated Knockoffs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"The generated knockoffs are saved in binary PLINK format, we can import it using SnpArrays","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"x = SnpArray(\"knockoffs/sim.knockoffs_res0.bed\")","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"2100×100000 SnpArray:\n 0x03  0x03  0x02  0x02  0x03  0x03  …  0x02  0x02  0x02  0x03  0x03  0x03\n 0x02  0x02  0x03  0x03  0x00  0x02     0x02  0x02  0x03  0x03  0x02  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x00  0x03  0x02  0x02  0x02  0x02     0x03  0x02  0x03  0x03  0x03  0x03\n 0x03  0x03  0x00  0x00  0x03  0x02     0x02  0x02  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02  …  0x03  0x03  0x03  0x02  0x03  0x03\n 0x02  0x00  0x00  0x00  0x02  0x02     0x03  0x00  0x02  0x02  0x03  0x03\n 0x02  0x02  0x02  0x02  0x00  0x02     0x02  0x02  0x02  0x03  0x03  0x03\n 0x02  0x03  0x02  0x02  0x03  0x03     0x02  0x02  0x02  0x00  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x00     0x02  0x02  0x02  0x02  0x03  0x03\n 0x03  0x00  0x02  0x03  0x02  0x03  …  0x02  0x02  0x02  0x02  0x03  0x03\n 0x00  0x03  0x03  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x02  0x02  0x03  0x03  0x03  0x03     0x00  0x02  0x02  0x02  0x03  0x03\n    ⋮                             ⋮  ⋱           ⋮                    \n 0x00  0x00  0x03  0x03  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x00  0x02  0x03  0x03  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x00  0x02  0x03  0x03  0x02  0x02  …  0x00  0x00  0x02  0x00  0x03  0x03\n 0x00  0x00  0x02  0x02  0x03  0x03     0x02  0x02  0x03  0x03  0x03  0x03\n 0x00  0x02  0x03  0x03  0x02  0x02     0x00  0x00  0x02  0x02  0x03  0x03\n 0x00  0x00  0x02  0x02  0x03  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x02  0x03  0x02  0x00  0x03  0x02     0x03  0x03  0x00  0x00  0x03  0x03\n 0x03  0x02  0x03  0x00  0x03  0x03  …  0x02  0x02  0x02  0x02  0x03  0x03\n 0x03  0x03  0x02  0x02  0x03  0x03     0x02  0x02  0x03  0x03  0x02  0x02\n 0x03  0x00  0x00  0x00  0x02  0x02     0x02  0x02  0x03  0x03  0x03  0x03\n 0x00  0x03  0x03  0x02  0x02  0x02     0x00  0x00  0x00  0x00  0x03  0x03\n 0x02  0x00  0x00  0x00  0x02  0x02     0x02  0x02  0x02  0x02  0x03  0x03","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Notice there are 100k SNPs: the original 50k SNPs and their knockoffs. Reading the SNP names will tell us which are the originals:","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"snpid = SnpData(\"knockoffs/sim.knockoffs_res0\").snp_info.snpid","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"100000-element Vector{String}:\n \"snp1.k\"\n \"snp1\"\n \"snp2\"\n \"snp2.k\"\n \"snp3.k\"\n \"snp3\"\n \"snp4.k\"\n \"snp4\"\n \"snp5.k\"\n \"snp5\"\n \"snp6\"\n \"snp6.k\"\n \"snp7\"\n ⋮\n \"snp49995\"\n \"snp49995.k\"\n \"snp49996.k\"\n \"snp49996\"\n \"snp49997.k\"\n \"snp49997\"\n \"snp49998.k\"\n \"snp49998\"\n \"snp49999\"\n \"snp49999.k\"\n \"snp50000.k\"\n \"snp50000\"","category":"page"},{"location":"man/shapeit_hmm/#Step-4:-Model-selection-with-knockoffs","page":"SHAPEIT HMM knockoffs","title":"Step 4: Model selection with knockoffs","text":"","category":"section"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"Tutorial for this part coming soon! Basically, one constructs a SnpLinAlg, feed that into MendelIHT.jl, and calculate knockoff statistics afterwards using built-in functions like coefficient_diff and threshold.","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"SnpLinAlg performs compressed linear algebra (often faster than double precision BLAS)\nMendelIHT.jl is a very efficient implementation of the iterative hard thresholding algorithm. For model selection, IHT is known to be superior to standard LASSO, elastic net, and MCP solvers. ","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"xla = SnpLinAlg{Float64}(x, center=true, scale=true, impute=true)","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"2100×100000 SnpLinAlg{Float64}:\n  1.76602    1.68237   -0.311698  …   1.20757    0.0817861   0.12776\n  0.316766   0.246784   1.13646       1.20757  -12.1861      0.12776\n  0.316766   0.246784  -0.311698     -0.22433    0.0817861   0.12776\n -1.13249    1.68237   -0.311698      1.20757    0.0817861   0.12776\n  1.76602    1.68237   -1.75985       1.20757    0.0817861   0.12776\n  0.316766   0.246784  -0.311698  …  -0.22433    0.0817861   0.12776\n  0.316766  -1.1888    -1.75985      -0.22433    0.0817861   0.12776\n  0.316766   0.246784  -0.311698      1.20757    0.0817861   0.12776\n  0.316766   1.68237   -0.311698     -1.65623    0.0817861   0.12776\n  0.316766   0.246784  -0.311698     -0.22433    0.0817861   0.12776\n  1.76602   -1.1888    -0.311698  …  -0.22433    0.0817861   0.12776\n -1.13249    1.68237    1.13646      -0.22433    0.0817861   0.12776\n  0.316766   0.246784   1.13646      -0.22433    0.0817861   0.12776\n  ⋮                               ⋱                         \n -1.13249   -1.1888     1.13646       1.20757    0.0817861   0.12776\n -1.13249    0.246784   1.13646       1.20757    0.0817861   0.12776\n -1.13249    0.246784   1.13646   …  -1.65623    0.0817861   0.12776\n -1.13249   -1.1888    -0.311698      1.20757    0.0817861   0.12776\n -1.13249    0.246784   1.13646      -0.22433    0.0817861   0.12776\n -1.13249   -1.1888    -0.311698     -0.22433    0.0817861   0.12776\n  0.316766   1.68237   -0.311698     -1.65623    0.0817861   0.12776\n  1.76602    0.246784   1.13646   …  -0.22433    0.0817861   0.12776\n  1.76602    1.68237   -0.311698      1.20757  -12.1861     -7.7633\n  1.76602   -1.1888    -1.75985       1.20757    0.0817861   0.12776\n -1.13249    1.68237    1.13646      -1.65623    0.0817861   0.12776\n  0.316766  -1.1888    -1.75985      -0.22433    0.0817861   0.12776","category":"page"},{"location":"man/shapeit_hmm/","page":"SHAPEIT HMM knockoffs","title":"SHAPEIT HMM knockoffs","text":"","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#KnockoffScreen-knockoffs","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen knockoffs","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"warning: Warning\nKnockoffScreen Knockoffs are provided as experimental feature. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"This is a tutorial for generating KnockoffScreen knockoffs for genome-wide association studies. This kind of knockoffs is designed for sequence data that have a lot of rare variants. The methodology is described in the following papers","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"He, Zihuai, Linxi Liu, Chen Wang, Yann Le Guen, Justin Lee, Stephanie Gogarten, Fred Lu et al. \"Identification of putative causal loci in whole-genome sequencing data via knockoff statistics.\" Nature communications 12, no. 1 (2021): 1-18.","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"He, Zihuai, Yann Le Guen, Linxi Liu, Justin Lee, Shiyang Ma, Andrew C. Yang, Xiaoxia Liu et al. \"Genome-wide analysis of common and rare variants via multiple knockoffs at biobank scale, with an application to Alzheimer disease genetics.\" The American Journal of Human Genetics 108, no. 12 (2021): 2336-2353","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"In particular, we generate:","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"beginalign*\nhatX_j = hatbeta_0 + sum_k in B_jhatbeta_kX_k + sum_k in B_j k le j - 1hatgamma_ktildeX_k\nhatepsilon = permute(X_j - hatX_j)\ntildeX_j = hatX_j + hatepsilon\nendalign*","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"where B_j is a ball of variants near j and hatbeta_k hatgamma_k are estimated via least squares. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# first load packages needed for this tutorial\nusing SnpArrays\nusing Knockoffs\nusing Statistics\nusing Plots\nusing GLMNet\nusing Distributions\nusing Random\ngr(fmt=:png);","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#Step-0:-Prepare-example-data","page":"KnockoffScreen Knockoffs","title":"Step 0: Prepare example data","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"To illustrate we need example PLINK data, which are available in Knockoffs/data/mouse.imputed.(bed/bim/fam)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# Path to PLINK data\nmouse_path = joinpath(normpath(Knockoffs.datadir()), \"mouse.imputed\")","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"\"/Users/biona001/.julia/dev/Knockoffs/data/mouse.imputed\"","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#Step-1:-Generate-Knockoffs","page":"KnockoffScreen Knockoffs","title":"Step 1: Generate Knockoffs","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Knockoffs are made using the wrapper function full_knockoffscreen. An iterator format that streams knockoffs one by one is coming soon.","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"warning: Warning\nThe output of full_knockoffscreen is a dense Float64 matrix, which requires 8np bytes of RAM. Do not call it on large PLINK files. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"@time X̃ = full_knockoffscreen(mouse_path, windowsize=50)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"\u001b[32mGenerating knockoffs100%|███████████████████████████████| Time: 0:01:40\u001b[39m\n\n\n129.793232 seconds (74.18 M allocations: 34.660 GiB, 5.35% gc time, 23.10% compilation time)\n\n\n\n\n\n1940×10150 Matrix{Float64}:\n -0.158027  -0.15993  -0.397849  …   0.663515   0.664671   0.668258\n -0.157256  -0.15993   1.07455       0.663515   0.664671   0.666508\n  1.26416    1.2633    0.914503      0.663515   0.664671   0.669306\n -0.158079  -0.15993  -0.412851      0.663515   0.664671   0.667707\n  1.2641     1.2633    1.05954      -1.17537   -1.17217   -1.16703\n -0.15979   -0.15993  -0.412641  …   0.663515   0.664671   0.66629\n -0.159042  -0.15993   0.258318      0.663515   0.664671   0.669239\n -0.158219  -0.15993   1.0255        0.663515   0.664671   0.665875\n -0.156292  -0.15993   1.07454       0.663515   0.664671   0.667836\n  1.26493    1.2633    1.07325      -1.17537   -1.17217   -1.16801\n  1.26685    1.2633    0.258326  …  -3.01425   -3.00901   -3.00042\n -0.157256  -0.15993  -0.397863      0.663515   0.664671   0.669154\n  1.26332    1.2633    1.06682      -3.01425   -3.00901   -3.00326\n  ⋮                              ⋱                        \n  1.26412    1.2633    1.0803        0.663515   0.664671   0.669112\n  1.26589    1.2633    1.02462       0.663515   0.664671   0.669181\n -0.158027  -0.15993  -0.411348  …   0.663515   0.664671   0.667478\n -0.158219  -0.15993  -0.470753      0.663515   0.664671   0.665076\n  1.26493    1.2633    1.04758       0.663515   0.664671   0.666428\n -0.158306  -0.15993  -0.399157      0.663515   0.664671   0.669292\n  1.26589    1.2633    0.258319      0.663515   0.664671   0.669402\n -0.158023  -0.15993  -0.446907  …   0.663515   0.664671   0.666399\n -0.15899   -0.15993   0.257012      0.663515   0.664671   0.668106\n -0.159269  -0.15993   1.07455       0.663515   0.664671   0.666293\n -0.156292  -0.15993  -0.576227     -3.01425   -3.00901   -3.00041\n -1.58241   -1.58316  -1.88373       0.663515   0.664671   0.66915","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/#Step-2:-Examine-knockoff-statistics","page":"KnockoffScreen Knockoffs","title":"Step 2: Examine knockoff statistics","text":"","category":"section"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Lets check if the knockoffs \"make sense\". For example, we can compare SNP 1 and its knockoff (which are very similar):","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# import original genotypes into numeric matrix\nX = convert(Matrix{Float64}, SnpArray(mouse_path * \".bed\"), center=true, scale=true)\n\n# compare SNP 1 with its knockoff\n[X[:, 1] X̃[:, 1]]","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"1940×2 Matrix{Float64}:\n -0.159187  -0.157256\n -0.159187  -0.158219\n  1.26396    1.26388\n -0.159187  -0.158219\n  1.26396    1.26589\n -0.159187  -0.158219\n -0.159187  -0.159424\n -0.159187  -0.157256\n -0.159187  -0.158219\n  1.26396    1.2641\n  1.26396    1.26685\n -0.159187  -0.158986\n  1.26396    1.26589\n  ⋮         \n  1.26396    1.26589\n  1.26396    1.2641\n -0.159187  -0.160036\n -0.159187  -0.157256\n  1.26396    1.26589\n -0.159187  -0.159753\n  1.26396    1.26589\n -0.159187  -0.158219\n -0.159187  -0.159005\n -0.159187  -0.15899\n -0.159187  -0.158219\n -1.58233   -1.58241","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Lets also compare cor(X_i X_j) and cor(X_i tildeX_j). If knockoffs satisfy exchangability, their correlation should be very similar and form a diagonal line. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"# look at pairwise correlation (between first 200 snps)\nr1, r2 = Float64[], Float64[]\nfor i in 1:200, j in 1:i\n    push!(r1, cor(@view(X[:, i]), @view(X[:, j])))\n    push!(r2, cor(@view(X[:, i]), @view(X̃[:, j])))\nend\n\n# make plot\nscatter(r1, r2, xlabel = \"cor(Xi, Xj)\", ylabel=\"cor(Xi, X̃j)\", legend=false)\nPlots.abline!(1, 0, line=:dash)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"Plots distribution of cor(X_j tildeX_j) for all j. Ideally, we want cor(X_j tildeX_j) to be small in magnitude (i.e. X and tildeX is very different). Here the knockoffs are tightly correlated with the original genotypes, so they will likely have low power. ","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"r2 = Float64[]\nfor j in 1:size(X, 2)\n    push!(r1, cor(@view(X[:, j]), @view(X[:, j])))\n    push!(r2, cor(@view(X[:, j]), @view(X̃[:, j])))\nend\nhistogram(r2, legend=false, xlabel=\"cor(Xj, X̃j)\", ylabel=\"count\")","category":"page"},{"location":"man/knockoffscreen/knockoffscreen/","page":"KnockoffScreen Knockoffs","title":"KnockoffScreen Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/ghost_knockoffs/#Ghost-Knockoffs","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"","category":"section"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"This tutorial is for generating Ghost (summary statistics) Knockoffs for analyzing genome-wide association studies (GWAS). The methodology is described in ","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"He Z, Liu L, Belloy ME, Le Guen Y, Sossin A, Liu X, Qi X, Ma S, Gyawali PK, Wyss-Coray T, Tang H. GhostKnockoff inference empowers identification of putative causal variants in genome-wide association studies. Nature Communications. 2022 Nov 23;13(1):7209.","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"It is assumed we do not have access to individual level genotype data mathbfG. Rather, for each SNP, we have the z-scores Z_j with respect to a phenotype mathbfY from a GWAS. Then we sample the knockoff z-scores as ","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"beginaligned\nmathbftildeZ  mathbfG mathbfY sim N(mathbfPmathbfZ mathbfV)\nendaligned","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"beginaligned\nmathbfP = mathbfI - mathbfDmathbfSigma^-1 quad mathbfV = 2mathbfD - mathbfDmathbfSigma^-1mathbfD\nendaligned","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"where mathbfI is a p times p identity matrix, mathbfSigma is the correlation matrix among genotypes (characterizing linkage disequilibrium), and mathbfD = diag(s_1  s_p) is a diagonal matrix given by solving the following convex optimization problem","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"beginaligned\ntextminimize   sum_j  1 - s_j \ntextsubject to   2mathbfSigma - mathbfD succeq 0\n                    s_j ge 0\nendaligned","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"In summary, we need to","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Estimate the correlation matrix mathbfSigma, and \nSolve for the vector mathbfs.","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"These operations define mathbfP and mathbfV which can be used to sample the knockoffs mathbftildeZ. We describe step 1 in detail below. Step 2 can be accomplished via standard SDP or MVR solvers.","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"# load package needed for this tutorial\nusing Knockoffs\nusing VCFTools\nusing StatsBase\nusing LinearAlgebra\nusing SnpArrays\nusing Random","category":"page"},{"location":"man/ghost_knockoffs/#Estimate-correlation-matrix-\\mathbf{\\Sigma}","page":"Ghost Knockoffs","title":"Estimate correlation matrix mathbfSigma","text":"","category":"section"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Recall the only data we have is the score statistic mathbfZ for each SNP (i.e. we do not have individual level data mathbfG). To obtain an estimate of mathbfSigma, one way is to leverage a reference haplotype panel, which we denote by mathbfH. For instance, the 1000 genomes phase 3 panel is freely availble to the public and contains 2504 samples of diverse ancestry and ~50 million SNPs. Since mathbfH is very dense, each SNP in mathbfZ either exist in mathbfH, or is close to one that is typed in mathbfH. Over 90% of SNPs in the UK Biobank can be mapped to this panel. Thus, we can roughly estimate mathbfSigma. ","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Of course, population structure may skew the estimation. If the GWAS samples are rather homogeneous, one may want include only ancestrally similar samples in the reference panel. Of course, using denser and larger reference panels such as the HRC or TOPMed will also improve approximation, but those panels has restricted public access. ","category":"page"},{"location":"man/ghost_knockoffs/#Obtain-reference-panel","page":"Ghost Knockoffs","title":"Obtain reference panel","text":"","category":"section"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"First download the 1000 genomes reference panel in standard VCF format (warning: requires sim 94 GB):","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"download_1000genomes(outdir = \"/scratch/users/bbchu\")","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Import chr22 data","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"vcffile = \"/scratch/users/bbchu/1000genomes/chr22.1kg.phase3.v5a.vcf.gz\"\nH, H_sampleID, H_chr, H_pos, H_ids, H_ref, H_alt = convert_gt(Float32, \n    vcffile, save_snp_info=true, msg=\"importing\");","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"\u001b[32mimporting 100%|██████████████████████████████████████████| Time: 0:02:36\u001b[39m","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Here H is the reference panel, each row is a sample and each column is a SNP. The type of H is Union{Missing, Float32}, which potentially allows for missing data. To conserve memory, one could specify UInt8 instead of Float32. Of course, a good reference panel such as the 1000 genomes featured here will have no missing data. ","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"H","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"2504×424147 Matrix{Union{Missing, Float32}}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  1.0  0.0  0.0\n ⋮                        ⋮              ⋱  ⋮                        ⋮    \n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  1.0  1.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Here H_pos contains the position for all SNPs present on chromosome 22 on the reference panel. ","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"H_pos","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"424147-element Vector{Int64}:\n 16050115\n 16050213\n 16050607\n 16050739\n 16050783\n 16050840\n 16050847\n 16050922\n 16050984\n 16051075\n 16051249\n 16051453\n 16051722\n        ⋮\n 51239651\n 51239652\n 51239678\n 51239794\n 51240084\n 51240820\n 51241101\n 51241102\n 51241285\n 51241386\n 51244163\n 51244237","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"On the UK Biobank, 9359 / 9537 SNPs can be mapped to the 1000 genomes on chromosome 22. Note when this number is low, check if the human genome build for the reference panel (here build 37) matches with the GWAS data.","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"xdata = SnpData(\"/scratch/users/bbchu/ukb_fastPHASE/subset/ukb.10k.chr22\")\nxdata.snp_info[!, \"position\"] ∩ H_pos","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"9359-element Vector{Int64}:\n 16495833\n 16870425\n 16888577\n 16952830\n 17054795\n 17056415\n 17057597\n 17068748\n 17070109\n 17072347\n 17079911\n 17080190\n 17091201\n        ⋮\n 51162059\n 51162850\n 51163138\n 51163910\n 51165664\n 51171497\n 51173542\n 51174939\n 51175626\n 51183255\n 51185848\n 51193629","category":"page"},{"location":"man/ghost_knockoffs/#Simulated-Example","page":"Ghost Knockoffs","title":"Simulated Example","text":"","category":"section"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Now suppose we were given the z-scores for 10000 SNPs and their position. Note that a GWAS summary stats file may not contain z-scores, but rather effect sizes, odds-ratios, or p-values. To convert different measures to the standard z-score, I found this reference to be very useful.  ","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Random.seed!(2022)\np = 10000 # number of SNPs\nZ = randn(p) # simulated z-scores\nZ_pos = sort!(rand(16050000:51244000, p)) # simulated position for each SNP","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"10000-element Vector{Int64}:\n 16051161\n 16051964\n 16058006\n 16061965\n 16062797\n 16066970\n 16070158\n 16071335\n 16076125\n 16078197\n 16078220\n 16080831\n 16082209\n        ⋮\n 51197030\n 51203484\n 51209420\n 51211742\n 51211790\n 51215620\n 51222784\n 51227760\n 51227831\n 51231582\n 51235924\n 51238476","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Generating ghost knockoffs is accomplished via the ghost_knockoffs function. Here we employ the MVR construction (which tends to have the highest power) with a moderate window size:","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"Z̃ = ghost_knockoffs(Z, Z_pos, H_pos, H, :mvr, windowsize=500)","category":"page"},{"location":"man/ghost_knockoffs/","page":"Ghost Knockoffs","title":"Ghost Knockoffs","text":"\u001b[32mApproximating covariance by blocks... 100%|██████████████| Time: 0:00:32\u001b[39m\n\n\n\n\n\n10000-element Vector{Float64}:\n  0.5410315696729918\n -0.4246081059629637\n -0.04956798334091112\n -1.5764005812497706\n  0.5281884350544112\n -0.02190687576925561\n  0.5249259412485039\n  1.0111906565388558\n -1.4466613758239868\n  0.2581548620476279\n  0.09210845466626205\n -0.4317124835746688\n  1.0672703288267222\n  ⋮\n  0.45921376701255845\n  1.202714589200995\n  0.6726136982607442\n -0.22241142386162988\n -0.05067713325684163\n -0.6315313886344935\n -0.20778832692909632\n  0.12586124372837243\n  0.37169961989672984\n -0.1551860169036035\n  1.7102480919504381\n -0.03192549553328507","category":"page"},{"location":"man/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"Here is a list of available function calls. A detailed description can be found below. ","category":"page"},{"location":"man/api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"man/api/#Generating-knockoffs","page":"API","title":"Generating knockoffs","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"  fixed_knockoffs\n  modelX_gaussian_knockoffs\n  modelX_gaussian_group_knockoffs\n  modelX_gaussian_rep_group_knockoffs\n  approx_modelX_gaussian_knockoffs\n  hmm_knockoff\n  full_knockoffscreen\n  ghost_knockoffs\n  ipad\n  solve_s\n  solve_s_group\n  solve_s_graphical_group","category":"page"},{"location":"man/api/#Knockoffs.fixed_knockoffs","page":"API","title":"Knockoffs.fixed_knockoffs","text":"fixed_knockoffs(X::Matrix{T}; [method], [kwargs...])\n\nCreates fixed-X knockoffs. Internally, X will be automatically normalized before computing its knockoff. \n\nInputs\n\nX: A column-normalized n × p numeric matrix, each row is a sample, and   each column is covariate. We will internally normalized X if it is not. \nmethod: Can be one of the following\n:mvr: Minimum variance-based reconstructability knockoffs (alg 1 in ref 2)\n:maxent: Maximum entropy knockoffs (alg 2 in ref 2)\n:equi: Equi-distant knockoffs (eq 2.3 in ref 1), \n:sdp: SDP knockoffs (eq 2.4 in ref 1)\n:sdp_fast: SDP knockoffs via coordiate descent (alg 2.2 in ref 3)\nkwargs...: Possible optional inputs to method, see solve_MVR,    solve_max_entropy, and solve_sdp_fast\n\nOutput\n\nGaussianKnockoff: A struct containing the original (column-normalized) X   and its knockoff X̃, in addition to other variables (e.g. s)\n\nReference\n\n\"Controlling the false discovery rate via Knockoffs\" by Barber and Candes (2015).\n\"Powerful knockoffs via minimizing reconstructability\" by Spector, Asher, and Lucas Janson (2020)\n\"FANOK: Knockoffs in Linear Time\" by Askari et al. (2020).\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.modelX_gaussian_knockoffs","page":"API","title":"Knockoffs.modelX_gaussian_knockoffs","text":"modelX_gaussian_knockoffs(X::Matrix, method::Symbol; [m], [covariance_approximator], [kwargs...])\nmodelX_gaussian_knockoffs(X::Matrix, method::Symbol, μ::Vector, Σ::Matrix; [m], [kwargs...])\n\nCreates model-free multivariate normal knockoffs by sequentially sampling from  conditional multivariate normal distributions. The true mean μ and covariance Σ is estimated from data if not supplied. \n\nInputs\n\nX: A n × p numeric matrix, each row is a sample, and each column is covariate.\nmethod: Can be one of the following\n:mvr for minimum variance-based reconstructability knockoffs (alg 1 in ref 2)\n:maxent for maximum entropy knockoffs (alg 2 in ref 2)\n:equi for equi-distant knockoffs (eq 2.3 in ref 1), \n:sdp for SDP knockoffs (eq 2.4 in ref 1)\n:sdp_ccd for SDP knockoffs via coordiate descent (alg 2.2 in ref 3)\nμ: A p × 1 vector of column mean of X, defaults to column mean\nΣ: A p × p matrix of covariance of X, defaults to a shrinkage estimator   specified by covariance_approximator. \nm: Number of knockoff copies per variable to generate, defaults to 1. \ncovariance_approximator: A covariance estimator, defaults to LinearShrinkage(DiagonalUnequalVariance(), :lw)   which tends to give good empirical performance when p>n. See CovarianceEstimation.jl for more options.\nkwargs...: Possible optional inputs to solvers specified in method, see    solve_MVR, solve_max_entropy, and solve_sdp_fast\n\nReference:\n\n\"Panning for Gold: Model-X Knockoffs for High-dimensional Controlled  Variable Selection\" by Candes, Fan, Janson, and Lv (2018)\n\"Powerful knockoffs via minimizing reconstructability\" by Spector, Asher, and Lucas Janson (2020)\n\"FANOK: Knockoffs in Linear Time\" by Askari et al. (2020).\n\nCovariance Approximation:\n\nThe covariance is approximated by a linear shrinkage estimator using  Ledoit-Wolf with DiagonalUnequalVariance target,  which seems to perform well for p>n cases. We do not simply use cov(X) since isposdef(cov(X)) is typically false. For comparison of various estimators, see: https://mateuszbaran.github.io/CovarianceEstimation.jl/dev/man/msecomp/#msecomp\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.modelX_gaussian_group_knockoffs","page":"API","title":"Knockoffs.modelX_gaussian_group_knockoffs","text":"modelX_gaussian_group_knockoffs(X, method, groups, μ, Σ; [m], [nrep], [covariance_approximator])\nmodelX_gaussian_group_knockoffs(X, method, groups; [m], [nrep], [covariance_approximator])\n\nConstructs Gaussian model-X group knockoffs. If the covariance Σ and mean μ  are not specified, they will be estimated from data, i.e. we will make second-order group knockoffs. To incorporate group structure, the (true or estimated) covariance  matrix is block-diagonalized according to groups membership to solve a relaxed  optimization problem. See reference paper and Knockoffs.jl docs for more details. \n\nInputs\n\nX: A n × p design matrix. Each row is a sample, each column is a feature.\nmethod: Method for constructing knockoffs. Options include\n:maxent: (recommended) for fully general maximum entropy group knockoffs\n:mvr: for fully general minimum variance-based reconstructability (MVR) group    knockoffs\n:equi: for equi-correlated knockoffs. This is the methodology proposed in   Dai R, Barber R. The knockoff filter for FDR control in group-sparse and multitask regression.    International conference on machine learning 2016 Jun 11 (pp. 1851-1859). PMLR.\n:sdp: Fully general SDP group knockoffs based on coodinate descent\n:sdp_block: Fully general SDP group knockoffs where each block is solved exactly    using an interior point solver. \n:sdp_subopt: Chooses each block S_{i} = γ_i * Σ_{ii}. This slightly    generalizes the equi-correlated group knockoff idea proposed in Dai and Barber 2016.\ngroups: Vector of group membership\nμ: A length p vector storing the true column means of X\nΣ: A p × p covariance matrix for columns of X\nm: Number of knockoffs per variable, defaults to 1. \ncovariance_approximator: A covariance estimator, defaults to    LinearShrinkage(DiagonalUnequalVariance(), :lw). See CovarianceEstimation.jl    for more options.\nkwargs: Extra keyword arguments for solve_s_group\n\nHow to define groups\n\nThe exported functions hc_partition_groups and id_partition_groups can be used to build a group membership vector. \n\nA note on compute time\n\nThe computational complexity of group knockoffs scales quadratically with group size. Thus, very large groups (e.g. >100 members per group) dramatically slows down  parameter estimation. In such cases, one can consider running the routine  modelX_gaussian_rep_group_knockoffs which constructs group knockoffs by choosing top representatives from each group. \n\nReference\n\nDai & Barber 2016, The knockoff filter for FDR control in group-sparse and multitask regression\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.modelX_gaussian_rep_group_knockoffs","page":"API","title":"Knockoffs.modelX_gaussian_rep_group_knockoffs","text":"modelX_gaussian_rep_group_knockoffs(X, method, groups; [m], [covariance_approximator], [kwargs...])\nmodelX_gaussian_rep_group_knockoffs(X, method, groups, μ, Σ; [m], [kwargs...])\n\nConstructs group knockoffs by choosing representatives from each group and solving a smaller optimization problem based on the representatives only. Remaining knockoffs are generated based on a conditional independence assumption similar to a graphical model (details to be given later). The representatives are computed by choose_group_reps\n\nInputs\n\nX: A n × p design matrix. Each row is a sample, each column is a feature.\nmethod: Method for constructing knockoffs. Options are the same as    modelX_gaussian_group_knockoffs\ngroups: Vector of Int denoting group membership. groups[i] is the group    of X[:, i]\ncovariance_approximator: A covariance estimator, defaults to    LinearShrinkage(DiagonalUnequalVariance(), :lw). See CovarianceEstimation.jl    for more options.\nμ: A length p vector storing the true column means of X\nΣ: A p × p covariance matrix for columns of X\nrep_threshold: Value between 0 and 1 that controls the number of    representatives per group. Larger means more representatives (default 0.5)\nm: Number of knockoffs per variable, defaults to 1. \nkwargs: Extra keyword arguments for solve_s_group\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.approx_modelX_gaussian_knockoffs","page":"API","title":"Knockoffs.approx_modelX_gaussian_knockoffs","text":"approx_modelX_gaussian_knockoffs(X, method; [m=1], [windowsize = 500], [covariance_approximator], kwargs...)\napprox_modelX_gaussian_knockoffs(X, method, window_ranges; [m=1], [covariance_approximator], kwargs...)\n\nGenerates Gaussian knockoffs by approximating the covariance as a block diagonal matrix.  Each block contains windowsize consecutive features. One could alternatively  specify the window_ranges argument to construct blocks of different sizes. \n\nInputs\n\nX: A n × p numeric matrix or SnpArray. Each row is a sample, and each column is covariate.\nmethod: Can be one of the following\n:mvr for minimum variance-based reconstructability knockoffs (alg 1 in ref 2)\n:maxent for maximum entropy knockoffs (alg 2 in ref 2)\n:equi for equi-distant knockoffs (eq 2.3 in ref 1), \n:sdp for SDP knockoffs (eq 2.4 in ref 1)\n:sdp_fast for SDP knockoffs via coordiate descent (alg 2.2 in ref 3)\nm: Number of knockoff copies per variable to generate, defaults to 1. \nwindowsize: Number of covariates to be included in a block. Each block consists of   adjacent variables. The last block could contain less than windowsize variables. \nwindow_ranges: Vector of ranges for each window. e.g. [1:97, 98:200, 201:500]\ncovariance_approximator: A covariance estimator, defaults to LinearShrinkage(DiagonalUnequalVariance(), :lw).   See CovarianceEstimation.jl for more options.\nkwargs...: Possible optional inputs to solvers specified in method, see    solve_MVR, solve_max_entropy, and solve_sdp_fast\n\nMultithreading (todo)\n\nTo enable multiple threads, simply start Julia with >1 threads and this routine will run with all available threads. \n\nCovariance Approximation:\n\nThe covariance is approximated by a LinearShrinkageEstimator using  Ledoit-Wolf shrinkage with DiagonalUnequalVariance target,  which seems to perform well for p>n cases. We do not simply use cov(X) since isposdef(cov(X)) is typically false. For comparison of different estimators, see: https://mateuszbaran.github.io/CovarianceEstimation.jl/dev/man/msecomp/#msecomp\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.hmm_knockoff","page":"API","title":"Knockoffs.hmm_knockoff","text":"hmm_knockoff(plinkname; [datadir], [plink_outfile], [fastphase_outfile], [outdir], [verbose], args...)\n\nGenerates HMM knockoffs from binary PLINK formatted files. This is done by first running fastPHASE, then running Algorithm 2 of \"Gene hunting with hidden Markov model knockoffs\" by Sesia, Sabatti, and Candes\n\nInput\n\nplinkname: Binary PLINK file names without the .bed/.bim/.fam suffix. \n\nOptional arguments\n\ndatadir: Full path to the PLINK and fastPHASE files (default = current directory)\nplink_outfile: Output PLINK format name\nfastphase_outfile: The output file name from fastPHASE's alpha, theta, r files\nargs...: Any parameter that accepted in fastPHASE.fastphase_estim_param()\n\nOutput\n\nplink_outfile.bed: n × p knockoff genotypes\nplink_outfile.bim: SNP mapping file. Knockoff have SNP names ending in \".k\"\nplink_outfile.fam: Sample mapping file, this is a copy of the original plinkname.fam file\nfastphase_outfile_rhat.txt: averaged r hat file from fastPHASE\nfastphase_outfile_alphahat.txt: averaged alpha hat file from fastPHASE\nfastphase_outfile_thetahat.txt: averaged theta hat file from fastPHASE\n\n\n\n\n\nhmm_knockoff(snpdata::SnpData, r::AbstractVecOrMat, θ::AbstractMatrix, α::AbstractMatrix)\n\nGenerates knockoff of snpdata with loaded r, θ, α\n\nInput\n\nSnpData: A SnpData object from SnpArrays\nr: The r vector estimated by fastPHASE\nθ: The θ matrix estimated by fastPHASE\nα: The α matrix estimated by fastPHASE\n\nOptional Inputs\n\noutdir: Output directory for generated knockoffs\nplink_outfile: Output file name for knockoff genotypes\nestimate_δ: If true, will estimate pseudo-FDR by computing a δ value    for each SNP via likelihood ratio bound\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.full_knockoffscreen","page":"API","title":"Knockoffs.full_knockoffscreen","text":"full_knockoffscreen(x::SnpArray; windowsize::Int=100)\n\nGenerates knockoffs X̃ⱼ by on regressing Xⱼ on SNPs knockoffs within a sliding window of width windowsize. \n\nInputs\n\nx: A SnpArray or String for the path of the PLINK .bed file\nwindowsize: Int specifying window width. Defaults to 100\n\nOutputs\n\nX̃: A n × p dense matrix of Float64, each row is a sample.\n\nReferences\n\nHe, Zihuai, Linxi Liu, Chen Wang, Yann Le Guen, Justin Lee, Stephanie Gogarten, Fred Lu et al. \"Identification of putative causal loci in whole-genome sequencing data via knockoff statistics.\" Nature communications 12, no. 1 (2021): 1-18.\nHe, Zihuai, Yann Le Guen, Linxi Liu, Justin Lee, Shiyang Ma, Andrew C. Yang, Xiaoxia Liu et al. \"Genome-wide analysis of common and rare variants via multiple knockoffs at biobank scale, with an application to Alzheimer disease genetics.\" The American Journal of Human Genetics 108, no. 12 (2021): 2336-2353.\n\nTODO\n\nUse ElasticArrays.jl to avoid reallocating design matrix in each loop\nWrite iterator interface to avoid allocating and storing all knockoffs at once\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.ghost_knockoffs","page":"API","title":"Knockoffs.ghost_knockoffs","text":"ghost_knockoffs(Zscores, D, Σinv; [m=1])\nghost_knockoffs(Zscores, Z_pos, H_pos, H, method; [windowsize], [covariance_approximator], [kwargs])\n\nGenerate Ghost knockoffs given a list of z-scores (GWAS summary statistic). \n\nInputs\n\nZscores: List of z-score statistics\nD: Matrix obtained from solving the knockoff problem satisfying    (m+1)/m*Σ - D ⪰ 0\nΣinv: Inverse of the covariance matrix\nZ_pos: A sorted list of SNP position for each SNP in Zscores\nH_pos: A sorted list of SNP position in the reference panel H\nH: A haplotype reference panel. Each row is a sample and each column is a variant.\nmethod: Can be any of the method in approx_modelX_gaussian_knockoffs\nwindowsize: Number of covariates to be included in a block. Each block consists of   adjacent variables. The last block could contain less than windowsize variables. \ncovariance_approximator: A covariance estimator, defaults to    LinearShrinkage(DiagonalUnequalVariance(), :lw). See    CovarianceEstimation.jl for more options.\nkwargs...: Possible optional inputs to solvers specified in method, see    solve_MVR, solve_max_entropy, and solve_sdp_fast\n\noptional inputs\n\nm: Number of knockoffs\n\nReference\n\nHe, Z., Liu, L., Belloy, M. E., Le Guen, Y., Sossin, A., Liu, X., ... & Ionita-Laza, I. (2021).  Summary statistics knockoff inference empowers identification of putative causal variants in  genome-wide association studies. \n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.ipad","page":"API","title":"Knockoffs.ipad","text":"ipad(X::Matrix; [r_method], [m])\n\nGenerates knockoffs based on intertwined probabilitistic factors decoupling (IPAD). This assumes that X can be factored as X = FΛ' + E where F is a n × r random matrix of latent factors, Λ are factor loadings, and E are residual errors. When this assumption is met, FDR can be controlled with no power loss when applying the knockoff procedure. Internally, we need to compute an eigenfactorization for a n × n matrix. This is often faster than standard model-X knockoffs which requires solving p-dimensional convex optimization problem.\n\nInputs\n\nX: A n × p numeric matrix, each row is a sample, and each column is covariate.\nr_method: Method used for estimating r, the number of latent factors.    Choices include :er (default), :gr, or :ve\nm: Number of (simultaneous) knockoffs per variable to generate, default m=1\n\nReferences\n\nFan, Y., Lv, J., Sharifvaghefi, M. and Uematsu, Y., 2020. IPAD: stable interpretable forecasting with knockoffs inference. Journal of the American Statistical Association, 115(532), pp.1822-1834.\nBai, J., 2003. Inferential theory for factor models of large dimensions. Econometrica, 71(1), pp.135-171.\nAhn, S.C. and Horenstein, A.R., 2013. Eigenvalue ratio test for the number of factors. Econometrica, 81(3), pp.1203-1227.\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.solve_s","page":"API","title":"Knockoffs.solve_s","text":"solve_s(Σ::Symmetric, method::Symbol; m=1, kwargs...)\n\nSolves the vector s for generating knockoffs. Σ can be a general  covariance matrix but it must be wrapped in the Symmetric keyword. \n\nInputs\n\nΣ: A covariance matrix (one must wrap Symmetric(Σ) explicitly)\nmethod: Can be one of the following\n:mvr for minimum variance-based reconstructability knockoffs (alg 1 in ref 2)\n:maxent for maximum entropy knockoffs (alg 2 in ref 2)\n:equi for equi-distant knockoffs (eq 2.3 in ref 1), \n:sdp for SDP knockoffs (eq 2.4 in ref 1)\n:sdp_ccd fast SDP knockoffs via coordiate descent (alg 2.2 in ref 3)\nm: Number of knockoffs per variable, defaults to 1. \nkwargs: Extra arguments available for specific methods. For example, to use    less stringent convergence tolerance for MVR knockoffs, specify tol = 0.001.   For a list of available options, see solve_MVR,   solve_max_entropy, solve_sdp_ccd, solve_sdp, or   solve_equi\n\nReference\n\n\"Controlling the false discovery rate via Knockoffs\" by Barber and Candes (2015).\n\"Powerful knockoffs via minimizing reconstructability\" by Spector, Asher, and Lucas Janson (2020)\n\"FANOK: Knockoffs in Linear Time\" by Askari et al. (2020).\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.solve_s_group","page":"API","title":"Knockoffs.solve_s_group","text":"solve_s_group(Σ, groups, method; [m=1], kwargs...)\n\nSolves the group knockoff problem, returns block diagonal matrix S satisfying (m+1)/m*Σ - S ⪰ 0 where m is number of knockoffs per feature. \n\nInputs\n\nΣ: A general covariance matrix wrapped by Symmetric keyword\ngroups: Vector of group membership, does not need to be contiguous\nmethod: Method for constructing knockoffs. Options include\n:maxent: (recommended) for fully general maximum entropy group knockoffs\n:mvr: for fully general minimum variance-based reconstructability (MVR) group    knockoffs\n:equi: for equi-correlated knockoffs. This is the methodology proposed in   Dai R, Barber R. The knockoff filter for FDR control in group-sparse and multitask regression.    International conference on machine learning 2016 Jun 11 (pp. 1851-1859). PMLR.\n:sdp: Fully general SDP group knockoffs based on coodinate descent\n:sdp_subopt: Chooses each block S_{i} = γ_i * Σ_{ii}. This slightly    generalizes the equi-correlated group knockoff idea proposed in Dai and Barber 2016.\n:sdp_block: Fully general SDP group knockoffs where each block is solved exactly    using an interior point solver. \nm: Number of knockoffs per variable, defaults to 1. \nkwargs: Extra arguments available for specific methods. For example, to use    less stringent convergence tolerance, specify tol = 0.001.   For a list of available options, see solve_group_mvr_hybrid,   solve_group_max_entropy_hybrid, solve_group_sdp_hybrid, or   solve_group_equi\n\nOutput\n\nS: A matrix solved so that (m+1)/m*Σ - S ⪰ 0 and S ⪰ 0\nγ: A vector that is only non-empty for equi and suboptimal knockoff constructions.    They correspond to values of γ where S_{gg} = γΣ_{gg}. So for equi, the   vector is length 1. For SDP, the vector has length equal to number of groups\nobj: Final SDP/MVR/ME objective value given S. Equi-correlated group knockoffs   and singleton (non-grouped knockoffs) returns 0 because they either no objective    value or it is not necessary to evaluate the objectives\n\nWarning\n\nThis function potentially permutes the columns/rows of Σ, and puts them back at the end. Thus one should NOT call solve_s_group on the same Σ simultaneously, e.g. in a multithreaded for loop. Permutation does not happen when groups are contiguous. \n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.solve_s_graphical_group","page":"API","title":"Knockoffs.solve_s_graphical_group","text":"solve_s_graphical_group(Σ::Symmetric, groups::Vector{Int}, group_reps::Vector{Int},\nmethod; [m], [verbose])\n\nSolves the group knockoff problem but the convex optimization problem only runs on the representatives. The non-representative variables are assumed to be  independent by groups when conditioning on the reprensetatives. \n\nInputs\n\nΣ: Symmetric p × p covariance matrix\ngroups: p dimensional vector of group membership\ngroup_reps: Indices for the representatives. \nmethod: Method for solving group knockoff problem\nm: Number of knockoffs to generate per feature\nverbose: Whether to print informative intermediate results\nkwargs...: extra arguments for solve_s_group\n\nOutputs\n\nS: Matrix obtained from solving the optimization problem on the representatives.\nD: A p × p (dense) matrix corresponding to the S matrix for both the   representative and non-representative variables. Knockoff sampling should    use this matrix. If the graphical conditional independent assumption is    satisfied exactly, this matrix should be sparse, but it is always never sparse   unless we use cond_indep_corr to force the covariance matrix to satisify it. \nobj: Objective value for solving the optimization problem on the representatives. \n\n\n\n\n\n","category":"function"},{"location":"man/api/#Regular-knockoffs-Solvers","page":"API","title":"Regular knockoffs Solvers","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"  solve_equi\n  solve_max_entropy\n  solve_MVR\n  solve_sdp_ccd\n  solve_SDP","category":"page"},{"location":"man/api/#Knockoffs.solve_equi","page":"API","title":"Knockoffs.solve_equi","text":"solve_equi(Σ::AbstractMatrix)\n\nSolves the equicorrelated problem for fixed-X and model-X knockoffs given  correlation matrix Σ. Users should call solve_s instead of this function. \n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.solve_max_entropy","page":"API","title":"Knockoffs.solve_max_entropy","text":"solve_max_entropy(Σ::AbstractMatrix)\n\nSolves the maximum entropy knockoff problem for fixed-X and model-X knockoffs given correlation matrix Σ. Users should call solve_s instead of this function. \n\nReference\n\nAlgorithm 2.2 from Powerful Knockoffs via Minimizing Reconstructability: https://arxiv.org/pdf/2011.14625.pdf\n\nNote\n\nThere is a typo in algorithm for computing ME knockoffs in \"Powerful knockoffs via minimizing reconstructability\" by Spector, Asher, and Lucas Janson (2020). In the supplemental section, equation 59, they needed to evaluate  c_m = D^t_{-j,j}D^{-1}_{-j,-j}D_{-j,j}. They claimed the FANOK paper  (\"FANOK: KNOCKOFFS IN LINEAR TIME\" by Askari et al. (2020)) implies that c_m = ||v_m||^2 where Lv_m = u. However, according to section A.1.2 of the FANOK paper, it seems like the actual update should be D^t_{-j,j}D^{-1}_{-j,-j}D_{-j,j} = ζ*||c_m||^2 / (ζ + ||c_m||^2)  where ζ = 2Σ_{jj} - s_j.\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.solve_MVR","page":"API","title":"Knockoffs.solve_MVR","text":"solve_MVR(Σ::AbstractMatrix)\n\nSolves the minimum variance-based reconstructability problem for fixed-X and model-X knockoffs given correlation matrix Σ. Users should call solve_s  instead of this function. \n\nSee algorithm 1 of \"Powerful knockoffs via minimizing  reconstructability\" by Spector, Asher, and Lucas Janson (2020) https://arxiv.org/pdf/2011.14625.pdf\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.solve_sdp_ccd","page":"API","title":"Knockoffs.solve_sdp_ccd","text":"solve_sdp_ccd(Σ::AbstractMatrix)\n\nSolves the SDP problem for fixed-X and model-X knockoffs using coordinate descent,  given correlation matrix Σ. Users should call solve_s instead of this function. \n\nReference\n\nAlgorithm 2.2 from \"FANOK: Knockoffs in Linear Time\" by Askari et al. (2020).\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.solve_SDP","page":"API","title":"Knockoffs.solve_SDP","text":"solve_SDP(Σ::AbstractMatrix)\n\nSolves the SDP problem for fixed-X and model-X knockoffs given correlation matrix Σ.  Users should call solve_s instead of this function. \n\nThe optimization problem is stated in equation 3.13 of https://arxiv.org/pdf/1610.02351.pdf\n\nArguments\n\nΣ: A correlation matrix (diagonals all equal to 1)\nm: Number of knockoffs to generate, defaults to 1\noptm: SDP solver. Defaults to Hypatia.Optimizer(verbose=false). This can   be any solver that supports the JuMP interface. For example, use    SDPT3.Optimizer in SDPT3.jl package (which is a MATLAB dependency)   for the best performance. \n\n\n\n\n\n","category":"function"},{"location":"man/api/#Group-knockoffs-Solvers","page":"API","title":"Group knockoffs Solvers","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"  solve_group_equi\n  solve_group_max_entropy_hybrid\n  solve_group_mvr_hybrid\n  solve_group_sdp_hybrid","category":"page"},{"location":"man/api/#Knockoffs.solve_group_equi","page":"API","title":"Knockoffs.solve_group_equi","text":"Solves the equi-correlated group knockoff problem. Here Σ is the true covariance matrix (scaled so that it has 1 on its diagonal) and Σblocks is the block-diagonal covariance matrix where each  block corresponds to groups.\n\nDetails can be found in Dai & Barber 2016, The knockoff filter for FDR control in group-sparse and multitask regression\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.solve_group_max_entropy_hybrid","page":"API","title":"Knockoffs.solve_group_max_entropy_hybrid","text":"solve_group_max_entropy_hybrid(Σ, groups, [outer_iter=100], [inner_pca_iter=1],\n    [inner_ccd_iter=1], [tol=0.0001], [ϵ=1e-6], [m=1], [robust=false], [verbose=false])\n\nSolves the group-knockoff optimization problem based on Maximum Entropy objective. Users should call solve_s_group instead of this function. \n\nInputs\n\nΣ: Correlation matrix\ngroups: Group membership vector \n\nOptional inputs\n\nouter_iter: Maximum number of outer iterations. Each outer iteration will   perform inner_pca_iter PCA updates inner_ccd_iter full optimization    updates (default = 100).\ninner_pca_iter: Number of full PCA updates before changing to fully   general coordinate descent updates (default = 1)\ninner_ccd_iter: Number of full general coordinate descent updates before changing   to PCA updates (default = 1)\ntol: convergence tolerance. Algorithm converges when    abs((obj_new-obj_old)/obj_old) < tol OR when changes in S matrix falls    below 1e-4\nϵ: tolerance added to the lower and upper bound, prevents numerical issues   (default = 1e-6)\nm: Number of knockoffs per variable (defaults 1)\nrobust: whether to use \"robust\" Cholesky updates. If robust=true, alg will   be ~10x slower, only use this if robust=false causes cholesky updates to fail.   (default false)\nverbose: Whether to print intermediate results (default false)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.solve_group_mvr_hybrid","page":"API","title":"Knockoffs.solve_group_mvr_hybrid","text":"solve_group_mvr_hybrid(Σ, groups, [outer_iter=100], [inner_pca_iter=1],\n    [inner_ccd_iter=1], [tol=0.0001], [ϵ=1e-6], [m=1], [robust=false], [verbose=false])\n\nSolves the group-knockoff optimization problem based on MVR objective. Users should call solve_s_group instead of this function. \n\nInputs\n\nΣ: Correlation matrix\ngroups: Group membership vector \n\nOptional inputs\n\nouter_iter: Maximum number of outer iterations. Each outer iteration will   perform inner_pca_iter PCA updates inner_ccd_iter full optimization    updates (default = 100).\ninner_pca_iter: Number of full PCA updates before changing to fully   general coordinate descent updates (default = 1)\ninner_ccd_iter: Number of full general coordinate descent updates before changing   to PCA updates (default = 1)\ntol: convergence tolerance. Algorithm converges when    abs((obj_new-obj_old)/obj_old) < tol OR when changes in S matrix falls    below 1e-4\nϵ: tolerance added to the lower and upper bound, prevents numerical issues   (default = 1e-6)\nm: Number of knockoffs per variable (defaults 1)\nrobust: whether to use \"robust\" Cholesky updates. If robust=true, alg will   be ~10x slower, only use this if robust=false causes cholesky updates to fail.   (default false)\nverbose: Whether to print intermediate results (default false)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.solve_group_sdp_hybrid","page":"API","title":"Knockoffs.solve_group_sdp_hybrid","text":"solve_group_sdp_hybrid(Σ, groups, [outer_iter=100], [inner_pca_iter=1],\n    [inner_ccd_iter=1], [tol=0.0001], [ϵ=1e-6], [m=1], [robust=false], [verbose=false])\n\nSolves the group-knockoff optimization problem based on SDP objective. Users should call solve_s_group instead of this function. \n\nInputs\n\nΣ: Correlation matrix\ngroups: Group membership vector \n\nOptional inputs\n\nouter_iter: Maximum number of outer iterations. Each outer iteration will   perform inner_pca_iter PCA updates inner_ccd_iter full optimization    updates (default = 100).\ninner_pca_iter: Number of full PCA updates before changing to fully   general coordinate descent updates (default = 1)\ninner_ccd_iter: Number of full general coordinate descent updates before changing   to PCA updates (default = 1)\ntol: convergence tolerance. Algorithm converges when    abs((obj_new-obj_old)/obj_old) < tol OR when changes in S matrix falls    below 1e-4\nϵ: tolerance added to the lower and upper bound, prevents numerical issues   (default = 1e-6)\nm: Number of knockoffs per variable (defaults 1)\nrobust: whether to use \"robust\" Cholesky updates. If robust=true, alg will   be ~10x slower, only use this if robust=false causes cholesky updates to fail.   (default false)\nverbose: Whether to print intermediate results (default false)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Other-functions","page":"API","title":"Other functions","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"  threshold\n  MK_statistics\n  hc_partition_groups\n  id_partition_groups\n  choose_group_reps\n  fit_lasso\n  fit_marginal\n  simulate_AR1\n  simulate_ER\n  simulate_block_covariance\n  normalize_col!\n  rapid","category":"page"},{"location":"man/api/#Knockoffs.threshold","page":"API","title":"Knockoffs.threshold","text":"threshold(w::AbstractVector, q::Number, [method=:knockoff], [m::Int=1])\n\nChooses a threshold τ > 0 by choosing τ to be one of the following τ = min{ t > 0 : {#j: w[j] ≤ -t} / {#j: w[j] ≥ t} ≤ q }        (method=:knockoff) τ = min{ t > 0 : (1 + {#j: w[j] ≤ -t}) / {#j: w[j] ≥ t} ≤ q }  (method=:knockoff)\n\nInputs\n\nw: Vector of feature important statistics\nq: target FDR (between 0 and 1)\nmethod: either :knockoff or :knockoff_plus (default)\n\nReference:\n\nEquation 3.10 (method=:knockoff) or 3.11 (method=:knockoff_plus) of  \"Panning for Gold: Model-X Knockoffs for High-dimensional Controlled Variable Selection\" by Candes, Fan, Janson, and Lv (2018)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.MK_statistics","page":"API","title":"Knockoffs.MK_statistics","text":"MK_statistics(T0::Vector, Tk::Vector{Vector}; filter_method)\n\nComputes the multiple knockoff statistics kappa, tau, and W. \n\nInputs\n\nT0: p-vector of importance score for original variables\nTk: Vector storing T1, ..., Tm, where Ti is importance scores for    the ith knockoff copy\nfilter_method: Either Statistics.median (default) or max (original    function used in 2019 Gimenez and Zou)\n\noutput\n\nκ: Index of the most significant feature (κ[i] = 0 if original feature most    important, otherwise κ[i] = k if the kth knockoff is most important)\nτ: τ[i] stores the most significant statistic among original and knockoff   variables minus filter_method() applied to the remaining statistics. \nW: coefficient difference statistic W[i] = abs(T0[i]) - abs(Tk[i])     \n\n\n\n\n\nMK_statistics(T0::Vector, Tk::Vector)\n\nCompute regular knockoff statistics tau and W. \n\nInputs\n\nT0: p-vector of importance score for original variables\nTk: p-vector of importance score for knockoff variables\n\noutput\n\nW: coefficient difference statistic W[i] = abs(T0[i]) - abs(Tk[i])\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.hc_partition_groups","page":"API","title":"Knockoffs.hc_partition_groups","text":"hc_partition_groups(X::AbstractMatrix; [cutoff], [min_clusters], [force_contiguous])\nhc_partition_groups(Σ::Symmetric; [cutoff], [min_clusters], [force_contiguous])\n\nComputes a group partition based on individual level data X or correlation  matrix Σ using hierarchical clustering with specified linkage. \n\nInputs\n\nX: n × p data matrix. Each row is a sample\nΣ: p × p correlation matrix. Must be wrapped in the Symmetric argument,   otherwise we will treat it as individual level data\ncutoff: Height value for which the clustering result is cut, between 0 and 1   (default 0.5). This ensures that no variables between 2 groups have correlation   greater than cutoff. 1 recovers ungrouped structure, 0 corresponds to    everything in a single group. \nmin_clusters: The desired number of clusters. \nlinkage: cluster linkage function to use (when force_contiguous=true,    linkage must be :single). linkage defines how the    distances between the data points are aggregated into the distances between    the clusters. Naturally, it affects what clusters are merged on each    iteration. The valid choices are:\n:single (default): use the minimum distance between any of the cluster members\n:average: use the mean distance between any of the cluster members\n:complete: use the maximum distance between any of the members\n:ward: the distance is the increase of the average squared distance of a   point to its cluster centroid after merging the two clusters\n:ward_presquared: same as :ward, but assumes that the distances in d    are already squared.\nrep_method: Method for selecting representatives for each group. Options are   :id (tends to select roughly independent variables) or :rss (tends to   select more correlated variables)\n\nIf force_contiguous = false and both min_clusters and cutoff are specified,  it is guaranteed that the number of clusters is not less than min_clusters and their height is not above cutoff. If force_contiguous = true, min_clusters keyword is ignored. \n\nOutputs\n\ngroups: Length p vector of group membership for each variable\ngroup_reps: Columns of X selected as representatives. Each group have at    most nrep representatives. These are typically used to construct smaller   group knockoff for extremely large groups\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.id_partition_groups","page":"API","title":"Knockoffs.id_partition_groups","text":"id_partition_groups(X::AbstractMatrix; [rss_target], [force_contiguous])\nid_partition_groups(Σ::Symmetric; [rss_target], [force_contiguous])\n\nCompute group members based on interpolative decompositions. An initial pass  first selects the most representative features such that regressing each  non-represented feature on the selected will have residual less than rss_target. The selected features are then defined as group centers and the remaining  features are assigned to groups\n\nInputs\n\nG: Either individual level data X or a correlation matrix Σ. If one   inputs Σ, it must be wrapped in the Symmetric argument, otherwise   we will treat it as individual level data\nrss_target: Target residual level (greater than 0) for the first pass, smaller   means more groups\nforce_contiguous: Whether groups are forced to be contiguous. If true,   variants are assigned its left or right center, whichever   has the largest correlation with it without breaking contiguity.\n\nOutputs\n\ngroups: Length p vector of group membership for each variable\n\nNote: interpolative decomposition is a stochastic algorithm. Set a seed to guarantee reproducible results. \n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.choose_group_reps","page":"API","title":"Knockoffs.choose_group_reps","text":"choose_group_reps(Σ::Symmetric, groups::AbstractVector; threshold=0.5)\nchoose_group_reps(X::AbstractMatrix, groups::AbstractVector; threshold=0.5)\n\nChooses group representatives. If R is the set of selected variables within a group and O is the set of variables outside the group, then we keep adding variables to R until the proportion of variance explained by R divided by the proportion of variance explained by R and O exceeds threshold. \n\nInputs\n\nFirst argument: Either individual level data X or the correlation matrix Σ.   If one inputs Σ, it must be wrapped in the Symmetric argument.\ngroups: Vector of group membership. \nthreshold: Value between 0 and 1 that controls the number of    representatives per group. Larger means more representatives (default 0.5)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.fit_lasso","page":"API","title":"Knockoffs.fit_lasso","text":"fit_lasso(y, X, method=:maxent, ...)\nfit_lasso(y, X, μ, Σ, method=:maxent, ...)\n\nGenerates model-X knockoffs with method, runs Lasso, then applies the  knockoff-filter. If μ and Σ are not provided, they will be estimated from data. \n\nInputs\n\ny: A n × 1 response vector\nX: A n × p numeric matrix, each row is a sample, and each column is covariate.\nmethod: Method for knockoff generation (defaults to :maxent)\nμ: A p × 1 vector of column mean of X. If not provided, defaults to column mean.\nΣ: A p × p covariance matrix of X. If not provided, it will be estimated    based on a shrinked empirical covariance matrix, see modelX_gaussian_knockoffs\nd: Distribution of response. Defaults Normal(), for binary response   (logistic regression) use Binomial().\nm: Number of simultaneous knockoffs to generate, defaults to m=1\nfdrs: Target FDRs, defaults to [0.01, 0.05, 0.1, 0.25, 0.5]\ngroups: Vector of group membership. If not supplied, we generate regular knockoffs.   If supplied, we run group knockoffs.\nfilter_method: Choices are :knockoff or :knockoff_plus (default) \ndebias: Defines how the selected coefficients are debiased. Specify :ls    for least squares or :lasso for Lasso (only running on the    support). To not debias, specify debias=nothing (default).\nkwargs: Additional arguments to input into glmnetcv and glmnet\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.fit_marginal","page":"API","title":"Knockoffs.fit_marginal","text":"fit_marginal(y, X, method=:maxent, ...)\nfit_marginal(y, X, μ, Σ, method=:maxent, ...)\n\nGenerates model-X knockoffs with method and computes feature importance statistics based on squared marginal Z score: abs2(x[:, i]^t*y) / n. If μ and Σ are not provided, they will be estimated from data. \n\nInputs\n\ny: A n × 1 response vector\nX: A n × p numeric matrix, each row is a sample, and each column is covariate.\nmethod: Method for knockoff generation (defaults to :maxent)\nμ: A p × 1 vector of column mean of X. If not provided, defaults to column mean.\nΣ: A p × p covariance matrix of X. If not provided, it will be estimated    based on a shrinked empirical covariance matrix, see modelX_gaussian_knockoffs\nd: Distribution of response. Defaults Normal(), for binary response   (logistic regression) use Binomial().\nm: Number of simultaneous knockoffs to generate, defaults to m=1\nfdrs: Target FDRs, defaults to [0.01, 0.05, 0.1, 0.25, 0.5]\ngroups: Vector of group membership. If not supplied, we generate regular knockoffs.   If supplied, we run group knockoffs.\nfilter_method: Choices are :knockoff or :knockoff_plus (default) \ndebias: Defines how the selected coefficients are debiased. Specify :ls    for least squares or :lasso for Lasso (only running on the    support). To not debias, specify debias=nothing (default).\nkwargs: Additional arguments to input into glmnetcv and glmnet\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.simulate_AR1","page":"API","title":"Knockoffs.simulate_AR1","text":"simulate_AR1(p::Int, a=1, b=1, tol=1e-3, max_corr=1, rho=nothing)\n\nGenerates p-dimensional correlation matrix for AR(1) Gaussian process, where successive correlations are drawn from Beta(a,b) independently. If rho is specified, then the process is stationary with correlation rho.\n\nSource\n\nhttps://github.com/amspector100/knockpy/blob/20eddb3eb60e0e82b206ec989cb936e3c3ee7939/knockpy/dgp.py#L61\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.simulate_ER","page":"API","title":"Knockoffs.simulate_ER","text":"simulate_ER(p::Int; [invert])\n\nSimulates a covariance matrix from a clustered Erdos-Renyi graph, which is a block diagonal matrix where each block is an Erdo-Renyi graph. The result is scaled back to a correlation matrix. \n\nFor details, see the 4th simulation routine in section 5.1 of Li and Maathius  https://academic.oup.com/jrsssb/article/83/3/534/7056103?login=false\n\nInputs\n\np: Dimension of covariance matrix\nϕ: Probability of forming an edge between any 2 nodes\nlb: lower bound for the value of an edge (drawn from uniform distribution)\nub: upper bound for the value of an edge (drawn from uniform distribution)\ninvert: Whther to invert the covariance matrix (to obtain the precision)\nλmin: minimum eigenvalue of the resulting covariance matrix\nblocksize: Number of variables within each ER graph. \n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.simulate_block_covariance","page":"API","title":"Knockoffs.simulate_block_covariance","text":"simulate_block_covariance(groups, ρ, γ, num_v, w)\n\nSimulates a block covariance matrix similar to the one in Dai & Barber 2016,  The knockoff filter for FDR control in group-sparse and multitask regression.  That is, all diagonal elements will be 1, correlation within groups will be ρ, and correlation between groups will be ρ*γ. \n\nInputs\n\ngroups: Vector of group membership\nρ: within group correlation \nγ: between group correlation\n\nOptional arguments\n\nnum_v: Number of added rank 1 update Σ + v1*v1' + ... + vn*vn' where v    is iid N(0, w) (default 0)\nw: variance of the rank 1 update used in num_v (default 1)\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.normalize_col!","page":"API","title":"Knockoffs.normalize_col!","text":"normalize_col!(X::AbstractVecOrMat, [center=false])\n\nNormalize each column of X so they sum to 1. \n\n\n\n\n\n","category":"function"},{"location":"man/api/#Knockoffs.rapid","page":"API","title":"Knockoffs.rapid","text":"rapid(rapid_exe, vcffile, mapfile, d, outfolder, w, r, s, [a])\n\nWrapper for the RaPID program. \n\nInputs\n\nrapid_exe: Full path to the RaPID_v.1.7 executable file\nvcffile: Phased VCF file name\nmapfile: Map file name\nd: Actual Minimum IBD length in cM\noutfolder: Output folder name\nw: Number of SNPs in a window for sub-sampling\nr: Number of runs\ns: Minimum number of successes to consider a hit\n\nOptional Inputs\n\na: If true, ignore MAFs. By default (a=false) the sites are selected at random weighted by their MAFs.\n\n\n\n\n\n","category":"function"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"title: \"Call Julia code from R\" output:    htmldocument:     keepmd: true –-","category":"page"},{"location":"man/JuliaCall/#Calling-from-R","page":"Calling from R","title":"Calling from R","text":"","category":"section"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"This notebook demonstrates how to call Julia code in R. We will use Knockoffs.jl to generate MVR/ME knockoffs (Minimum Variance-based Reconstructability and Maximum Entropy) in R. ","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"Interfacing between R and Julia is accomplished by the JuliaCall package","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"JuliaCall package repo: https://github.com/Non-Contradiction/JuliaCall\nJuliaCall documentation: https://cran.r-project.org/web/packages/JuliaCall/JuliaCall.pdf","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"The following code was tested on Sherlock with julia/1.6.2 and R/4.1.2.","category":"page"},{"location":"man/JuliaCall/#Installation","page":"Calling from R","title":"Installation","text":"","category":"section"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"First install JuliaCall like any other R package ","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"install.packages(\"JuliaCall\", repos = \"http://cran.us.r-project.org\")","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"## \n## The downloaded binary packages are in\n## \t/var/folders/vr/7w477ygd2513yzklk5pzsk1r0000gn/T//Rtmp3EMwdk/downloaded_packages","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"To use JuliaCall you must have a working installation of Julia. You can download the latest Julia version here, or a typical cluster can load Julia with","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"module load julia/1.6.2","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"Within Julia, we need to install RCall.jl and Knockoffs.jl packages. Start Julia, and execute the following","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"using Pkg\npkg\"add RCall\"\npkg\"add https://github.com/biona001/Knockoffs.jl\"","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"Note: On Stanford cluster, I encountered GLIBCXX_3.4.20 not found error when I call julia_setup() later. To solve this, I added ","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"export R_LD_LIBRARY_PATH=/share/software/user/open/julia/1.6.2/lib/julia","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"in my ~/.bash_profile file. Once we source ~/.bash_profile and restart R, the problem should be resolved. ","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"To check that installation worked, try loading JuliaCall in R:","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"# load JuliaCall package\nlibrary(JuliaCall)\n\n# tell JuliaCall where is the Julia executable\njulia <- julia_setup(JULIA_HOME = \"/Applications/Julia-1.8.app/Contents/Resources/julia/bin\")","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"Next, within R, also try loading Knockoffs.jl package","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"# load Knockoffs.jl package\njulia_library(\"Knockoffs\")","category":"page"},{"location":"man/JuliaCall/#Examples","page":"Calling from R","title":"Examples","text":"","category":"section"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"Below are a few examples of using Knockoffs.jl in R. Obviously, these code can be modified to suit your need. Note that the first call to any Julia function will be slower than subsequent call, because Julia uses JIT (just-in-time) compilation. For larger problems, compilation time becomes negligible. ","category":"page"},{"location":"man/JuliaCall/#Wrapper-1:-generating-knockoffs","page":"Calling from R","title":"Wrapper 1: generating knockoffs","text":"","category":"section"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"Finally, generate_group_ko_with_julia is a wrapper that will solve for group knockoffs using the specified method. ","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"X is the original design matrix\nSigma is covariance matrix\nmu is column mean\nmethod can be maxent, sdp, mvr, or equi\nm is the number of knockoffs to generate per sample (see multiple knockoffs paper). \ngroups: Vector of group membership","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"To generate second order knockoffs, simply do not specify Sigma and mu. ","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"generate_group_ko_with_julia <- function(X, Sigma, mu, method, m, groups) {\n  # pass variables from R to Julia\n  julia_assign(\"X\", X)\n  julia_assign(\"Sigma\", Sigma)\n  julia_assign(\"mu\", mu)\n  julia_assign(\"method\", method)\n  julia_assign(\"m\", m)\n  julia_assign(\"groups\", groups)\n  \n  # with Julia, solve group knockoffs problem\n  julia_command(\"result = modelX_gaussian_group_knockoffs(X, Symbol(method), Int.(groups), mu, Sigma, m=Int(m), verbose=true)\")\n\n  # pull variables from Julia back to R\n  Xko <- julia_eval(\"result.X̃ \") # the knockoffs\n  S <- julia_eval(\"result.S\") # the S matrix\n  obj <- julia_eval(\"result.obj\") # final objective value\n\n  # return\n  result <- list(\"Xko\"=Xko, \"S\"=S, \"obj\"=obj)\n  return (result)\n}","category":"page"},{"location":"man/JuliaCall/#Wrapper-2:-running-lasso","page":"Calling from R","title":"Wrapper 2: running lasso","text":"","category":"section"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"If one wishes to run Lasso, we have a convenient function fit_lasso. By default, we run with 5 target FDR levels 0.01, 0.05, 0.1, 0.25, 0.5, so there are 5 sets of selected variables.","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"run_group_ko_lasso_with_julia <- function(y, X, Sigma, mu, method, m, groups) {\n  # pass variables from R to Julia\n  julia_assign(\"y\", y)\n  julia_assign(\"X\", X)\n  julia_assign(\"Sigma\", Sigma)\n  julia_assign(\"mu\", mu)\n  julia_assign(\"method\", method)\n  julia_assign(\"m\", m)\n  julia_assign(\"groups\", groups)\n\n  # with Julia, generate group knockoffs then solve lasso\n  julia_command(\"result = fit_lasso(vec(y), X, mu, Sigma, groups=Int.(groups), method=Symbol(method), m=Int(m))\")\n\n  # pull variables from Julia back to R\n  selected <- julia_eval(\"result.selected\") # selected variables\n  Xko <- julia_eval(\"result.ko.X̃ \") # the knockoffs\n  S <- julia_eval(\"result.ko.S\") # the S matrix\n  obj <- julia_eval(\"result.ko.obj\") # final objective value\n\n  # return\n  result <- list(\"selected\"=selected, \"Xko\"=Xko, \"S\"=S, \"obj\"=obj)\n  return (result)\n}","category":"page"},{"location":"man/JuliaCall/#Wrapper-3:-only-solve-for-S-matrix","page":"Calling from R","title":"Wrapper 3: only solve for S matrix","text":"","category":"section"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"Here's a function that only solves the Knockoff optimization problem and returns the S matrix, given a covariance matrix. ","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"Sigma is covariance matrix\ngroups is a group membership vector\nmethod can be maxent, sdp, mvr, or equi\nm is the number of knockoffs to generate per sample. ","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"solve_S_with_julia <- function(Sigma, groups, method, m) {\n  # pass Sigma from R to Julia\n  julia_assign(\"Sigma\", Sigma)\n  julia_assign(\"groups\", groups)\n  julia_assign(\"method\", method)\n  julia_assign(\"m\", m)\n\n  # solve for s vector in Julia (note: one must wrap `Symmetric()` keyword around Sigma)\n  julia_command(\"S, _, obj = solve_s_group(Symmetric(Sigma), groups, Symbol(method), tol=0.01, m=Int(m))\")\n\n  # put S matrix from Julia back to R\n  S <- julia_eval(\"S\")\n\n  # return s vector\n  return(S)\n}","category":"page"},{"location":"man/JuliaCall/#Example-1:-Generating-knockoff","page":"Calling from R","title":"Example 1: Generating knockoff","text":"","category":"section"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"Let's simulate a covariance matrix, then solve the group knockoff problem with maximum entropy coordinate descent","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"# simulate 1000 by 1000 toeplitz covariance matrix in R\nn <- 1000 # number of samples\np <- 1000 # number of covariates\nm <- 1    # number of knockoffs to generate per feature\nSigma <- toeplitz(0.7^(0:(p-1)))\nmu <- rep(0, p)\nmethod <- \"maxent\"\nX <- MASS::mvrnorm(n=n, mu=mu, Sigma=Sigma)\n\n# variables 1-5 are in group 1, then variables 6-10 in group 2...etc\ngroups = rep(1:200, each = 5)\n\n# call Julia solver\nresult <- generate_group_ko_with_julia(X, Sigma, mu, method, m, groups)\nXko <- result$Xko\nS <- result$S\nobj <- result$obj\n\n# print first few entries of S\nS[1:5, 1:5]","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"##           [,1]      [,2]      [,3]      [,4]      [,5]\n## [1,] 0.8960803 0.5703981 0.3503640 0.2140139 0.0954538\n## [2,] 0.5703981 0.8344664 0.5220040 0.3149892 0.1377268\n## [3,] 0.3503640 0.5220040 0.7898848 0.4708099 0.1992458\n## [4,] 0.2140139 0.3149892 0.4708099 0.7051883 0.2873474\n## [5,] 0.0954538 0.1377268 0.1992458 0.2873474 0.4067004","category":"page"},{"location":"man/JuliaCall/#Example-2:-Running-Lasso","page":"Calling from R","title":"Example 2: Running Lasso","text":"","category":"section"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"Let's simulate a covariance matrix, design matrix X, and response y, then solve the group knockoff problem with maximum entropy coordinate descent. To solve the Lasso problem, Knockoffs.jl internally calls Fortran code from the GLMNet library. ","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"# simulate 1000 by 1000 toeplitz covariance matrix in R\nn <- 1000 # sample size\np <- 1000 # number of covariates\nk <- 10   # number of causal variables\nm <- 1    # number of knockoffs to generate per feature\nmu <- rep(0, p)\nSigma <- toeplitz(0.4^(0:(p-1)))\nmethod <- \"maxent\"\n\n# variables 1-5 are in group 1, then variables 6-10 in group 2...etc\ngroups = rep(1:200, each = 5)\n\n# simulate X, y, beta\nX <- MASS::mvrnorm(n=n, mu=mu, Sigma=Sigma)\nbeta <- sample(c(rnorm(k), rep(0, p-k)))\ny <- X %*% beta + rnorm(n)\n\n# call Julia solver\nresult <- run_group_ko_lasso_with_julia(y, X, Sigma, mu, method, m, groups)\nselected <- result$selected\nXko <- result$Xko\nS <- result$S\nobj <- result$obj\n\n# check selected (here selected has 5 vectors, corresponding to target FDR 0.01, 0.05, 0.1, 0.25, 0.5)\nselected[3]","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"##  [1]  14  19  21  38  61  66 123 168 182 183 185","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"For sanity check, compare selection to the causal groups","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"correct_groups <- groups[which(beta != 0)]\ncorrect_groups","category":"page"},{"location":"man/JuliaCall/","page":"Calling from R","title":"Calling from R","text":"##  [1]  14  19  38  61  66 123 168 182 183 185","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#fastPHASE-HMM-knockoffs","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"This is a tutorial for generating (fastPHASE) HMM knockoffs for genome-wide association studies. This kind of knockoffs is suitable for data without population admixture or cryptic relatedness. The methodology is described in the following paper:","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Sesia, Matteo, Chiara Sabatti, and Emmanuel J. Candès. \"Gene hunting with hidden Markov model knockoffs.\" Biometrika 106.1 (2019): 1-18.","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"If your samples have diverse ancestries and/or extensive relatedness, we recommend those samples to be filtered out, or use SHAPEIT-HMM knockoffs.","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"# first load packages needed for this tutorial\nusing Revise\nusing SnpArrays\nusing Knockoffs\nusing Statistics\nusing Plots\nusing GLMNet\nusing Distributions\nusing Random\ngr(fmt=:png);","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Step-0:-Prepare-example-data","page":"fastPHASE HMM knockoffs","title":"Step 0: Prepare example data","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"To illustrate we need example PLINK data, which are available in Knockoffs.jl/data","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"test.(bed/bim/fam) are simulated genotypes without missings\nmouse.imputed.(bed/bim/fam) are real genotypes without missing","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"# Path to PLINK data\ndata_path = joinpath(normpath(Knockoffs.datadir()), \"test\")","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"\"/Users/biona001/.julia/dev/Knockoffs/data/test\"","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Step-1:-Generate-Knockoffs","page":"fastPHASE HMM knockoffs","title":"Step 1: Generate Knockoffs","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Knockoffs are made using the wrapper function hmm_knockoff. This function does 3 steps sequentially:","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Run fastPHASE on mathbfX_ntimes p to estimate alpha theta r (this step takes 5-10 min for the example data)\nFit and generate knockoff copies of the HMM \nStore knockoffs tildemathbfX_ntimes p in binary PLINK format (by default under a new directory called knockoffs) and return it as a SnpArray","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"@time X̃ = hmm_knockoff(data_path, plink_outfile=\"test.fastphase.knockoffs\")","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"seed = 1652154851\n\nThis is fastPHASE 1.4.8\n\nCopyright 2005-2006.  University of Washington. All rights reserved.\nWritten by Paul Scheet, with algorithm developed by Paul Scheet and\nMatthew Stephens in the Department of Statistics at the University of\nWashington.  Please contact pscheet@alum.wustl.edu for questions, or to\nobtain the software visit\nhttp://stephenslab.uchicago.edu/software.html\n\nTotal proportion of missing genotypes: 0.000000\n1000 diploids below missingness threshold, 0 haplotypes\n data read successfully\n1000 diploid individuals, 10000 loci\n\nK selected (by user): \t\t 12\nseed: \t\t\t 1\nno. EM starts: \t\t 1\nEM iterations: \t\t 10\nno. haps from posterior: 0\nNOT using subpopulation labels\n\n\n this is random start no. 1 of 1 for the EM...\n\nseed for this start: 1\n-12448937.79229315\n-9445075.64492578\n-8349084.94704032\n-7261896.43613014\n-6281741.47324536\n-5576823.19655063\n-5155151.87406101\n-4928193.53344398\n-4802495.92350104\n-4725979.88580363\nfinal loglikelihood: -4676003.575106\niterations: 10\n\nwriting parameter estimates to disk\n\n  simulating 0 haplotype configurations for each individual... done.\n\n\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:02:45\u001b[39m\n\n\n\n\nsimulating 0 haplotypes from model: knockoffs/tmp1_hapsfrommodel.out\n554.600068 seconds (124.71 M allocations: 6.023 GiB, 0.35% gc time, 4.53% compilation time)\n\n\n\n\n\n1000×10000 SnpArray:\n 0x00  0x00  0x02  0x03  0x02  0x02  …  0x03  0x03  0x03  0x02  0x03  0x02\n 0x00  0x02  0x03  0x03  0x02  0x00     0x02  0x02  0x02  0x00  0x00  0x02\n 0x00  0x00  0x02  0x03  0x02  0x02     0x03  0x03  0x00  0x00  0x02  0x02\n 0x00  0x00  0x00  0x00  0x00  0x02     0x02  0x02  0x02  0x02  0x00  0x00\n 0x00  0x00  0x02  0x02  0x02  0x02     0x02  0x00  0x00  0x00  0x03  0x03\n 0x00  0x00  0x03  0x03  0x02  0x02  …  0x03  0x03  0x02  0x02  0x02  0x00\n 0x00  0x00  0x03  0x03  0x00  0x03     0x03  0x00  0x02  0x02  0x03  0x03\n 0x02  0x02  0x03  0x02  0x00  0x02     0x03  0x03  0x02  0x00  0x02  0x02\n 0x02  0x00  0x02  0x02  0x00  0x02     0x03  0x03  0x02  0x02  0x00  0x03\n 0x00  0x03  0x02  0x03  0x03  0x02     0x03  0x03  0x03  0x00  0x00  0x02\n 0x00  0x02  0x02  0x03  0x03  0x02  …  0x03  0x03  0x03  0x03  0x00  0x02\n 0x02  0x02  0x02  0x02  0x00  0x00     0x02  0x02  0x02  0x00  0x02  0x00\n 0x00  0x00  0x03  0x03  0x02  0x02     0x02  0x02  0x02  0x00  0x00  0x00\n    ⋮                             ⋮  ⋱           ⋮                    \n 0x00  0x00  0x03  0x02  0x02  0x00     0x03  0x03  0x03  0x02  0x02  0x00\n 0x00  0x02  0x02  0x03  0x03  0x03     0x03  0x02  0x03  0x02  0x03  0x03\n 0x02  0x02  0x03  0x03  0x03  0x02  …  0x03  0x00  0x00  0x00  0x03  0x03\n 0x00  0x00  0x02  0x03  0x03  0x02     0x03  0x02  0x02  0x02  0x03  0x03\n 0x02  0x00  0x00  0x00  0x02  0x02     0x02  0x00  0x00  0x00  0x03  0x03\n 0x00  0x00  0x02  0x02  0x02  0x03     0x02  0x03  0x02  0x02  0x02  0x02\n 0x03  0x03  0x03  0x03  0x02  0x00     0x03  0x02  0x03  0x03  0x03  0x02\n 0x00  0x00  0x02  0x02  0x02  0x00  …  0x03  0x02  0x02  0x00  0x02  0x03\n 0x02  0x02  0x02  0x02  0x00  0x00     0x03  0x03  0x03  0x02  0x00  0x03\n 0x00  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x02  0x02\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x02  0x02  0x00  0x02  0x02\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x03  0x02","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Optional-parameters","page":"fastPHASE HMM knockoffs","title":"Optional parameters","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Here are some optional parameters one can tune when fitting the HMM procedure. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"K: Number of haplotype clusters. Defaults to 12\nC: Number of EM iterations before convergence. Defaults to 10.\nn: Number of samples used to fit HMM in fastPHASE. Defaults to using all samples","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"They can be specified via:","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"@time X̃ = hmm_knockoff(\n    data_file,\n    plink_outfile=\"test.fastphase.knockoffs\",\n    K = 12,\n    C = 10,\n    n = 100)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Step-2:-Examine-knockoff-statistics","page":"fastPHASE HMM knockoffs","title":"Step 2: Examine knockoff statistics","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Lets check if the knockoffs \"make sense\". We will use SnpArrays.jl to import the original and knockoff genotypes, and compare summary statistics using built-in functions comparepairwisecorrelation and compare_correlation","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"# import original and knockoff genotypes\nX = SnpArray(data_path * \".bed\")\nX̃ = SnpArray(\"knockoffs/test.fastphase.knockoffs.bed\")\nn, p = size(X̃)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"(1000, 10000)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Lets compare cor(X_i X_j) and cor(X_i tildeX_j). If knockoffs satisfy exchangability, their correlation should be very similar and form a diagonal line. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"# look at only pairwise correlation between first 200 snps\nr1, r2 = compare_pairwise_correlation(X, X̃, snps=200)\n\n# make plot\nscatter(r1, r2, xlabel = \"cor(Xi, Xj)\", ylabel=\"cor(Xi, X̃j)\", legend=false)\nPlots.abline!(1, 0, line=:dash)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"(Image: png)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Plots distribution of cor(X_j tildeX_j) for all j. Ideally, we want cor(X_j tildeX_j) to be small in magnitude (i.e. X and tildeX is very different). Here the knockoffs are tightly correlated with the original genotypes, so they will likely have low power. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"r2 = compare_correlation(X, X̃)\nhistogram(r2, legend=false, xlabel=\"cor(Xi, X̃i)\", ylabel=\"count\")","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"(Image: png)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#LASSO-example","page":"fastPHASE HMM knockoffs","title":"LASSO example","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Let us apply the generated knockoffs to the model selection problem","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Given response mathbfy_n times 1, design matrix mathbfX_n times p, we want to select a subset S subset 1p of variables that are truly causal for mathbfy. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Simulate-data","page":"fastPHASE HMM knockoffs","title":"Simulate data","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"We will simulate ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"mathbfy_n times 1 sim N(mathbfX_n times pmathbfbeta_p times 1    mathbfepsilon_n times 1) quad epsilon_i sim N(0 1)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"where k=50 positions of mathbfbeta is non-zero with effect size beta_j sim N(0 1). The goal is to recover those 50 positions using LASSO.","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"# set seed for reproducibility\nRandom.seed!(1111)\n\n# simulate true beta\nn, p = size(X)\nk = 50\nβtrue = zeros(p)\nβtrue[1:k] .= randn(k)\nshuffle!(βtrue)\n\n# find true causal variables\ncorrect_position = findall(!iszero, βtrue)\n\n# simulate y\ny = X * βtrue + randn(n)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"1000-element Vector{Float64}:\n -7.523748950079584\n -5.870529819964483\n -0.5742132199848955\n  2.1309132557501718\n -1.6879497296254022\n  6.303519372510508\n -5.802636275728736\n  4.326923276536526\n -1.0412802760571847\n -8.041827059609703\n  5.499043516471697\n -7.052572319910739\n -0.7269822409994189\n  ⋮\n -8.64616507915174\n  9.75520485123946\n -4.741610543782101\n  0.19476116174706148\n -6.907628164727042\n  4.074654461857484\n -0.8816816975311048\n -4.477392544345892\n -0.9657429191845255\n -2.6017256381373777\n  3.599329780486735\n -8.028131783786595","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#Standard-LASSO","page":"fastPHASE HMM knockoffs","title":"Standard LASSO","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Lets try running standard LASSO, which will produce hatmathbfbeta_p times 1 where we typically declare SNP j to be selected if hatbeta_j ne 0. We use LASSO solver in GLMNet.jl package, which is just a Julia wrapper for the GLMnet Fortran code. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"How well does LASSO perform in terms of power and FDR?","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"# run 10-fold cross validation to find best λ minimizing MSE\nlasso_cv = glmnetcv(X, y)\nλbest = lasso_cv.lambda[argmin(lasso_cv.meanloss)]\n\n# use λbest to fit LASSO on full data\nβlasso = glmnet(X, y, lambda=[λbest]).betas[:, 1]\n\n# check power and false discovery rate\npower = length(findall(!iszero, βlasso) ∩ correct_position) / k\nFDR = length(setdiff(findall(!iszero, βlasso), correct_position)) / count(!iszero, βlasso)\n\n#summarize\ncount(!iszero, βlasso), power, FDR","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"(348, 0.9, 0.8706896551724138)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Observe that","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"LASSO found a total of 348 SNPs\nLASSO found 90% of all true predictors\nFalse discovery rate is 87%, meaning that 303/348 discovered predictors are false positives. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/#KnockoffLASSO","page":"fastPHASE HMM knockoffs","title":"Knockoff+LASSO","text":"","category":"section"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Now lets try applying the knockoff methodology. Recall that consists of a few steps ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Run LASSO on mathbfX mathbftildeX\nCompare feature importance score W_j = textscore(x_j) - textscore(tildex_j) for each j = 1p. Here we use W_j = beta_j - tildebeta_j\nChoose target FDR 0 le q le 1 and compute ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"tau = min_tleftt  0 fracj W_j  -tj W_j  t le qright","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"note: Note\nIn step 1, mathbfX mathbftildeX is written for notational convenience. In practice one must interleave knockoffs with the original variables, where either the knockoff come first or the original genotype come first with equal probability. This is due to the inherent bias of LASSO solvers: when the original and knockoff variable are equally valid, the one listed first will be selected. ","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"# interleave knockoffs with originals\nXfull, original, knockoff = merge_knockoffs_with_original(data_path,\n    \"knockoffs/test.fastphase.knockoffs\",\n    des=\"knockoffs/merged\") \nXfull = convert(Matrix{Float64}, Xfull, center=true, scale=true)\n\n# step 1\nknockoff_cv = glmnetcv(Xfull, y)                         # cross validation step\nλbest = knockoff_cv.lambda[argmin(knockoff_cv.meanloss)] # find lambda that minimizes MSE\nβestim = glmnet(Xfull, y, lambda=[λbest]).betas[:, 1]    # refit lasso with best lambda\n\n# target FDR is 0.05, 0.1, ..., 0.5\nFDR = collect(0.05:0.05:0.5)\nempirical_power = Float64[]\nempirical_fdr = Float64[]\nfor fdr in FDR\n    βknockoff = extract_beta(βestim, fdr, original, knockoff) # steps 2-3 happen here\n\n    # compute power and false discovery proportion\n    power = length(findall(!iszero, βknockoff) ∩ correct_position) / k\n    fdp = length(setdiff(findall(!iszero, βknockoff), correct_position)) / max(count(!iszero, βknockoff), 1)\n    push!(empirical_power, power)\n    push!(empirical_fdr, fdp)\nend\n\n# visualize FDR and power\npower_plot = plot(FDR, empirical_power, xlabel=\"Target FDR\", ylabel=\"Empirical power\", legend=false)\nfdr_plot = plot(FDR, empirical_fdr, xlabel=\"Target FDR\", ylabel=\"Empirical FDR\", legend=false)\nPlots.abline!(fdr_plot, 1, 0, line=:dash)\nplot(power_plot, fdr_plot)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"(Image: png)","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"Observe that","category":"page"},{"location":"man/fastphase_hmm/fastphase_hmm/","page":"fastPHASE HMM knockoffs","title":"fastPHASE HMM knockoffs","text":"LASSO + knockoffs controls the false discovery rate at approximately the target (dashed line). If we repeat the simulation multiple times, the empirical FDR should average out to be slightly below the target level.\nThe power of LASSO + knockoffs is lower than standard LASSO","category":"page"},{"location":"man/fixed/fixed/#Fixed-X-knockoffs","page":"Fixed-X Knockoffs","title":"Fixed-X knockoffs","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"This tutorial generates fixed-X knockoffs and checks some of its basic properties. The methodology is described in the following paper","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Barber, Rina Foygel, and Emmanuel J. Candès. \"Controlling the false discovery rate via knockoffs.\" The Annals of Statistics 43.5 (2015): 2055-2085.","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"note: Note\nFor fixed-X knockoffs, we assume n  2p where n is sample size and p is number of covariates, although in principle this method can be adapted to work for n  p case.","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# load packages needed for this tutorial\nusing Knockoffs\nusing Random\nusing GLMNet\nusing LinearAlgebra\nusing Distributions\nusing Plots\ngr(fmt=:png);","category":"page"},{"location":"man/fixed/fixed/#Generate-knockoffs","page":"Fixed-X Knockoffs","title":"Generate knockoffs","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"We will","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Simulate Gaussian design matrix\nGenerate knockoffs. Here we generate maximum entropy (ME) knockoffs as described in this paper. ME knockoffs tend to have higher power over SDP or equi-correlated knockoffs. For more options, see the fixed_knockoffs API.","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"X = randn(1000, 200) # simulate Gaussian matrix\nnormalize_col!(X)    # normalize columns of X\n\n# make ME knockoffs\n@time me = fixed_knockoffs(X, :maxent);","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"  0.767067 seconds (102 allocations: 22.303 MiB)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"The return type is a Knockoff struct, which contains the following fields","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"struct GaussianKnockoff{T<:AbstractFloat, M<:AbstractMatrix, S <: Symmetric} <: Knockoff\n    X::M # n × p design matrix\n    Xko::Matrix{T} # n × mp knockoff of X\n    s::Vector{T} # p × 1 vector. Diagonal(s) and 2Sigma - Diagonal(s) are both psd\n    Sigma::S # p × p symmetric covariance matrix. \n    method::Symbol # method for solving s\n    m::Int # number of knockoffs per feature generated\nend","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Thus, to access these fields, one can do","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Xko = me.Xko      \ns = me.s\nSigma = me.Sigma; # estimated covariance matrix","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"We can check some knockoff properties. For instance, is it true that XtildeX approx Sigma - diag(s)?","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# compare X'Xko and Sigma-diag(s) visually\n[vec(X'*Xko) vec(Sigma - Diagonal(s))]","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"40000×2 Matrix{Float64}:\n  0.376926     0.376926\n -0.0434507   -0.0434507\n -0.00211772  -0.00211772\n -0.00720163  -0.00720163\n -0.0160462   -0.0160462\n  0.00304937   0.00304937\n -0.0207398   -0.0207398\n -0.0171064   -0.0171064\n  0.0164143    0.0164143\n -0.0314399   -0.0314399\n -0.01243     -0.01243\n  0.0308754    0.0308754\n  0.0194948    0.0194948\n  ⋮           \n -0.0183637   -0.0183637\n  0.0180358    0.0180358\n -0.0269833   -0.0269833\n  0.00231273   0.00231273\n  0.0047828    0.0047828\n  0.0191073    0.0191073\n  0.0116001    0.0116001\n -0.0203994   -0.0203994\n  0.00449654   0.00449654\n -0.00696245  -0.00696245\n -0.0045149   -0.0045149\n  0.363215     0.363215","category":"page"},{"location":"man/fixed/fixed/#LASSO-example","page":"Fixed-X Knockoffs","title":"LASSO example","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Let us apply the generated knockoffs to the model selection problem","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Given response mathbfy_n times 1, design matrix mathbfX_n times p, we want to select a subset S subset 1p of variables that are truly causal for mathbfy. ","category":"page"},{"location":"man/fixed/fixed/#Simulate-data","page":"Fixed-X Knockoffs","title":"Simulate data","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"We will simulate ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"mathbfy_n times 1 sim N(mathbfX_n times pmathbfbeta_p times 1    mathbfepsilon_n times 1) quad epsilon_i sim N(0 05)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"where k=50 positions of mathbfbeta is non-zero with effect size beta_j sim N(0 1). The goal is to recover those 50 positions using LASSO.","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# set seed for reproducibility\nRandom.seed!(2022)\n\n# simulate true beta\nn, p = size(X)\nk = 50\nβtrue = zeros(p)\nβtrue[1:k] .= randn(50)\nshuffle!(βtrue)\n\n# find true causal variables\ncorrect_position = findall(!iszero, βtrue)\n\n# simulate y using normalized X\ny = X * βtrue + randn(n)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"1000-element Vector{Float64}:\n  11.443750905602776\n   0.9838821881590077\n   4.005284705393306\n  -3.7700161069515\n -13.00069065413081\n  -3.723567487544001\n  -0.023706041074809142\n  -7.7754509432906405\n  -1.3428086906548775\n   2.997872505761214\n   3.0159247260525435\n   7.447226561613222\n   0.8552180712448658\n   ⋮\n   7.5361496693874495\n   4.931186951450571\n  -2.257175596026274\n  -0.5319905325018484\n   8.025043090281391\n   6.3728542780832385\n  -3.0432136216197696\n   0.77378700225668\n  -3.454973406104122\n  -5.29163844545535\n   2.74314096421341\n   0.05144992498465495","category":"page"},{"location":"man/fixed/fixed/#Standard-LASSO","page":"Fixed-X Knockoffs","title":"Standard LASSO","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Lets try running standard LASSO, which will produce hatmathbfbeta_p times 1 where we typically declare variable j to be selected if hatbeta_j ne 0. We use LASSO solver in GLMNet.jl package, which is just a Julia wrapper for the GLMnet Fortran code. ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"How well does LASSO perform in terms of power and FDR?","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# run 10-fold cross validation to find best λ minimizing MSE\nlasso_cv = glmnetcv(X, y)\nλbest = lasso_cv.lambda[argmin(lasso_cv.meanloss)]\n\n# use λbest to fit LASSO on full data\nβlasso = glmnet(X, y, lambda=[λbest]).betas[:, 1]\n\n# check power and false discovery rate\npower = length(findall(!iszero, βlasso) ∩ correct_position) / k\nFDR = length(setdiff(findall(!iszero, βlasso), correct_position)) / count(!iszero, βlasso)\nprintln(\"Lasso power = $power, FDR = $FDR\")","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Lasso power = 0.96, FDR = 0.5","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"About half of all discoveries from Lasso regression are false positives. ","category":"page"},{"location":"man/fixed/fixed/#KnockoffLASSO","page":"Fixed-X Knockoffs","title":"Knockoff+LASSO","text":"","category":"section"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Now lets try applying the knockoff methodology. Recall that consists of a few steps ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Run LASSO on mathbfX mathbftildeX\nCompare feature importance score W_j = textscore(x_j) - textscore(tildex_j) for each j = 1p. Here we use W_j = beta_j - tildebeta_j\nChoose target FDR q in 0 1 and compute ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"tau = min_tleftt  0 fracj W_j  -tmax(1 j W_j  t) le qright","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"@time knockoff_filter = fit_lasso(y, me);","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"  1.049388 seconds (835 allocations: 46.274 MiB)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"The return type is now a LassoKnockoffFilter, which contains the following information","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"struct LassoKnockoffFilter{T} <: KnockoffFilter\n    y :: Vector{T} # n × 1 response vector\n    X :: Matrix{T} # n × p matrix of original features\n    ko :: Knockoff # A knockoff struct\n    m :: Int # number of knockoffs per feature generated\n    betas :: Vector{Vector{T}} # betas[i] is the p × 1 vector of effect sizes corresponding to fdr level fdr_target[i]\n    a0 :: Vector{T}   # intercepts for each model in betas\n    selected :: Vector{Vector{Int}} # selected[i] includes all variables selected based on target FDR level fdr_target[i]\n    W :: Vector{T} # length p vector of feature importance\n    taus :: Vector{T} # threshold for significance. For fdr fdr_target[i], tau[i] is threshold, and all W ≥ tau[i] is selected\n    fdr_target :: Vector{T} # target FDR level for each taus and betas\n    d :: UnivariateDistribution # distribution of y\n    debias :: Union{Nothing, Symbol} # how betas and a0 have been debiased (`nothing` for not debiased)\nend","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Given these information, we can e.g. visualize power and FDR trade-off:","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"# run 10 simulations and compute empirical power/FDR\nnsims = 10\nempirical_power = zeros(5)\nempirical_fdr = zeros(5)\nfor i in 1:nsims\n    # simulate data\n    X = randn(1000, 200)\n    k = 50\n    βtrue = zeros(p)\n    βtrue[1:k] .= randn(50)\n    shuffle!(βtrue)\n    correct_position = findall(!iszero, βtrue)\n    y = X * βtrue + randn(n)\n\n    # generate knockoff and fit lasso\n    @time me = fixed_knockoffs(X, :maxent)\n    @time knockoff_filter = fit_lasso(y, me)\n\n    # compute FDR/power\n    FDR = knockoff_filter.fdr_target\n    for i in eachindex(FDR)\n        selected = knockoff_filter.selected[i]\n        power = length(selected ∩ correct_position) / k\n        fdp = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n        empirical_power[i] += power\n        empirical_fdr[i] += fdp\n    end\nend\nempirical_power ./= nsims\nempirical_fdr ./= nsims\n\n# visualize FDR and power\npower_plot = plot(FDR, empirical_power, xlabel=\"Target FDR\", ylabel=\"Empirical power\", legend=false, w=2)\nfdr_plot = plot(FDR, empirical_fdr, xlabel=\"Target FDR\", ylabel=\"Empirical FDR\", legend=false, w=2)\nPlots.abline!(fdr_plot, 1, 0, line=:dash)\nplot(power_plot, fdr_plot)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"  0.730351 seconds (102 allocations: 22.303 MiB, 0.75% gc time)\n  0.882967 seconds (835 allocations: 46.349 MiB)\n  0.508460 seconds (102 allocations: 22.303 MiB)\n  0.888551 seconds (835 allocations: 46.278 MiB)\n  0.643473 seconds (102 allocations: 22.303 MiB)\n  0.891910 seconds (835 allocations: 46.492 MiB, 0.18% gc time)\n  0.432557 seconds (102 allocations: 22.303 MiB)\n  0.859462 seconds (835 allocations: 46.205 MiB)\n  0.474027 seconds (102 allocations: 22.303 MiB)\n  0.879261 seconds (835 allocations: 46.277 MiB)\n  0.586823 seconds (102 allocations: 22.303 MiB, 0.48% gc time)\n  0.883496 seconds (835 allocations: 46.421 MiB)\n  0.742627 seconds (102 allocations: 22.303 MiB)\n  0.878495 seconds (835 allocations: 46.127 MiB)\n  0.576416 seconds (102 allocations: 22.303 MiB)\n  0.884102 seconds (835 allocations: 46.204 MiB, 0.15% gc time)\n  0.617052 seconds (102 allocations: 22.303 MiB)\n  0.885246 seconds (835 allocations: 46.493 MiB)\n  0.536176 seconds (102 allocations: 22.303 MiB)\n  0.872704 seconds (835 allocations: 46.127 MiB, 0.15% gc time)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Conclusion: ","category":"page"},{"location":"man/fixed/fixed/","page":"Fixed-X Knockoffs","title":"Fixed-X Knockoffs","text":"Regular Lasso has good power but nearly 50% of all discoveries are false positives. \nKnockoffs + Lasso controls the false discovery rate at below the target (dashed line)","category":"page"},{"location":"man/ipad/#IPAD-knockoffs","page":"IPAD Knockoffs","title":"IPAD knockoffs","text":"","category":"section"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"This tutorial generates knockoffs based on the intertwined probabilistic factors decoupling (IPAD) method, described in the following paper","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"Fan, Yingying, Jinchi Lv, Mahrad Sharifvaghefi, and Yoshimasa Uematsu. \"IPAD: stable interpretable forecasting with knockoffs inference.\" Journal of the American Statistical Association 115, no. 532 (2020): 1822-1834.","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"As we will see shortly,","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"IPAD knockoffs are more powerful and much more efficient to generate than model-X MVR/ME/SDP knockoffs, if we can assume a low-dimensional factored model for the data matrix X. \nIf X doesn't really assume a factored model, then IPAD knockoff's empirical FDR will be inflated, sometimes severely so.","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"Our comparison uses target FDR 10%,  Lasso coefficient difference statistic, and we explore 3 ways (ER, GR, VR) to choose the number of latent factors r for IPAD knockoffs.","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"# load packages\nusing Knockoffs\nusing LinearAlgebra\nusing Random\nusing StatsKit\nusing ToeplitzMatrices\nusing Distributions\nusing Random\nusing CSV, DataFrames","category":"page"},{"location":"man/ipad/#Test1:-Simulate-under-factored-model","page":"IPAD Knockoffs","title":"Test1: Simulate under factored model","text":"","category":"section"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"This is design 1 of IPAD: Stable Interpretable Forecasting with Knockoffs Inference. ","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"Here n=500 p=1000\nX = FLambda + sqrtrthetaE where r = 3 theta=1 and F Lambda E are n times r p times r, and n times p iid gaussian matrices. \ny = Xbeta + sqrtcepsilon where c = 02\n50 causal variables with beta_i = A = 01\nFor MVR/ME/SDP, we generate 2nd order knockoffs by estimating a shrinked covariance matrix","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"function compare_ipad(nsims)\n    n = 500 # number of samples\n    p = 1000 # number of covariates\n    m = 1    # number of knockoffs per variable\n    k = 50   # number of causal variables\n    rtrue = 3 # true rank\n    A = 0.1 # causal beta\n    θ = 1\n    c = 0.2 # some noise term for simulating y    \n    \n    sdp_powers, sdp_fdrs, sdp_times = 0.0, 0.0, 0.0\n    me_powers, me_fdrs, me_times = 0.0, 0.0, 0.0\n    mvr_powers, mvr_fdrs, mvr_times = 0.0, 0.0, 0.0\n    ipad_er_powers, ipad_er_fdrs, ipad_er_times = 0.0, 0.0, 0.0\n    ipad_gr_powers, ipad_gr_fdrs, ipad_gr_times = 0.0, 0.0, 0.0\n    ipad_ve_powers, ipad_ve_fdrs, ipad_ve_times = 0.0, 0.0, 0.0\n\n    for seed in 1:nsims\n        # simulate X\n        Random.seed!(seed)\n        F = randn(n, rtrue)\n        Λ = randn(p, rtrue)\n        C = F * Λ'\n        E = randn(n, p)\n        X = C + sqrt(rtrue * θ) * E\n\n        # simulate y\n        Random.seed!(seed)\n        βtrue = zeros(p)\n        βtrue[1:k] .= rand(-1:2:1, k) .* A\n        shuffle!(βtrue)\n        ϵ = randn(n)\n        y = X * βtrue + sqrt(c) .* ϵ\n        μ = zeros(p)\n        correct_position = findall(!iszero, βtrue)\n\n        # ipad with ER\n        Random.seed!(seed)\n        ipad_er_t = @elapsed ipad_er = ipad(X, r_method = :er, m = m)\n        ipad_er_ko_filter = fit_lasso(y, ipad_er)\n        selected = ipad_er_ko_filter.selected[3]\n        ipad_er_power = length(selected ∩ correct_position) / k\n        ipad_er_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        #ipad with GR\n        Random.seed!(seed)\n        ipad_gr_t = @elapsed ipad_gr = ipad(X, r_method = :gr, m = m)\n        ipad_gr_ko_filter = fit_lasso(y, ipad_gr)\n        selected = ipad_gr_ko_filter.selected[3]\n        ipad_gr_power = length(selected ∩ correct_position) / k\n        ipad_gr_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # ipad with VE\n        Random.seed!(seed)\n        ipad_ve_t = @elapsed ipad_ve = ipad(X, r_method = :ve, m = m)\n        ipad_ve_ko_filter = fit_lasso(y, ipad_ve)\n        selected = ipad_ve_ko_filter.selected[3]\n        ipad_ve_power = length(selected ∩ correct_position) / k\n        ipad_ve_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # ME knockoffs\n        Random.seed!(seed)\n        me_t = @elapsed me = modelX_gaussian_knockoffs(X, :maxent, m = m)\n        me_ko_filter = fit_lasso(y, me)\n        selected = me_ko_filter.selected[3]\n        me_power = length(selected ∩ correct_position) / k\n        me_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # MVR knockoffs\n        Random.seed!(seed)\n        mvr_t = @elapsed mvr = modelX_gaussian_knockoffs(X, :mvr, m = m)\n        mvr_ko_filter = fit_lasso(y, mvr)\n        selected = mvr_ko_filter.selected[3]\n        mvr_power = length(selected ∩ correct_position) / k\n        mvr_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # SDP (ccd) knockoffs\n        Random.seed!(seed)\n        sdp_t = @elapsed sdp = modelX_gaussian_knockoffs(X, :sdp_ccd, m = m)\n        sdp_ko_filter = fit_lasso(y, sdp)\n        selected = sdp_ko_filter.selected[3]\n        sdp_power = length(selected ∩ correct_position) / k\n        sdp_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # record results\n        println(\"ipad ER: power = $ipad_er_power, FDR = $ipad_er_fdr, rank = $(ipad_er.r), time = $(round(ipad_er_t, digits=3))\")\n        println(\"ipad GR: power = $ipad_gr_power, FDR = $ipad_gr_fdr, rank = $(ipad_gr.r), time = $(round(ipad_gr_t, digits=3))\")\n        println(\"ipad VE: power = $ipad_ve_power, FDR = $ipad_ve_fdr, rank = $(ipad_ve.r), time = $(round(ipad_ve_t, digits=3))\")\n        println(\"ME: power = $me_power, FDR = $me_fdr, time = $(round(me_t, digits=3))\")\n        println(\"MVR: power = $mvr_power, FDR = $mvr_fdr, time = $(round(mvr_t, digits=3))\")\n        println(\"SDP: power = $sdp_power, FDR = $sdp_fdr, time = $(round(sdp_t, digits=3))\\n\\n\")\n        sdp_powers += sdp_power\n        sdp_fdrs += sdp_fdr\n        sdp_times += sdp_t\n        me_powers += me_power\n        me_fdrs += me_fdr\n        me_times += me_t\n        mvr_powers += mvr_power\n        mvr_fdrs += mvr_fdr\n        mvr_times += mvr_t\n        ipad_er_powers += ipad_er_power\n        ipad_er_fdrs += ipad_er_fdr\n        ipad_er_times += ipad_er_t\n        ipad_gr_powers += ipad_gr_power\n        ipad_gr_fdrs += ipad_gr_fdr\n        ipad_gr_times += ipad_gr_t\n        ipad_ve_powers += ipad_ve_power\n        ipad_ve_fdrs += ipad_ve_fdr\n        ipad_ve_times += ipad_ve_t\n    end\n    \n    # compute average\n    ipad_er_powers /= nsims\n    ipad_er_fdrs /= nsims\n    ipad_er_times /= nsims\n    ipad_gr_powers /= nsims\n    ipad_gr_fdrs /= nsims\n    ipad_gr_times /= nsims\n    ipad_ve_powers /= nsims\n    ipad_ve_fdrs /= nsims\n    ipad_ve_times /= nsims\n    me_powers /= nsims\n    me_fdrs /= nsims\n    me_times /= nsims\n    mvr_powers /= nsims\n    mvr_fdrs /= nsims\n    mvr_times /= nsims\n    sdp_powers /= nsims\n    sdp_fdrs /= nsims\n    sdp_times /= nsims\n    \n    # save in dataframe\n    result = DataFrame(\n        method=[\"IPAD-er\", \"IPAD-gr\", \"IPAD-ve\", \"ME\", \"MVR\", \"SDP\"],\n        power=[ipad_er_powers,ipad_gr_powers,ipad_ve_powers,me_powers,mvr_powers,sdp_powers], \n        FDR=[ipad_er_fdrs,ipad_gr_fdrs,ipad_ve_fdrs,me_fdrs,mvr_fdrs,sdp_fdrs], \n        time=[ipad_er_times,ipad_gr_times,ipad_ve_times,me_times,mvr_times,sdp_times]\n    )\n\n    return result\nend\n\nnsims = 10\nresult = compare_ipad(nsims);","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"ipad ER: power = 0.98, FDR = 0.07547169811320754, rank = 3, time = 0.232\nipad GR: power = 0.98, FDR = 0.07547169811320754, rank = 3, time = 0.068\nipad VE: power = 1.0, FDR = 0.16666666666666666, rank = 257, time = 0.052\nME: power = 0.0, FDR = 0.0, time = 2.312\nMVR: power = 0.0, FDR = 0.0, time = 2.953\nSDP: power = 0.48, FDR = 0.0, time = 11.525\n\n\nipad ER: power = 1.0, FDR = 0.2647058823529412, rank = 3, time = 0.029\nipad GR: power = 1.0, FDR = 0.2647058823529412, rank = 3, time = 0.028\nipad VE: power = 1.0, FDR = 0.12280701754385964, rank = 263, time = 0.031\nME: power = 0.5, FDR = 0.0, time = 2.256\nMVR: power = 0.4, FDR = 0.0, time = 2.944\nSDP: power = 0.94, FDR = 0.0784313725490196, time = 11.536\n\n\nipad ER: power = 0.96, FDR = 0.02040816326530612, rank = 3, time = 0.043\nipad GR: power = 0.96, FDR = 0.02040816326530612, rank = 3, time = 0.027\nipad VE: power = 0.98, FDR = 0.09259259259259259, rank = 257, time = 0.031\nME: power = 0.66, FDR = 0.0, time = 2.268\nMVR: power = 0.66, FDR = 0.0, time = 3.047\nSDP: power = 0.8, FDR = 0.024390243902439025, time = 11.565\n\n\nipad ER: power = 0.94, FDR = 0.04081632653061224, rank = 3, time = 0.049\nipad GR: power = 0.94, FDR = 0.04081632653061224, rank = 3, time = 0.027\nipad VE: power = 0.92, FDR = 0.041666666666666664, rank = 260, time = 0.225\nME: power = 0.0, FDR = 0.0, time = 2.61\nMVR: power = 0.0, FDR = 0.0, time = 2.943\nSDP: power = 0.0, FDR = 0.0, time = 11.484\n\n\nipad ER: power = 1.0, FDR = 0.20634920634920634, rank = 3, time = 0.029\nipad GR: power = 1.0, FDR = 0.20634920634920634, rank = 3, time = 0.03\nipad VE: power = 0.98, FDR = 0.07547169811320754, rank = 256, time = 0.03\nME: power = 0.78, FDR = 0.025, time = 2.255\nMVR: power = 0.64, FDR = 0.0, time = 3.009\nSDP: power = 0.9, FDR = 0.1, time = 11.51\n\n\nipad ER: power = 1.0, FDR = 0.05660377358490566, rank = 3, time = 0.03\nipad GR: power = 1.0, FDR = 0.05660377358490566, rank = 3, time = 0.029\nipad VE: power = 0.9, FDR = 0.1346153846153846, rank = 253, time = 0.03\nME: power = 0.84, FDR = 0.023255813953488372, time = 2.294\nMVR: power = 0.78, FDR = 0.025, time = 2.946\nSDP: power = 0.76, FDR = 0.05, time = 11.468\n\n\nipad ER: power = 0.92, FDR = 0.09803921568627451, rank = 3, time = 0.033\nipad GR: power = 0.92, FDR = 0.09803921568627451, rank = 3, time = 0.036\nipad VE: power = 0.92, FDR = 0.041666666666666664, rank = 256, time = 0.029\nME: power = 0.54, FDR = 0.0, time = 2.257\nMVR: power = 0.62, FDR = 0.0, time = 2.95\nSDP: power = 0.8, FDR = 0.047619047619047616, time = 11.574\n\n\nipad ER: power = 1.0, FDR = 0.10714285714285714, rank = 3, time = 0.029\nipad GR: power = 1.0, FDR = 0.10714285714285714, rank = 3, time = 0.03\nipad VE: power = 1.0, FDR = 0.15254237288135594, rank = 260, time = 0.028\nME: power = 0.66, FDR = 0.0, time = 2.254\nMVR: power = 0.66, FDR = 0.0, time = 3.003\nSDP: power = 0.8, FDR = 0.0, time = 11.761\n\n\nipad ER: power = 1.0, FDR = 0.09090909090909091, rank = 3, time = 0.031\nipad GR: power = 1.0, FDR = 0.09090909090909091, rank = 3, time = 0.027\nipad VE: power = 1.0, FDR = 0.07407407407407407, rank = 257, time = 0.032\nME: power = 0.0, FDR = 0.0, time = 2.245\nMVR: power = 0.0, FDR = 0.0, time = 2.952\nSDP: power = 0.86, FDR = 0.0, time = 11.547\n\n\nipad ER: power = 0.94, FDR = 0.14545454545454545, rank = 3, time = 0.048\nipad GR: power = 0.94, FDR = 0.14545454545454545, rank = 3, time = 0.026\nipad VE: power = 0.94, FDR = 0.1896551724137931, rank = 255, time = 0.04\nME: power = 0.68, FDR = 0.0, time = 2.269\nMVR: power = 0.7, FDR = 0.0, time = 2.962\nSDP: power = 0.9, FDR = 0.021739130434782608, time = 11.542","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"# check average\n@show result;","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"result = 6×4 DataFrame\n Row │ method   power    FDR         time\n     │ String   Float64  Float64     Float64\n─────┼──────────────────────────────────────────\n   1 │ IPAD-er    0.974  0.11059      0.055441\n   2 │ IPAD-gr    0.974  0.11059      0.032905\n   3 │ IPAD-ve    0.964  0.109176     0.0528907\n   4 │ ME         0.466  0.00482558   2.30208\n   5 │ MVR        0.446  0.0025       2.97096\n   6 │ SDP        0.724  0.032218    11.5513","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"Summary (when X follows the IPAD model assumption)","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"All methods control FDR (target = 10%) \nER and GR method always find the correct rank (r = 3), while VE overestimates the rank\nIPAD method has much better power compared to model-X knockoffs via ME/MVR/SDP construction\nSurprisingly, ME/MVR has worse power than SDP\nIPAD method is much more efficient to construct","category":"page"},{"location":"man/ipad/#Test2:-Try-X-that's-not-a-factored-model","page":"IPAD Knockoffs","title":"Test2: Try X that's not a factored model","text":"","category":"section"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"Here y sim N(Xbeta 1) and X_i sim N(0 Sigma) where Sigma is an AR(1) model.\n50 causal SNPs with beta_i sim pm N(0 05)\nFor MVR/ME/SDP knockoffs, we assume the true mu and Sigma are available. ","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"function compare_ipad2(nsims)\n    n = 500 # number of samples\n    p = 1000 # number of covariates\n    m = 1    # number of knockoffs per variable\n    k = 50   # number of causal variables\n\n    sdp_powers, sdp_fdrs, sdp_times = 0.0, 0.0, 0.0\n    me_powers, me_fdrs, me_times = 0.0, 0.0, 0.0\n    mvr_powers, mvr_fdrs, mvr_times = 0.0, 0.0, 0.0\n    ipad_er_powers, ipad_er_fdrs, ipad_er_times = 0.0, 0.0, 0.0\n    ipad_gr_powers, ipad_gr_fdrs, ipad_gr_times = 0.0, 0.0, 0.0\n    ipad_ve_powers, ipad_ve_fdrs, ipad_ve_times = 0.0, 0.0, 0.0\n\n    for seed in 1:nsims\n        # simulate X\n        Random.seed!(seed)\n        Σ = simulate_AR1(p, a=3, b=1)\n        μ = zeros(p)\n        X = rand(MvNormal(μ, Σ), n)' |> Matrix\n        zscore!(X, mean(X, dims=1), std(X, dims=1))\n\n        # simulate y\n        Random.seed!(seed)\n        βtrue = zeros(p)\n        βtrue[1:k] .= rand(-1:2:1, k) .* rand(Normal(0, 0.5), k)\n        shuffle!(βtrue)\n        ϵ = randn(n)\n        y = X * βtrue + ϵ\n        μ = zeros(p)\n        correct_position = findall(!iszero, βtrue)\n\n        # ipad with ER\n        Random.seed!(seed)\n        ipad_er_t = @elapsed ipad_er = ipad(X, r_method = :er, m = m)\n        ipad_er_ko_filter = fit_lasso(y, ipad_er)\n        selected = ipad_er_ko_filter.selected[3]\n        ipad_er_power = length(selected ∩ correct_position) / k\n        ipad_er_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        #ipad with GR\n        Random.seed!(seed)\n        ipad_gr_t = @elapsed ipad_gr = ipad(X, r_method = :gr, m = m)\n        ipad_gr_ko_filter = fit_lasso(y, ipad_gr)\n        selected = ipad_gr_ko_filter.selected[3]\n        ipad_gr_power = length(selected ∩ correct_position) / k\n        ipad_gr_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # ipad with VE\n        Random.seed!(seed)\n        ipad_ve_t = @elapsed ipad_ve = ipad(X, r_method = :ve, m = m)\n        ipad_ve_ko_filter = fit_lasso(y, ipad_ve)\n        selected = ipad_ve_ko_filter.selected[3]\n        ipad_ve_power = length(selected ∩ correct_position) / k\n        ipad_ve_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # ME knockoffs\n        Random.seed!(seed)\n        me_t = @elapsed me = modelX_gaussian_knockoffs(X, :maxent, μ, Σ, m = m)\n        me_ko_filter = fit_lasso(y, me)\n        selected = me_ko_filter.selected[3]\n        me_power = length(selected ∩ correct_position) / k\n        me_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # MVR knockoffs\n        Random.seed!(seed)\n        mvr_t = @elapsed mvr = modelX_gaussian_knockoffs(X, :mvr, μ, Σ,m = m)\n        mvr_ko_filter = fit_lasso(y, mvr)\n        selected = mvr_ko_filter.selected[3]\n        mvr_power = length(selected ∩ correct_position) / k\n        mvr_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # SDP (ccd) knockoffs\n        Random.seed!(seed)\n        sdp_t = @elapsed sdp = modelX_gaussian_knockoffs(X, :sdp_ccd, μ, Σ, m = m)\n        sdp_ko_filter = fit_lasso(y, sdp)\n        selected = sdp_ko_filter.selected[3]\n        sdp_power = length(selected ∩ correct_position) / k\n        sdp_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # record results\n        println(\"ipad ER: power = $ipad_er_power, FDR = $ipad_er_fdr, rank = $(ipad_er.r), time = $(round(ipad_er_t, digits=3))\")\n        println(\"ipad GR: power = $ipad_gr_power, FDR = $ipad_gr_fdr, rank = $(ipad_gr.r), time = $(round(ipad_gr_t, digits=3))\")\n        println(\"ipad VE: power = $ipad_ve_power, FDR = $ipad_ve_fdr, rank = $(ipad_ve.r), time = $(round(ipad_ve_t, digits=3))\")\n        println(\"ME: power = $me_power, FDR = $me_fdr, time = $(round(me_t, digits=3))\")\n        println(\"MVR: power = $mvr_power, FDR = $mvr_fdr, time = $(round(mvr_t, digits=3))\")\n        println(\"SDP: power = $sdp_power, FDR = $sdp_fdr, time = $(round(sdp_t, digits=3))\\n\\n\")\n        sdp_powers += sdp_power\n        sdp_fdrs += sdp_fdr\n        sdp_times += sdp_t\n        me_powers += me_power\n        me_fdrs += me_fdr\n        me_times += me_t\n        mvr_powers += mvr_power\n        mvr_fdrs += mvr_fdr\n        mvr_times += mvr_t\n        ipad_er_powers += ipad_er_power\n        ipad_er_fdrs += ipad_er_fdr\n        ipad_er_times += ipad_er_t\n        ipad_gr_powers += ipad_gr_power\n        ipad_gr_fdrs += ipad_gr_fdr\n        ipad_gr_times += ipad_gr_t\n        ipad_ve_powers += ipad_ve_power\n        ipad_ve_fdrs += ipad_ve_fdr\n        ipad_ve_times += ipad_ve_t\n    end\n    \n    # compute average\n    ipad_er_powers /= nsims\n    ipad_er_fdrs /= nsims\n    ipad_er_times /= nsims\n    ipad_gr_powers /= nsims\n    ipad_gr_fdrs /= nsims\n    ipad_gr_times /= nsims\n    ipad_ve_powers /= nsims\n    ipad_ve_fdrs /= nsims\n    ipad_ve_times /= nsims\n    me_powers /= nsims\n    me_fdrs /= nsims\n    me_times /= nsims\n    mvr_powers /= nsims\n    mvr_fdrs /= nsims\n    mvr_times /= nsims\n    sdp_powers /= nsims\n    sdp_fdrs /= nsims\n    sdp_times /= nsims\n    \n    # save in dataframe\n    result = DataFrame(\n        method=[\"IPAD-er\", \"IPAD-gr\", \"IPAD-ve\", \"ME\", \"MVR\", \"SDP\"],\n        power=[ipad_er_powers,ipad_gr_powers,ipad_ve_powers,me_powers,mvr_powers,sdp_powers], \n        FDR=[ipad_er_fdrs,ipad_gr_fdrs,ipad_ve_fdrs,me_fdrs,mvr_fdrs,sdp_fdrs], \n        time=[ipad_er_times,ipad_gr_times,ipad_ve_times,me_times,mvr_times,sdp_times]\n    )\n\n    return result\nend\n\nnsims = 10\nresult = compare_ipad2(nsims);","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"ipad ER: power = 0.0, FDR = 0.0, rank = 496, time = 0.052\nipad GR: power = 0.64, FDR = 0.1794871794871795, rank = 1, time = 0.039\nipad VE: power = 0.62, FDR = 0.20512820512820512, rank = 217, time = 0.044\nME: power = 0.28, FDR = 0.0, time = 2.299\nMVR: power = 0.26, FDR = 0.0, time = 3.286\nSDP: power = 0.4, FDR = 0.0, time = 8.727\n\n\nipad ER: power = 0.5, FDR = 0.24242424242424243, rank = 1, time = 0.043\nipad GR: power = 0.5, FDR = 0.24242424242424243, rank = 1, time = 0.227\nipad VE: power = 0.5, FDR = 0.24242424242424243, rank = 219, time = 0.041\nME: power = 0.0, FDR = 0.0, time = 2.627\nMVR: power = 0.2, FDR = 0.0, time = 3.515\nSDP: power = 0.38, FDR = 0.05, time = 8.974\n\n\nipad ER: power = 0.58, FDR = 0.21621621621621623, rank = 1, time = 0.039\nipad GR: power = 0.58, FDR = 0.21621621621621623, rank = 1, time = 0.031\nipad VE: power = 0.62, FDR = 0.24390243902439024, rank = 217, time = 0.078\nME: power = 0.5, FDR = 0.10714285714285714, time = 2.364\nMVR: power = 0.48, FDR = 0.07692307692307693, time = 3.309\nSDP: power = 0.0, FDR = 0.0, time = 8.754\n\n\nipad ER: power = 0.46, FDR = 0.14814814814814814, rank = 480, time = 0.049\nipad GR: power = 0.62, FDR = 0.29545454545454547, rank = 10, time = 0.035\nipad VE: power = 0.66, FDR = 0.2826086956521739, rank = 213, time = 0.049\nME: power = 0.54, FDR = 0.12903225806451613, time = 2.489\nMVR: power = 0.46, FDR = 0.08, time = 3.403\nSDP: power = 0.4, FDR = 0.09090909090909091, time = 9.418\n\n\nipad ER: power = 0.56, FDR = 0.2, rank = 1, time = 0.058\nipad GR: power = 0.56, FDR = 0.2, rank = 1, time = 0.077\nipad VE: power = 0.56, FDR = 0.2222222222222222, rank = 217, time = 0.073\nME: power = 0.38, FDR = 0.13636363636363635, time = 2.52\nMVR: power = 0.5, FDR = 0.16666666666666666, time = 3.628\nSDP: power = 0.4, FDR = 0.09090909090909091, time = 8.948\n\n\nipad ER: power = 0.0, FDR = 0.0, rank = 493, time = 0.039\nipad GR: power = 0.72, FDR = 0.25, rank = 3, time = 0.048\nipad VE: power = 0.74, FDR = 0.3508771929824561, rank = 218, time = 0.039\nME: power = 0.64, FDR = 0.058823529411764705, time = 2.555\nMVR: power = 0.64, FDR = 0.058823529411764705, time = 3.265\nSDP: power = 0.62, FDR = 0.06060606060606061, time = 8.543\n\n\nipad ER: power = 0.76, FDR = 0.3448275862068966, rank = 3, time = 0.029\nipad GR: power = 0.76, FDR = 0.3448275862068966, rank = 3, time = 0.04\nipad VE: power = 0.76, FDR = 0.36666666666666664, rank = 214, time = 0.064\nME: power = 0.6, FDR = 0.09090909090909091, time = 2.302\nMVR: power = 0.6, FDR = 0.11764705882352941, time = 3.329\nSDP: power = 0.22, FDR = 0.0, time = 8.788\n\n\nipad ER: power = 0.0, FDR = 0.0, rank = 495, time = 0.064\nipad GR: power = 0.58, FDR = 0.23684210526315788, rank = 2, time = 0.036\nipad VE: power = 0.56, FDR = 0.2, rank = 213, time = 0.034\nME: power = 0.0, FDR = 0.0, time = 2.239\nMVR: power = 0.0, FDR = 0.0, time = 3.351\nSDP: power = 0.4, FDR = 0.13043478260869565, time = 8.523\n\n\nipad ER: power = 0.68, FDR = 0.2916666666666667, rank = 1, time = 0.047\nipad GR: power = 0.68, FDR = 0.2916666666666667, rank = 1, time = 0.036\nipad VE: power = 0.7, FDR = 0.3137254901960784, rank = 218, time = 0.034\nME: power = 0.0, FDR = 0.0, time = 2.29\nMVR: power = 0.0, FDR = 0.0, time = 3.332\nSDP: power = 0.0, FDR = 0.0, time = 8.96\n\n\nipad ER: power = 0.6, FDR = 0.375, rank = 1, time = 0.105\nipad GR: power = 0.6, FDR = 0.375, rank = 1, time = 0.025\nipad VE: power = 0.54, FDR = 0.38636363636363635, rank = 213, time = 0.173\nME: power = 0.44, FDR = 0.15384615384615385, time = 2.265\nMVR: power = 0.36, FDR = 0.1, time = 3.223\nSDP: power = 0.0, FDR = 0.0, time = 8.907","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"@show result;","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"result = 6×4 DataFrame\n Row │ method   power    FDR        time\n     │ String   Float64  Float64    Float64\n─────┼────────────────────────────────────────\n   1 │ IPAD-er    0.414  0.181828   0.0524697\n   2 │ IPAD-gr    0.624  0.263192   0.059193\n   3 │ IPAD-ve    0.626  0.281392   0.0629533\n   4 │ ME         0.338  0.0676118  2.39515\n   5 │ MVR        0.35   0.060006   3.36422\n   6 │ SDP        0.282  0.0422859  8.85414","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"Summary (when X does not follow the factored model)","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"IPAD methods have slightly~pretty inflated FDR (target = 10%) \nER/GR/VE finds wildly differing ranks","category":"page"},{"location":"man/ipad/#Test3:-Simulate-with-gnomAD-panel","page":"IPAD Knockoffs","title":"Test3: Simulate with gnomAD panel","text":"","category":"section"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"Here we simulate X_i sim N(0 Sigma) where Sigma is from the European gnomAD LD panel. \nSigma can be downloaded and extract with the software EasyLD.jl. ","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"function compare_ipad3(nsims)\n    # import panel\n    datadir = \"/Users/biona001/Benjamin_Folder/research/4th_project_groupKO/group_knockoff_test_data\"\n    mapfile = CSV.read(joinpath(datadir, \"Groups_2_127374341_128034347.txt\"), DataFrame)\n    groups = mapfile[!, :group]\n    covfile = CSV.read(joinpath(datadir, \"CorG_2_127374341_128034347.txt\"), DataFrame)\n    Σ = covfile |> Matrix{Float64}\n    Σ = 0.99Σ + 0.01I #ensure PSD\n\n    # test on smaller data\n    idx = findlast(x -> x == 263, groups) # 263 is largest group with 192 members\n    groups = groups[1:idx]\n    Σ = Σ[1:idx, 1:idx]\n    \n    # simulation parameters\n    n = 500 # number of samples\n    p = size(Σ, 1) # number of covariates\n    m = 1    # number of knockoffs per variable\n    k = 50   # number of causal variables\n    \n    sdp_powers, sdp_fdrs, sdp_times = 0.0, 0.0, 0.0\n    me_powers, me_fdrs, me_times = 0.0, 0.0, 0.0\n    mvr_powers, mvr_fdrs, mvr_times = 0.0, 0.0, 0.0\n    ipad_er_powers, ipad_er_fdrs, ipad_er_times = 0.0, 0.0, 0.0\n    ipad_gr_powers, ipad_gr_fdrs, ipad_gr_times = 0.0, 0.0, 0.0\n    ipad_ve_powers, ipad_ve_fdrs, ipad_ve_times = 0.0, 0.0, 0.0\n\n    for seed in 1:nsims\n        # simulate X\n        Random.seed!(seed)\n        X = rand(MvNormal(Σ), n)' |> Matrix\n        zscore!(X, mean(X, dims=1), std(X, dims=1));\n\n        # simulate y\n        Random.seed!(seed)\n        βtrue = zeros(p)\n        βtrue[1:k] .= rand(-1:2:1, k) .* randn(k)\n        shuffle!(βtrue)\n        ϵ = randn(n)\n        y = X * βtrue + ϵ\n        μ = zeros(p)\n        correct_position = findall(!iszero, βtrue)\n\n        # ipad with ER\n        Random.seed!(seed)\n        ipad_er_t = @elapsed ipad_er = ipad(X, r_method = :er, m = m)\n        ipad_er_ko_filter = fit_lasso(y, ipad_er)\n        selected = ipad_er_ko_filter.selected[3]\n        ipad_er_power = length(selected ∩ correct_position) / k\n        ipad_er_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        #ipad with GR\n        Random.seed!(seed)\n        ipad_gr_t = @elapsed ipad_gr = ipad(X, r_method = :gr, m = m)\n        ipad_gr_ko_filter = fit_lasso(y, ipad_gr)\n        selected = ipad_gr_ko_filter.selected[3]\n        ipad_gr_power = length(selected ∩ correct_position) / k\n        ipad_gr_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # ipad with VE\n        Random.seed!(seed)\n        ipad_ve_t = @elapsed ipad_ve = ipad(X, r_method = :ve, m = m)\n        ipad_ve_ko_filter = fit_lasso(y, ipad_ve)\n        selected = ipad_ve_ko_filter.selected[3]\n        ipad_ve_power = length(selected ∩ correct_position) / k\n        ipad_ve_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # ME knockoffs\n        Random.seed!(seed)\n        me_t = @elapsed me = modelX_gaussian_knockoffs(X, :maxent, m = m)\n        me_ko_filter = fit_lasso(y, me)\n        selected = me_ko_filter.selected[3]\n        me_power = length(selected ∩ correct_position) / k\n        me_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # MVR knockoffs\n        Random.seed!(seed)\n        mvr_t = @elapsed mvr = modelX_gaussian_knockoffs(X, :mvr, m = m)\n        mvr_ko_filter = fit_lasso(y, mvr)\n        selected = mvr_ko_filter.selected[3]\n        mvr_power = length(selected ∩ correct_position) / k\n        mvr_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # SDP (ccd) knockoffs\n        Random.seed!(seed)\n        sdp_t = @elapsed sdp = modelX_gaussian_knockoffs(X, :sdp_ccd, m = m)\n        sdp_ko_filter = fit_lasso(y, sdp)\n        selected = sdp_ko_filter.selected[3]\n        sdp_power = length(selected ∩ correct_position) / k\n        sdp_fdr = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n\n        # record results\n        println(\"ipad ER: power = $ipad_er_power, FDR = $ipad_er_fdr, rank = $(ipad_er.r), time = $(round(ipad_er_t, digits=3))\")\n        println(\"ipad GR: power = $ipad_gr_power, FDR = $ipad_gr_fdr, rank = $(ipad_gr.r), time = $(round(ipad_gr_t, digits=3))\")\n        println(\"ipad VE: power = $ipad_ve_power, FDR = $ipad_ve_fdr, rank = $(ipad_ve.r), time = $(round(ipad_ve_t, digits=3))\")\n        println(\"ME: power = $me_power, FDR = $me_fdr, time = $(round(me_t, digits=3))\")\n        println(\"MVR: power = $mvr_power, FDR = $mvr_fdr, time = $(round(mvr_t, digits=3))\")\n        println(\"SDP: power = $sdp_power, FDR = $sdp_fdr, time = $(round(sdp_t, digits=3))\\n\\n\")\n        sdp_powers += sdp_power\n        sdp_fdrs += sdp_fdr\n        sdp_times += sdp_t\n        me_powers += me_power\n        me_fdrs += me_fdr\n        me_times += me_t\n        mvr_powers += mvr_power\n        mvr_fdrs += mvr_fdr\n        mvr_times += mvr_t\n        ipad_er_powers += ipad_er_power\n        ipad_er_fdrs += ipad_er_fdr\n        ipad_er_times += ipad_er_t\n        ipad_gr_powers += ipad_gr_power\n        ipad_gr_fdrs += ipad_gr_fdr\n        ipad_gr_times += ipad_gr_t\n        ipad_ve_powers += ipad_ve_power\n        ipad_ve_fdrs += ipad_ve_fdr\n        ipad_ve_times += ipad_ve_t\n    end\n    \n    # compute average\n    ipad_er_powers /= nsims\n    ipad_er_fdrs /= nsims\n    ipad_er_times /= nsims\n    ipad_gr_powers /= nsims\n    ipad_gr_fdrs /= nsims\n    ipad_gr_times /= nsims\n    ipad_ve_powers /= nsims\n    ipad_ve_fdrs /= nsims\n    ipad_ve_times /= nsims\n    me_powers /= nsims\n    me_fdrs /= nsims\n    me_times /= nsims\n    mvr_powers /= nsims\n    mvr_fdrs /= nsims\n    mvr_times /= nsims\n    sdp_powers /= nsims\n    sdp_fdrs /= nsims\n    sdp_times /= nsims\n    \n    # save in dataframe\n    result = DataFrame(\n        method=[\"IPAD-er\", \"IPAD-gr\", \"IPAD-ve\", \"ME\", \"MVR\", \"SDP\"],\n        power=[ipad_er_powers,ipad_gr_powers,ipad_ve_powers,me_powers,mvr_powers,sdp_powers], \n        FDR=[ipad_er_fdrs,ipad_gr_fdrs,ipad_ve_fdrs,me_fdrs,mvr_fdrs,sdp_fdrs], \n        time=[ipad_er_times,ipad_gr_times,ipad_ve_times,me_times,mvr_times,sdp_times]\n    )\n\n    return result\nend\n\nnsims = 10\nresult = compare_ipad3(nsims);","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"ipad ER: power = 0.54, FDR = 0.5645161290322581, rank = 1, time = 0.036\nipad GR: power = 0.54, FDR = 0.5645161290322581, rank = 1, time = 0.03\nipad VE: power = 0.54, FDR = 0.578125, rank = 90, time = 0.033\nME: power = 0.32, FDR = 0.1111111111111111, time = 6.315\nMVR: power = 0.32, FDR = 0.1111111111111111, time = 6.39\nSDP: power = 0.34, FDR = 0.05555555555555555, time = 22.637\n\n\nipad ER: power = 0.28, FDR = 0.6818181818181818, rank = 1, time = 0.036\nipad GR: power = 0.28, FDR = 0.6818181818181818, rank = 1, time = 0.035\nipad VE: power = 0.28, FDR = 0.6888888888888889, rank = 91, time = 0.029\nME: power = 0.2, FDR = 0.0, time = 7.001\nMVR: power = 0.2, FDR = 0.0, time = 6.373\nSDP: power = 0.24, FDR = 0.0, time = 22.658\n\n\nipad ER: power = 0.46, FDR = 0.43902439024390244, rank = 1, time = 0.029\nipad GR: power = 0.46, FDR = 0.43902439024390244, rank = 1, time = 0.029\nipad VE: power = 0.46, FDR = 0.4772727272727273, rank = 90, time = 0.029\nME: power = 0.44, FDR = 0.12, time = 6.205\nMVR: power = 0.46, FDR = 0.14814814814814814, time = 6.395\nSDP: power = 0.5, FDR = 0.24242424242424243, time = 22.824\n\n\nipad ER: power = 0.32, FDR = 0.5151515151515151, rank = 1, time = 0.039\nipad GR: power = 0.32, FDR = 0.5151515151515151, rank = 1, time = 0.039\nipad VE: power = 0.32, FDR = 0.5294117647058824, rank = 91, time = 0.042\nME: power = 0.28, FDR = 0.0, time = 6.303\nMVR: power = 0.32, FDR = 0.058823529411764705, time = 6.45\nSDP: power = 0.44, FDR = 0.2903225806451613, time = 22.526\n\n\nipad ER: power = 0.46, FDR = 0.41025641025641024, rank = 1, time = 0.028\nipad GR: power = 0.46, FDR = 0.41025641025641024, rank = 1, time = 0.027\nipad VE: power = 0.46, FDR = 0.425, rank = 91, time = 0.034\nME: power = 0.42, FDR = 0.16, time = 6.166\nMVR: power = 0.42, FDR = 0.16, time = 6.561\nSDP: power = 0.44, FDR = 0.12, time = 23.091\n\n\nipad ER: power = 0.56, FDR = 0.4716981132075472, rank = 1, time = 0.028\nipad GR: power = 0.56, FDR = 0.4716981132075472, rank = 1, time = 0.044\nipad VE: power = 0.56, FDR = 0.4716981132075472, rank = 90, time = 0.04\nME: power = 0.46, FDR = 0.11538461538461539, time = 6.062\nMVR: power = 0.42, FDR = 0.08695652173913043, time = 6.837\nSDP: power = 0.48, FDR = 0.14285714285714285, time = 23.626\n\n\nipad ER: power = 0.32, FDR = 0.627906976744186, rank = 1, time = 0.062\nipad GR: power = 0.32, FDR = 0.627906976744186, rank = 1, time = 0.046\nipad VE: power = 0.34, FDR = 0.6304347826086957, rank = 89, time = 0.05\nME: power = 0.0, FDR = 0.0, time = 6.593\nMVR: power = 0.0, FDR = 0.0, time = 7.597\nSDP: power = 0.0, FDR = 0.0, time = 22.777\n\n\nipad ER: power = 0.42, FDR = 0.6181818181818182, rank = 1, time = 0.029\nipad GR: power = 0.42, FDR = 0.6181818181818182, rank = 1, time = 0.044\nipad VE: power = 0.42, FDR = 0.6666666666666666, rank = 90, time = 0.069\nME: power = 0.2, FDR = 0.23076923076923078, time = 6.604\nMVR: power = 0.2, FDR = 0.23076923076923078, time = 6.423\nSDP: power = 0.2, FDR = 0.16666666666666666, time = 23.46\n\n\nipad ER: power = 0.58, FDR = 0.4727272727272727, rank = 1, time = 0.067\nipad GR: power = 0.58, FDR = 0.4727272727272727, rank = 1, time = 0.031\nipad VE: power = 0.58, FDR = 0.48214285714285715, rank = 90, time = 0.096\nME: power = 0.32, FDR = 0.0, time = 6.368\nMVR: power = 0.3, FDR = 0.0, time = 6.641\nSDP: power = 0.42, FDR = 0.0, time = 22.832\n\n\nipad ER: power = 0.36, FDR = 0.4857142857142857, rank = 1, time = 0.044\nipad GR: power = 0.36, FDR = 0.4857142857142857, rank = 1, time = 0.045\nipad VE: power = 0.36, FDR = 0.4857142857142857, rank = 91, time = 0.04\nME: power = 0.28, FDR = 0.0, time = 6.269\nMVR: power = 0.28, FDR = 0.0, time = 6.526\nSDP: power = 0.4, FDR = 0.09090909090909091, time = 23.831","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"@show result;","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"result = 6×4 DataFrame\n Row │ method   power    FDR        time\n     │ String   Float64  Float64    Float64\n─────┼─────────────────────────────────────────\n   1 │ IPAD-er    0.43   0.5287      0.0398029\n   2 │ IPAD-gr    0.43   0.5287      0.0370067\n   3 │ IPAD-ve    0.432  0.543536    0.0462691\n   4 │ ME         0.292  0.0737265   6.38856\n   5 │ MVR        0.292  0.0795809   6.61936\n   6 │ SDP        0.346  0.110874   23.0262","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"Summary (when X is simulated based on real data)","category":"page"},{"location":"man/ipad/","page":"IPAD Knockoffs","title":"IPAD Knockoffs","text":"IPAD methods have extremely inflated FDR (target = 10%)\nmodel-X Knockoffs control FDR","category":"page"},{"location":"man/modelX/modelX/#Model-X-knockoffs","page":"Model-X Knockoffs","title":"Model-X knockoffs","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"This tutorial is for generating model-X (Gaussian) knockoffs, which handles cases where covariates outnumber sample size (p  n). The methodology is described in the following paper","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Candes E, Fan Y, Janson L, Lv J. Panning for gold:‘model‐X’knockoffs for high dimensional controlled variable selection. Journal of the Royal Statistical Society: Series B (Statistical Methodology). 2018 Jun;80(3):551-77.","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"# load packages needed for this tutorial\nusing Knockoffs\nusing Random\nusing GLMNet\nusing Distributions\nusing LinearAlgebra\nusing ToeplitzMatrices\nusing StatsKit\nusing Plots\ngr(fmt=:png);","category":"page"},{"location":"man/modelX/modelX/#Gaussian-model-X-knockoffs-with-known-mean-and-covariance","page":"Model-X Knockoffs","title":"Gaussian model-X knockoffs with known mean and covariance","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"To illustrate, lets simulate data mathbfX with covariance Sigma and mean mu. Our model is","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"beginaligned\n    X_p times 1 sim N(mathbf0_p Sigma)\nendaligned","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"where","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"beginaligned\nSigma = \nbeginpmatrix\n    1  rho  rho^2    rho^p\n    rho  1     rho^p-1\n    vdots    1  vdots \n    rho^p  cdots    1\nendpmatrix\nendaligned","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Given n iid samples from the above distribution, we will generate knockoffs according to ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"beginaligned\n(X tildeX) sim N\nleft(0  \nbeginpmatrix\n    Sigma  Sigma - diag(s)\n    Sigma - diag(s)  Sigma\nendpmatrix\nright)\nendaligned","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"where s is solved so that 0 le s_j le Sigma_jj for all j and 2Σ - diag(s) is PSD. ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Random.seed!(2022)\nn = 500 # sample size\np = 1000 # number of covariates\nρ = 0.4\nΣ = Matrix(SymmetricToeplitz(ρ.^(0:(p-1)))) # true covariance matrix\nμ = zeros(p) # true mean parameters\nL = cholesky(Σ).L\nX = randn(n, p) * L # var(X) = L var(N(0, 1)) L' = var(Σ)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"500×1000 Matrix{Float64}:\n -0.255643    0.12145      1.90832   …  -0.425334  -0.0875185  -1.26044\n  1.21857    -1.04975     -1.93608       0.986266   0.495375    0.526645\n -0.489054   -0.325137    -0.389752     -0.54062   -0.765207   -0.925541\n  1.13077     0.715132     0.115053     -0.866809   0.835603    1.41018\n -2.06667    -0.799976     0.104784     -1.10473   -1.53618    -1.48403\n -0.692878   -1.04012     -0.711309  …   0.117786   0.419314    1.05\n  0.605767   -0.220341    -0.62107       1.36572   -0.454627   -0.226038\n -0.156307    0.0225261   -0.117329      1.06143    1.35028     1.0699\n  0.443743    2.41354      0.635028      0.744278   0.229644   -0.640157\n  0.710929    0.0527427    1.35858       1.06147   -0.142669   -1.67164\n  0.785485    1.72134     -1.02638   …  -0.222289  -0.903092   -0.237564\n -0.0330742   1.02192      0.367135     -0.412167   0.127533   -0.0828143\n -2.01006    -0.858529    -0.817414      1.52695    1.67114     2.15544\n  ⋮                                  ⋱                         \n -0.324703    0.476295     0.106425     -1.06599   -1.88418    -1.02433\n -0.811388    0.00190805  -1.16822       0.780591   1.11014    -0.208461\n -0.184579    0.344966    -0.648001  …   1.21303   -0.403468   -2.11791\n  1.27172     2.03987      1.4584       -0.819745   0.0938613   0.114038\n -0.688407    0.0815265   -0.503051      0.283407  -1.10525     0.131074\n -0.892244   -0.184611    -0.746692     -0.87555   -2.00235    -0.291364\n  1.57011     0.315036     1.35995       0.582807  -0.68021    -1.27912\n -0.503994   -1.70271     -0.186807  …  -0.67245   -1.07302    -0.755238\n -0.437047    0.27435     -0.821421     -1.33403   -0.368807   -0.0284317\n -2.81068    -0.361046     1.19981      -1.29837   -0.151723    1.00562\n -1.54038     0.403661     0.545421      0.728631  -1.2155      0.577002\n  0.194411    0.885717     0.54569      -0.753762  -1.55452    -0.416219","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"To generate model-X knockoffs,","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"The 4 argument function modelX_gaussian_knockoffs will generate exact model-X knockoffs. \nFirst argument is the design matrix X. \nThe second argument specifies the optimization method to generate knockoffs. We recommend :mvr or :maxent because they are more efficient to compute and tend to be more powerful than the SDP construction. \nThe 3rd and 4th argument supplies the true mean and covariance of features.","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"# for larger problems, consider including `verbose=true` argument to monitor convergence\n@time equi = modelX_gaussian_knockoffs(X, :equi, μ, Σ)\n@time mvr = modelX_gaussian_knockoffs(X, :mvr, μ, Σ)\n@time me = modelX_gaussian_knockoffs(X, :maxent, μ, Σ);","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"  8.064953 seconds (17.21 M allocations: 933.741 MiB, 1.84% gc time, 99.02% compilation time)\n  3.375101 seconds (59 allocations: 100.117 MiB, 1.45% gc time)\n  1.909561 seconds (57 allocations: 100.102 MiB)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"The return type is a GaussianKnockoff struct, which contains the following fields","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"struct GaussianKnockoff{T<:AbstractFloat, M<:AbstractMatrix, S <: Symmetric} <: Knockoff\n    X::M # n × p design matrix\n    Xko::Matrix{T} # n × mp knockoff of X\n    s::Vector{T} # p × 1 vector. Diagonal(s) and 2Sigma - Diagonal(s) are both psd\n    Sigma::S # p × p symmetric covariance matrix. \n    method::Symbol # method for solving s\n    m::Int # number of knockoffs per feature generated\nend","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Thus, to access these fields, one can do e.g.","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"s = mvr.s","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"1000-element Vector{Float64}:\n 0.7055844308562433\n 0.550600272751968\n 0.5579639876207405\n 0.5578996993527637\n 0.557883689440236\n 0.5578849315291078\n 0.5578848927508967\n 0.5578848919247213\n 0.5578848920850612\n 0.557884892075635\n 0.557884892074806\n 0.5578848920738697\n 0.5578848920729174\n ⋮\n 0.5578848730690327\n 0.5578848733890451\n 0.5578848767064315\n 0.5578848743329564\n 0.5578848745291356\n 0.557884875752427\n 0.5578849142012816\n 0.5578836722536301\n 0.5578996821189737\n 0.557963970313357\n 0.5506002575404055\n 0.7055843980219556","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"# compare s values for different methods\n[me.s mvr.s equi.s]","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"1000×3 Matrix{Float64}:\n 0.760607  0.705584  0.857145\n 0.599795  0.5506    0.857145\n 0.611403  0.557964  0.857145\n 0.610539  0.5579    0.857145\n 0.610604  0.557884  0.857145\n 0.610599  0.557885  0.857145\n 0.610599  0.557885  0.857145\n 0.610599  0.557885  0.857145\n 0.610599  0.557885  0.857145\n 0.610599  0.557885  0.857145\n 0.610599  0.557885  0.857145\n 0.610599  0.557885  0.857145\n 0.610599  0.557885  0.857145\n ⋮                   \n 0.610599  0.557885  0.857145\n 0.610599  0.557885  0.857145\n 0.610599  0.557885  0.857145\n 0.610599  0.557885  0.857145\n 0.610599  0.557885  0.857145\n 0.610599  0.557885  0.857145\n 0.610599  0.557885  0.857145\n 0.610603  0.557884  0.857145\n 0.610539  0.5579    0.857145\n 0.611403  0.557964  0.857145\n 0.599795  0.5506    0.857145\n 0.760607  0.705584  0.857145","category":"page"},{"location":"man/modelX/modelX/#Second-order-knockoffs","page":"Model-X Knockoffs","title":"Second order knockoffs","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"In practice, one usually do not have access to true mean \\mu and covariance \\Sigma. Thus, we provide routines to estimate them from data. In our software, the covariance is approximated by a shrinkage method (default = ledoit wolf) rather than using the sample covariance, see API for detail. ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"The 2 argument modelX_gaussian_knockoffs will estimate the mean and covariance of X and use them to generate model-X knockoffs","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"# make 2nd order knockoffs\n@time me_2nd_order = modelX_gaussian_knockoffs(X, :maxent);","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"  2.210275 seconds (3.37 M allocations: 317.416 MiB, 3.50% gc time, 24.69% compilation time)","category":"page"},{"location":"man/modelX/modelX/#Approximate-construction-for-speed","page":"Model-X Knockoffs","title":"Approximate construction for speed","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Generating model-X knockoffs scales as mathcalO(p^3) with coordinate descent (e.g. sdp_fast, mvr, maxent), which becomes prohibitively slow for large p (e.g. p = 5000). ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Sometimes one expects that covariates are only correlated with its nearby neighbors. Then, we can approximate the covariance matrix as a block diagonal structure with block size windowsize, and solve each block independently as smaller problems. This is implemented as approx_modelX_gaussian_knockoffs","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"@time me_approx = approx_modelX_gaussian_knockoffs(X, :maxent, windowsize=100);","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"  4.548431 seconds (16.01 M allocations: 1.061 GiB, 4.17% gc time, 93.69% compilation time)","category":"page"},{"location":"man/modelX/modelX/#Multiple-knockoffs","page":"Model-X Knockoffs","title":"Multiple knockoffs","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Gimenez et al suggested multiple simultaneous knockoffs, which can give a boost in power when the target FDR or the number of variables to select are low. ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"If one generated m knockoffs for each of the p variables, the convex optimization problem in solving for diagonal S matrix is equally efficient as in the single-knockoff case, but the subsequent model selection would have (m + 1) * p columns as opposed to 2p columns in the single-knockoff case. Thus, both computational speed and memory demand scales roughly linearly in m. ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"m = 5\n@time me_multiple = modelX_gaussian_knockoffs(X, :maxent, μ, Σ, m=m);","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"  3.006152 seconds (2.68 k allocations: 775.460 MiB, 14.50% gc time, 0.17% compilation time)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"As a sanity check, lets make sure the modified SDP constraint is satisfied","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"eigmin((m+1)/m * Σ - Diagonal(me_multiple.s))","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"0.14792714564321696","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Finally, we can compare the s vector estimated from all 4 methods.","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"[me.s me_2nd_order.s me_approx.s me_multiple.s]","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"1000×4 Matrix{Float64}:\n 0.760607  0.993382  0.846479  0.456365\n 0.599795  0.83418   0.644484  0.359877\n 0.611403  1.05053   0.787572  0.366842\n 0.610539  0.958254  0.722984  0.366324\n 0.610604  0.882614  0.690845  0.366362\n 0.610599  0.896145  0.706702  0.366359\n 0.610599  0.95216   0.715815  0.36636\n 0.610599  0.858501  0.636454  0.36636\n 0.610599  0.938511  0.70445   0.36636\n 0.610599  0.921345  0.715783  0.36636\n 0.610599  0.956845  0.698709  0.36636\n 0.610599  0.97871   0.723473  0.36636\n 0.610599  0.915263  0.688165  0.36636\n ⋮                             \n 0.610599  0.917573  0.708208  0.36636\n 0.610599  0.92724   0.712444  0.36636\n 0.610599  0.982501  0.7634    0.36636\n 0.610599  0.860957  0.680147  0.36636\n 0.610599  1.02923   0.774822  0.36636\n 0.610599  1.01452   0.751665  0.36636\n 0.610599  0.941284  0.710888  0.366359\n 0.610603  0.999975  0.755369  0.366362\n 0.610539  0.86102   0.660549  0.366324\n 0.611403  0.969511  0.786857  0.366842\n 0.599795  0.861765  0.685225  0.359877\n 0.760607  0.739856  0.613179  0.456364","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"In this example, they are quite different.","category":"page"},{"location":"man/modelX/modelX/#LASSO-example","page":"Model-X Knockoffs","title":"LASSO example","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Let us apply the generated knockoffs to the model selection problem","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Given response mathbfy_n times 1, design matrix mathbfX_n times p, we want to select a subset S subset 1p of variables that are truly causal for mathbfy. ","category":"page"},{"location":"man/modelX/modelX/#Simulate-data","page":"Model-X Knockoffs","title":"Simulate data","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"We will simulate ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"mathbfy sim N(mathbfXmathbfbeta mathbfepsilon) quad mathbfepsilon sim N(0 1)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"where k=50 positions of mathbfbeta is non-zero with effect size beta_j sim N(0 1). The goal is to recover those 50 positions using LASSO.","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"# set seed for reproducibility\nRandom.seed!(123)\n\n# simulate true beta\nn, p = size(X)\nk = 50\nβtrue = zeros(p)\nβtrue[1:k] .= randn(k)\nshuffle!(βtrue)\n\n# find true causal variables\ncorrect_position = findall(!iszero, βtrue)\n\n# simulate y\ny = X * βtrue + randn(n)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"500-element Vector{Float64}:\n -16.138781364984787\n  -5.287542411651397\n  18.027692775987678\n  -4.140794496081527\n   4.223445068157524\n   8.237597611236556\n  -8.800473194308873\n  12.138035964379569\n  -5.291660763277003\n   0.1763453121292271\n  12.719488833739977\n  -8.398513822600917\n  -1.9198345300850481\n   ⋮\n  -3.771806541112785\n   0.5681365432035446\n  -0.5397047794787977\n  -0.700940301452057\n  -7.850480614685315\n  -6.200339809747463\n  -9.87399476750332\n   2.219038357726496\n   4.788196033460055\n   4.61565606038031\n  -5.4031821003145595\n  -7.35857531035862","category":"page"},{"location":"man/modelX/modelX/#Standard-LASSO","page":"Model-X Knockoffs","title":"Standard LASSO","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Lets try running standard LASSO. We use LASSO solver in GLMNet.jl package, which is just a Julia wrapper for the GLMnet Fortran code. ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"How does it perform in power and FDR?","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"# run 10-fold cross validation to find best λ minimizing MSE\nlasso_cv = glmnetcv(X, y)\nλbest = lasso_cv.lambda[argmin(lasso_cv.meanloss)]\n\n# use λbest to fit LASSO on full data\nβlasso = glmnet(X, y, lambda=[λbest]).betas[:, 1]\n\n# check power and false discovery rate\npower = length(findall(!iszero, βlasso) ∩ correct_position) / k\nFDR = length(setdiff(findall(!iszero, βlasso), correct_position)) / count(!iszero, βlasso)\nprintln(\"Lasso power = $power, FDR = $FDR\")","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Lasso power = 0.96, FDR = 0.6619718309859155","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"More than half of all Lasso discoveries are false positives. ","category":"page"},{"location":"man/modelX/modelX/#KnockoffLASSO","page":"Model-X Knockoffs","title":"Knockoff+LASSO","text":"","category":"section"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Now lets try applying the knockoff methodology. Recall that consists of a few steps ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Run LASSO on mathbfX mathbftildeX\nCompare feature importance score W_j = textscore(x_j) - textscore(tildex_j) for each j = 1p. Here we use W_j = beta_j - tildebeta_j\nChoose target FDR q in 0 1 and compute ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"tau = min_tleftt  0 fracj W_j  -tmax(1 j W_j  t) le qright","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"The fit_lasso function generates knockoffs, run Lasso on mathbfX mathbftildeX, and apply knockoff filter.","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"@time knockoff_filter = fit_lasso(y, X, method=:maxent, m=1);","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"  3.506669 seconds (2.00 M allocations: 381.947 MiB, 1.03% gc time, 10.43% compilation time)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"The return type is now a LassoKnockoffFilter, which contains the following information","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"struct LassoKnockoffFilter{T} <: KnockoffFilter\n    y :: Vector{T} # n × 1 response vector\n    X :: Matrix{T} # n × p matrix of original features\n    ko :: Knockoff # A knockoff struct\n    m :: Int # number of knockoffs per feature generated\n    betas :: Vector{Vector{T}} # betas[i] is the p × 1 vector of effect sizes corresponding to fdr level fdr_target[i]\n    a0 :: Vector{T}   # intercepts for each model in betas\n    selected :: Vector{Vector{Int}} # selected[i] includes all variables selected based on target FDR level fdr_target[i]\n    W :: Vector{T} # length p vector of feature importance\n    taus :: Vector{T} # threshold for significance. For fdr fdr_target[i], tau[i] is threshold, and all W ≥ tau[i] is selected\n    fdr_target :: Vector{T} # target FDR level for each taus and betas\n    d :: UnivariateDistribution # distribution of y\n    debias :: Union{Nothing, Symbol} # how betas and a0 have been debiased (`nothing` for not debiased)\nend","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Lets do 10 simulations and visualize power and FDR trade-off:","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"# run 10 simulations and compute empirical power/FDR\nnsims = 10\nempirical_power = zeros(5)\nempirical_fdr = zeros(5)\nfor i in 1:nsims\n    @time knockoff_filter = fit_lasso(y, X, method=:mvr)\n    for i in eachindex(knockoff_filter.fdr_target)\n        selected = knockoff_filter.selected[i]\n        power = length(selected ∩ correct_position) / k\n        fdp = length(setdiff(selected, correct_position)) / max(length(selected), 1)\n        empirical_power[i] += power\n        empirical_fdr[i] += fdp\n    end\nend\nempirical_power ./= nsims\nempirical_fdr ./= nsims\n\n# visualize FDR and power\npower_plot = plot(FDR, empirical_power, xlabel=\"Target FDR\", ylabel=\"Empirical power\", legend=false, w=2)\nfdr_plot = plot(FDR, empirical_fdr, xlabel=\"Target FDR\", ylabel=\"Empirical FDR\", legend=false, w=2)\nPlots.abline!(fdr_plot, 1, 0, line=:dash)\nplot(power_plot, fdr_plot)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"  3.640497 seconds (40.55 k allocations: 286.264 MiB, 0.90% gc time, 0.32% compilation time)\n  3.579325 seconds (907 allocations: 284.040 MiB, 0.21% gc time)\n  3.590901 seconds (907 allocations: 284.040 MiB, 0.25% gc time)\n  3.575671 seconds (907 allocations: 284.040 MiB, 0.23% gc time)\n  3.570982 seconds (907 allocations: 284.040 MiB, 0.19% gc time)\n  3.570007 seconds (907 allocations: 284.040 MiB, 0.15% gc time)\n  3.577488 seconds (907 allocations: 284.040 MiB, 0.17% gc time)\n  3.614974 seconds (907 allocations: 284.040 MiB, 0.18% gc time)\n  3.567592 seconds (907 allocations: 284.040 MiB, 0.19% gc time)\n  3.588125 seconds (907 allocations: 284.040 MiB, 0.13% gc time)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"Conclusion: ","category":"page"},{"location":"man/modelX/modelX/","page":"Model-X Knockoffs","title":"Model-X Knockoffs","text":"LASSO + knockoffs controls the false discovery rate at below the target (dashed line). \nThe power of standard LASSO is better, but it comes with high empirical FDR that one cannot control via cross validation. \nIf one does not have the true mean and covariance of the p dimensional covariates, Knockoffs.jl will estimate them with sample mean and a shrunken (default = ledoit wolf) estimator. \nMultiple simultaneous knockoffs increases power at the expensive of larger regression problem. \nApproximate constructions can be leveraged for extremely large problems, e.g. p  10000. ","category":"page"},{"location":"man/hmm/hmm/#HMM-Knockoffs","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"warning: Warning\nHMM Knockoffs are provided as experimental features! fastPHASE HMM knockoffs relies on fastPHASE.jl which only works on linux and Mac machines (Intel or Rosetta). SHAPEIT HMM knockoffs relies on a non-Julia software RaPID for detecting IBD segments, which only run on linux. ","category":"page"},{"location":"man/hmm/hmm/#fastPHASE-HMM-knockoffs","page":"HMM Knockoffs","title":"fastPHASE HMM knockoffs","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"The first example, we generate fastPHASE HMM knockoffs for genome-wide association studies. This kind of knockoffs is suitable for data without population admixture or cryptic relatedness. The methodology is described in the following paper:","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Sesia, Matteo, Chiara Sabatti, and Emmanuel J. Candès. \"Gene hunting with hidden Markov model knockoffs.\" Biometrika 106.1 (2019): 1-18.","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"If your samples have diverse ancestries and/or extensive relatedness, we recommend those samples to be filtered out, or use SHAPEIT-HMM knockoffs.","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# first load packages needed for this tutorial\nusing Revise\nusing SnpArrays\nusing Knockoffs\nusing Statistics\nusing Plots\nusing GLMNet\nusing Distributions\nusing Random\nusing fastPHASE\ngr(fmt=:png);","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mPrecompiling Knockoffs [878bf26d-0c49-448a-9df5-b057c815d613]\n\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mPrecompiling Plots [91a5bcdd-55d7-5caf-9e0b-520d859cae80]\n\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mbackend `GR` is not installed.\n\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ Plots ~/.julia/packages/Plots/tDHxD/src/backends.jl:43\u001b[39m","category":"page"},{"location":"man/hmm/hmm/#Step-0:-Prepare-example-data","page":"HMM Knockoffs","title":"Step 0: Prepare example data","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"To illustrate we need example PLINK data, which are available in the data directory to where Knockoffs.jl was installed. ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"test.(bed/bim/fam) are simulated genotypes without missings\nmouse.imputed.(bed/bim/fam) are real genotypes without missing","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# path to PLINK data\ndata_path = normpath(Knockoffs.datadir())","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"\"/Users/biona001/.julia/dev/Knockoffs/data\"","category":"page"},{"location":"man/hmm/hmm/#Step-1:-Generate-Knockoffs","page":"HMM Knockoffs","title":"Step 1: Generate Knockoffs","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Knockoffs are made using the wrapper function hmm_knockoff. This function does 3 steps sequentially:","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Run fastPHASE on mathbfX_ntimes p to estimate alpha theta r (this step takes 5-10 min for the example data). Note we provide a simple wrapper fastPHASE.jl which we use here, but the original software, and hence our wrapper, does not support windows machines or Mac with M series processors. \nFit and generate knockoff copies of the HMM \nStore knockoffs tildemathbfX_ntimes p in binary PLINK format (by default under a new directory called knockoffs) and return it as a SnpArray","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# import PLINK data (test.bed, test.bim, and test.fam)\nsnpdata = SnpData(joinpath(data_path, \"test\"))\n\n# estimate fastPHASE HMM parameters\nr, θ, α = fastphase_estim_param(snpdata)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"seed = 1683238677\n\nThis is fastPHASE 1.4.8\n\nCopyright 2005-2006.  University of Washington. All rights reserved.\nWritten by Paul Scheet, with algorithm developed by Paul Scheet and\nMatthew Stephens in the Department of Statistics at the University of\nWashington.  Please contact pscheet@alum.wustl.edu for questions, or to\nobtain the software visit\nhttp://stephenslab.uchicago.edu/software.html\n\nTotal proportion of missing genotypes: 0.000000\n1000 diploids below missingness threshold, 0 haplotypes\n data read successfully\n1000 diploid individuals, 10000 loci\n\nK selected (by user): \t\t 12\nseed: \t\t\t 1\nno. EM starts: \t\t 1\nEM iterations: \t\t 10\nno. haps from posterior: 0\nNOT using subpopulation labels\n\n\n this is random start no. 1 of 1 for the EM...\n\nseed for this start: 1\n-12448937.79229315\n-9445075.64492578\n-8349084.94704032\n-7261896.43613014\n-6281741.47324536\n-5576823.19655063\n-5155151.87406101\n-4928193.53344398\n-4802495.92350104\n-4725979.88580363\nfinal loglikelihood: -4676003.575106\niterations: 10\n\nwriting parameter estimates to disk\n\n  simulating 0 haplotype configurations for each individual... done.\n\n\n\n\n\nsimulating 0 haplotypes from model: /Users/biona001/.julia/dev/Knockoffs/docs/src/man/tmp1_hapsfrommodel.out\n\n\n\n\n\n([1.0, 4.27174e-5, 7.86409e-5, 0.0001558163, 0.0001951641, 4.94156e-5, 3.25535e-5, 2.03465e-5, 6.29918e-5, 0.0149603794  …  1.169e-7, 1.0204e-6, 8.9106e-6, 4.31966e-5, 1.70696e-5, 1.57453e-5, 9.3809e-6, 3.60957e-5, 8.69709e-5, 0.0002070214], [0.001 0.001 … 0.001 0.999; 0.001 0.001 … 0.001 0.512408; … ; 0.999 0.999 … 0.999 0.0010000000000000009; 0.999 0.999 … 0.0010000000000000009 0.564578], [0.08277 0.078799 … 0.083905 0.086073; 0.08277 0.078799 … 0.083905 0.086073; … ; 0.08277 0.078799 … 0.083905 0.086073; 0.08277 0.078799 … 0.083905 0.086073])","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# Sample HMM knockoffs\nXko = hmm_knockoff(snpdata, r, θ, α)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"\u001b[32mProgress: 100%|█████████████████████████████████████████| Time: 0:01:24\u001b[39m\n\n\n\n\n\n1000×10000 SnpArray:\n 0x00  0x00  0x03  0x03  0x00  0x03  …  0x03  0x03  0x03  0x02  0x03  0x02\n 0x00  0x00  0x02  0x03  0x00  0x00     0x02  0x02  0x02  0x02  0x02  0x02\n 0x00  0x00  0x02  0x03  0x02  0x02     0x02  0x03  0x00  0x00  0x02  0x03\n 0x00  0x00  0x00  0x00  0x00  0x02     0x02  0x02  0x02  0x02  0x00  0x00\n 0x00  0x02  0x02  0x02  0x03  0x02     0x02  0x00  0x00  0x00  0x03  0x03\n 0x00  0x00  0x02  0x02  0x02  0x00  …  0x03  0x03  0x03  0x02  0x03  0x02\n 0x00  0x00  0x03  0x03  0x00  0x02     0x03  0x00  0x02  0x02  0x03  0x03\n 0x02  0x02  0x03  0x02  0x00  0x02     0x03  0x03  0x03  0x02  0x03  0x03\n 0x02  0x00  0x02  0x02  0x00  0x02     0x03  0x03  0x02  0x02  0x00  0x00\n 0x00  0x03  0x02  0x02  0x03  0x00     0x03  0x03  0x03  0x00  0x00  0x00\n 0x00  0x02  0x02  0x03  0x03  0x02  …  0x03  0x03  0x03  0x03  0x00  0x02\n 0x02  0x02  0x02  0x02  0x00  0x00     0x02  0x02  0x02  0x02  0x02  0x02\n 0x00  0x00  0x03  0x03  0x02  0x02     0x02  0x02  0x02  0x02  0x00  0x00\n    ⋮                             ⋮  ⋱           ⋮                    \n 0x00  0x00  0x03  0x03  0x02  0x02     0x03  0x03  0x03  0x00  0x00  0x02\n 0x00  0x02  0x03  0x03  0x03  0x02     0x03  0x02  0x03  0x02  0x03  0x03\n 0x02  0x02  0x02  0x03  0x03  0x02  …  0x03  0x00  0x00  0x00  0x03  0x03\n 0x00  0x00  0x03  0x03  0x03  0x00     0x03  0x02  0x02  0x02  0x03  0x02\n 0x02  0x02  0x00  0x00  0x00  0x00     0x02  0x00  0x00  0x00  0x03  0x03\n 0x00  0x00  0x02  0x00  0x02  0x02     0x03  0x02  0x02  0x02  0x02  0x02\n 0x03  0x03  0x03  0x03  0x02  0x00     0x03  0x02  0x03  0x02  0x03  0x02\n 0x00  0x00  0x02  0x02  0x00  0x02  …  0x03  0x02  0x02  0x02  0x02  0x03\n 0x02  0x02  0x00  0x02  0x02  0x03     0x03  0x03  0x03  0x02  0x00  0x03\n 0x00  0x00  0x00  0x02  0x02  0x02     0x03  0x03  0x02  0x00  0x02  0x02\n 0x02  0x02  0x02  0x03  0x00  0x02     0x03  0x02  0x02  0x02  0x02  0x02\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x03  0x02","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"The result Xko is a SnpArray, a Julia data structure for representing PLINK .bed files efficiently. See SnpArrays.jl documentation for more detail.","category":"page"},{"location":"man/hmm/hmm/#Step-2:-Examine-knockoff-statistics","page":"HMM Knockoffs","title":"Step 2: Examine knockoff statistics","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Lets check if the knockoffs \"make sense\". We compare summary statistics using built-in functions compare_pairwise_correlation and compare_correlation","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# look at only pairwise correlation between first 200 snps\nX = snpdata.snparray\nr1, r2 = compare_pairwise_correlation(X, Xko, snps=200)\n\n# make plot\nscatter(r1, r2, xlabel = \"cor(Xi, Xj)\", ylabel=\"cor(Xi, X̃j)\", legend=false)\nPlots.abline!(1, 0, line=:dash)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Plots distribution of cor(X_j tildeX_j) for all j. Ideally, we want cor(X_j tildeX_j) to be small in magnitude (i.e. X and tildeX is very different). Here the knockoffs are tightly correlated with the original genotypes, so they will likely have low power. ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"r2 = compare_correlation(X, Xko)\nhistogram(r2, legend=false, xlabel=\"cor(Xi, X̃i)\", ylabel=\"count\")","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"(Image: png)","category":"page"},{"location":"man/hmm/hmm/#SHAPEIT-HMM-knockoffs","page":"HMM Knockoffs","title":"SHAPEIT HMM knockoffs","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"This page is a tutorial for generating (SHAPEIT) HMM knockoffs, which is good for controlling FDR in the presence of cryptic relatedness and diverse ancestries. The methodology is described in the following paper:","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Sesia, Matteo, et al. \"False discovery rate control in genome-wide association studies with population structure.\" Proceedings of the National Academy of Sciences 118.40 (2021). ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"This tutorial closely follows the original knockoffgwas tutorial. Currently users need to manually run and process various input/intermediate files, but eventually, we will write native Julia wrappers to circumvent these tedious procedures. Stay tuned. ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"note: Note\nIt is highly recommended to run this tutorial on linux machines, because RaPID (for detecting IBD segments) only run on linux. Currently users of windows and macOS machines must assume no IBD segments exist. ","category":"page"},{"location":"man/hmm/hmm/#Installation","page":"HMM Knockoffs","title":"Installation","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Install knockoffgwas and its dependencies\nInstall qctools for converting between VCF and BGEN formats\nInstall RaPID for detecting IBD segments (this only run on linux)\nInstall the following Julia packages. Within julia, type","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"]add SnpArrays Distributions ProgressMeter MendelIHT VCFTools StatsBase CodecZlib\n]add https://github.com/biona001/Knockoffs.jl","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Finally, modify these executable path to the ones installed on your local computer. Here the partition_exe is located under the path you installed knockoffgwas: knockoffgwas/knockoffgwas/utils/partition.R.","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"qctools_exe = \"/scratch/users/bbchu/qctool/build/release/qctool_v2.0.7\"\nsnpknock2_exe = \"/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2\"\nrapid_exe = \"/scratch/users/bbchu/RaPID/RaPID_v.1.7\"\npartition_exe = \"/scratch/users/bbchu/knockoffgwas/knockoffgwas/utils/partition.R\";","category":"page"},{"location":"man/hmm/hmm/#Required-inputs","page":"HMM Knockoffs","title":"Required inputs","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"We need multiple input files to generate knockoffs","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Unphased genotypes in binary PLINK format\nPhased genotypes in VCF and BGEN format: we will simulate haplotypes, store in VCF format, and convert to BGEN using qctools\nNote: knockoffgwas requires only BGEN format, but RaPID requires VCF formats. Hence, the extra conversion\nMap file (providing different group resolution): since data is simulated, we will generate fake map file\nIBD segment file (generated by RaPID which requires VCF inputs)\nVariant partition files (generated by snpknock2, i.e. module 2 of knockoffgwas) \nSample and variant QC files","category":"page"},{"location":"man/hmm/hmm/#Simulate-genotypes","page":"HMM Knockoffs","title":"Simulate genotypes","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Our simulation will try to follow","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Adding population structure (admixture & cryptic relatedness): New approaches to population stratification in genome-wide association studies\nHow to simulate siblings: Using Extended Genealogy to Estimate Components of Heritability for 23 Quantitative and Dichotomous Traits","category":"page"},{"location":"man/hmm/hmm/#Population-structure","page":"HMM Knockoffs","title":"Population structure","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Specifically, lets simulate genotypes with 2 populations. We simulate 49700 normally differentiated markers and 300 unusually differentiated markers based on allele frequency difference equal to 0.6. Let x_ij be the number of alternate allele count for sample i at SNP j with allele frequency p_j. Also let h_ij 1 denotype haplotype 1 of sample i at SNP j and h_ij 2 the second haplotype. Our simulation model is","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"h_ij 1 sim Bernoulli(p_j) quad h_ij 2 sim Bernoulli(p_j) quad x_ij = h_ij 1 + h_ij 2","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"which is equivalent to  ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"x_ij sim Binomial(2 p_j)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"for unphased data. The allele frequency is p_j = Uniform(0 1) for normally differentiated markers, and ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"p_pop1 j sim Uniform(0 04) quad p_pop2 j = p_pop1 j + 06","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"for abnormally differentiated markers. Each sample is randomly assigned to population 1 or 2. ","category":"page"},{"location":"man/hmm/hmm/#Sibling-pairs","page":"HMM Knockoffs","title":"Sibling pairs","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Based on the simulated data above, we can randomly sample pairs of individuals and have them produce offspring. Here, half of all offsprings will be siblings with the other half. This is done by first randomly sampling 2 person to represent parent. Assume they have 2 children. Then generate offspring individuals by copying segments of one parent haplotype directly to the corresponding haplotype of the offspring. This recombination event will produce IBD segments. The number of recombination is 1 or 2 per chromosome, and is chosen uniformly across the chromosome. ","category":"page"},{"location":"man/hmm/hmm/#Step-0:-simulate-genotypes","page":"HMM Knockoffs","title":"Step 0: simulate genotypes","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Load Julia packages needed for this tutorial","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"using SnpArrays\nusing Knockoffs\nusing DelimitedFiles\nusing Random\nusing LinearAlgebra\nusing Distributions\nusing ProgressMeter\nusing MendelIHT\nusing VCFTools\nusing StatsBase\nusing CodecZlib","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Load helper functions needed for this tutorial (data simulation + some glue code). It is not crucial to understand what they are doing.  ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"\"\"\"\n    simulate_pop_structure(n, p)\n\nSimulate genotypes with K = 2 populations. 300 SNPs will have different allele \nfrequencies between the populations, where 50 of them will be causal\n\n# Inputs\n- `plinkfile`: Output plink file name. \n- `n`: Number of samples\n- `p`: Number of SNPs\n\n# Output\n- `x1`: n×p matrix of the 1st haplotype for each sample. Each row is a haplotype\n- `x2`: n×p matrix of the 2nd haplotype for each sample. `x = x1 + x2`\n- `populations`: Vector of length `n` indicating population membership for eachsample. \n- `diff_markers`: Indices of the differentially expressed alleles.\n\n# Reference\nhttps://www.nature.com/articles/nrg2813\n\"\"\"\nfunction simulate_pop_structure(n::Int, p::Int)\n    # first simulate genotypes treating all samples equally\n    x1 = BitMatrix(undef, n, p)\n    x2 = BitMatrix(undef, n, p)\n    pmeter = Progress(p, 0.1, \"Simulating genotypes...\")\n    @inbounds for j in 1:p\n        d = Bernoulli(rand())\n        for i in 1:n\n            x1[i, j] = rand(d)\n            x2[i, j] = rand(d)\n        end\n        next!(pmeter)\n    end\n    # assign populations and simulate 300 unually differentiated markers\n    populations = rand(1:2, n)\n    diff_markers = sample(1:p, 300, replace=false)\n    @inbounds for j in diff_markers\n        pop1_allele_freq = 0.4rand()\n        pop2_allele_freq = pop1_allele_freq + 0.6\n        pop1_dist = Bernoulli(pop1_allele_freq)\n        pop2_dist = Bernoulli(pop2_allele_freq)\n        for i in 1:n\n            d = isone(populations[i]) ? pop1_dist : pop2_dist\n            x1[i, j] = rand(d)\n            x2[i, j] = rand(d)\n        end\n    end\n    return x1, x2, populations, diff_markers\nend\n\n\"\"\"\n    simulate_IBD(h1::BitMatrix, h2::BitMatrix, k::Int)\n\nSimulate recombination events. Parent haplotypes `h1` and `h2` will be used to generate \n`k` children, then both parent and children haplotypes will be returned. \n\nIn offspring simulation, half of all offsprings will be siblings with the other half.\nThis is done by first randomly sampling 2 samples from to represent parent. Assume they have\n2 children. Then generate offspring individuals by copying segments of the parents haplotype\ndirectly to the offspring to represent IBD segments. The number of segments (i.e. places of\nrecombination) is 1 or 2 per chromosome, and is chosen uniformly across the chromosome. \n\n# Inputs\n- `h1`: `n × p` matrix of the 1st haplotype for each parent. Each row is a haplotype\n- `h2`: `n × p` matrix of the 2nd haplotype for each parent. `H = h1 + h2`\n- `k`: Total number of offsprings\n\n# Output\n- `H1`: `n+k × p` matrix of the 1st haplotype. The first `n` haplotypes are from parents\n    and the next `k` haplotypes are the offsprings. Each row is a haplotype\n- `H2`: `n+k × p` matrix of the 2nd haplotype. `x = x1 + x2`\n\n# References\nhttps://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1003520\n\"\"\"\nfunction simulate_IBD(h1::BitMatrix, h2::BitMatrix, k::Int)\n    n, p = size(h1)\n    iseven(k) || error(\"number of offsprings should be even\")\n    # randomly designate gender for parents\n    sex = bitrand(n)\n    male_idx = findall(x -> x == true, sex)\n    female_idx = findall(x -> x == false, sex)\n    # simulate new samples\n    x1 = falses(k, p)\n    x2 = falses(k, p)\n    fathers = Int[]\n    mothers = Int[]\n    pmeter = Progress(k, 0.1, \"Simulating IBD segments...\")\n    for i in 1:k\n        # assign parents\n        dad = rand(male_idx)\n        mom = rand(female_idx)\n        push!(fathers, dad)\n        push!(mothers, mom)\n        # recombination\n        recombine!(@view(x1[i, :]), @view(x2[i, :]), @view(h1[dad, :]),\n                   @view(h2[dad, :]), @view(h1[mom, :]), @view(h2[mom, :]))\n        # update progress\n        next!(pmeter)\n    end\n    # combine offsprings and parents\n    H1 = [h1; x1]\n    H2 = [h2; x2]\n    return H1, H2, fathers, mothers\nend\n\nfunction recombination_segments(breakpoints::Vector{Int}, snps::Int)\n    start = 1\n    result = UnitRange{Int}[]\n    for bkpt in breakpoints\n        push!(result, start:bkpt)\n        start = bkpt + 1\n    end\n    push!(result, breakpoints[end]+1:snps)\n    return result\nend\n\nfunction recombine!(child_h1, child_h2, dad_h1, dad_h2, mom_h1, mom_h2)\n    p = length(child_h1)\n    recombinations = rand(1:5)\n    breakpoints = sort!(sample(1:p, recombinations, replace=false))\n    segments = recombination_segments(breakpoints, p)\n    for segment in segments\n        dad_hap = rand() < 0.5 ? dad_h1 : dad_h2\n        mom_hap = rand() < 0.5 ? mom_h1 : mom_h2\n        copyto!(@view(child_h1[segment]), @view(dad_hap[segment]))\n        copyto!(@view(child_h2[segment]), @view(mom_hap[segment]))\n    end\nend\n\nfunction write_plink(outfile::AbstractString, x1::AbstractMatrix, x2::AbstractMatrix)\n    n, p = size(x1)\n    x = SnpArray(outfile * \".bed\", n, p)\n    for j in 1:p, i in 1:n\n        c = x1[i, j] + x2[i, j]\n        if c == 0\n            x[i, j] = 0x00\n        elseif c == 1\n            x[i, j] = 0x02\n        elseif c == 2\n            x[i, j] = 0x03\n        else\n            error(\"matrix entries should be 0, 1, or 2 but was $c!\")\n        end\n    end\n    # create .bim file structure: https://www.cog-genomics.org/plink2/formats#bim\n    open(outfile * \".bim\", \"w\") do f\n        for i in 1:p\n            println(f, \"1\\tsnp$i\\t0\\t$(100i)\\t1\\t2\")\n        end\n    end\n    # create .fam file structure: https://www.cog-genomics.org/plink2/formats#fam\n    open(outfile * \".fam\", \"w\") do f\n        for i in 1:n\n            println(f, \"$i\\t1\\t0\\t0\\t1\\t-9\")\n        end\n    end\n    return nothing\nend\n\nfunction make_partition_mapfile(filename, p::Int)\n    map_cM = LinRange(0.0, Int(p / 10000), p)\n    open(filename, \"w\") do io\n        println(io, \"Chromosome\\tPosition(bp)\\tRate(cM/Mb)\\tMap(cM)\")\n        for i in 1:p\n            println(io, \"chr1\\t\", 100i, '\\t', 0.01rand(), '\\t', map_cM[i])\n        end\n    end\nend\n\nfunction make_rapid_mapfile(filename, p::Int)\n    map_cM = LinRange(0.0, Int(p / 10000), p)\n    open(filename, \"w\") do io\n        for i in 1:p\n            println(io, i, '\\t', map_cM[i])\n        end\n    end\nend\n\nfunction process_rapid_output(inputfile, outputfile)\n    writer = open(outputfile, \"w\")\n    df = readdlm(inputfile)\n    println(writer, \"CHR ID1 HID1 ID2 HID2 BP.start BP.end site.start site.end cM FAM1 FAM2\")\n    for r in eachrow(df)\n        chr, id1, id2, hap1, hap2, start_pos, end_pos, genetic_len, start_site, end_site = \n            Int(r[1]), Int(r[2]), Int(r[3]), Int(r[4]), Int(r[5]), Int(r[6]), Int(r[7]),\n            r[8], Int(r[9]), Int(r[10])\n        println(writer, chr, ' ', id1, ' ', hap1, ' ', id2, ' ', hap2, ' ', \n            start_pos, ' ', end_pos, ' ', start_site, ' ', end_site, ' ', \n            genetic_len, ' ', 1, ' ', 1)\n    end\n    close(writer)\nend\n\nfunction make_bgen_samplefile(filename, n)\n    open(filename, \"w\") do io\n        println(io, \"ID_1 ID_2 missing sex\")\n        println(io, \"0 0 0 D\")\n        for i in 1:n\n            println(io, \"$i 1 0 1\")\n        end\n    end \nend","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"make_bgen_samplefile (generic function with 1 method)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Simulate phased data with 2 populations, 49700 usually differentiated markers, and 300 unusually differentiated markers. Then simulate mating, which generates IBD segments. Finally, make unphased data from offspring haplotypes. ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# simulate phased genotypes\nRandom.seed!(2021)\noutfile = \"sim\"\nn = 2000\np = 50000\nh1, h2, populations, diff_markers = simulate_pop_structure(n, p)\n\n# simulate random mating to get IBD segments\noffsprings = 100\nx1, x2 = simulate_IBD(h1, h2, offsprings)\n\n# write phased genotypes to VCF format\nwrite_vcf(\"sim.phased.vcf.gz\", x1, x2)\n\n# write unphased genotypes to PLINK binary format\nwrite_plink(outfile, x1, x2)\n\n# save pop1/pop2 index and unually differentiated marker indices\nwritedlm(\"populations.txt\", populations)\nwritedlm(\"diff_markers.txt\", diff_markers)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"\u001b[32mSimulating genotypes...100%|████████████████████████████| Time: 0:00:01\u001b[39m\n\u001b[32mWriting VCF...100%|█████████████████████████████████████| Time: 0:00:24\u001b[39m","category":"page"},{"location":"man/hmm/hmm/#Step-1:-Partitions","page":"HMM Knockoffs","title":"Step 1: Partitions","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"We need","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Map file (in particular the (cM) field will determine group resolution)\nPLINK's bim file\nQC file (all SNP names that pass QC)\noutput file name","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Since data is simulated, there are no genomic map file. Let us generate a fake one. ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# generate fake map file\nmake_partition_mapfile(\"sim.partition.map\", p)\n\n# also generate QC file that contains all SNPs and all samples\nsnpdata = SnpData(\"sim\")\nsnpIDs = snpdata.snp_info[!, :snpid]\nsampleIDs = Matrix(snpdata.person_info[!, 1:2])\nwritedlm(\"variants_qc.txt\", snpIDs)\nwritedlm(\"samples_qc.txt\", sampleIDs)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Now we run the partition script","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"plinkfile = \"sim\"\nmapfile = \"sim.partition.map\"\nqc_variants = \"variants_qc.txt\"\noutfile = \"sim.partition.txt\"\npartition(partition_exe, plinkfile, mapfile, qc_variants, outfile)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Mean group sizes: \n      res_7       res_6       res_5       res_4       res_3       res_2 \n    1.00000    67.75068   349.65035   694.44444  1351.35135  3333.33333 \n      res_1 \n10000.00000 \nPartitions written to: sim.partition.txt\n\n\n\n\n\nProcess(`\u001b[4mRscript\u001b[24m \u001b[4m--vanilla\u001b[24m \u001b[4m/scratch/users/bbchu/knockoffgwas/knockoffgwas/utils/partition.R\u001b[24m \u001b[4msim.partition.map\u001b[24m \u001b[4msim.bim\u001b[24m \u001b[4mvariants_qc.txt\u001b[24m \u001b[4msim.partition.txt\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/hmm/hmm/#Step-2:-Generate-Knockoffs","page":"HMM Knockoffs","title":"Step 2: Generate Knockoffs","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"First generate IBD segment files. We need to generate RaPID's required map file","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"make_rapid_mapfile(\"sim.rapid.map\", p)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Next we run the RaPID software","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"vcffile = \"sim.phased.vcf.gz\"\nmapfile = \"sim.rapid.map\"\noutfolder = \"rapid\"\nd = 3    # minimum IBD length in cM\nw = 3    # number of SNPs per window\nr = 10   # number of runs\ns = 2    # Minimum number of successes to consider a hit\n@time rapid(rapid_exe, vcffile, mapfile, d, outfolder, w, r, s)\n\n# unzip output file\nrun(pipeline(`gunzip -c ./rapid/results.max.gz`, stdout=\"./rapid/results.max\"))","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"┌ Info: RaPID command:\n│ `/scratch/users/bbchu/RaPID/RaPID_v.1.7 -i sim.phased.vcf.gz -g sim.rapid.map -d 3 -o rapid -w 3 -r 10 -s 2`\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:55\n┌ Info: Output directory: rapid\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:56\n\n\nCreate sub-samples..\nDone!\n 43.120301 seconds (3.04 k allocations: 159.828 KiB)\n\n\n\n\n\nProcess(`\u001b[4mgunzip\u001b[24m \u001b[4m-c\u001b[24m \u001b[4m./rapid/results.max.gz\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"countlines(\"./rapid/results.max\") # d = 3, w = 3, r = 10, s = 9","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"140","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Here we identified 140 IBD segments. Because we only simulated 100 offsprings, and all 2000 parents are unrelated, the \"IBD related families\" are small. When there are too many segments, one might have to prune the IBD segments so that the families are not too connected. See this issue for details. ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"where the column format is: ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"<chr_name> <sample_id1> <sample_id2> <hap_id1> <hap_id2> <starting_pos_genomic> <ending_pos_genomic> <genetic_length> <starting_site> <ending_site>","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Then we need to do some postprocessing to this output, as described here. ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"process_rapid_output(\"./rapid/results.max\", \"sim.snpknock.ibdmap\")","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"The output looks like follows. The last 5 columns (site.start site.end cM FAM1 FAM2) are not actually currently used. They need to be there (the file should have 12 fields in total), but it doesn't matter what values you put in them.","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":";head sim.snpknock.ibdmap","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"CHR ID1 HID1 ID2 HID2 BP.start BP.end site.start site.end cM FAM1 FAM2\n1 29 0 2053 0 100 5000000 0 49999 4.9999 1 1\n1 64 0 2003 1 100 4712700 0 47126 4.71259 1 1\n1 97 1 2051 0 100 5000000 0 49999 4.9999 1 1\n1 99 1 2017 0 967300 5000000 9672 49999 4.03278 1 1\n1 106 1 2024 1 100 4078800 0 40787 4.07868 1 1\n1 151 1 2009 0 100 5000000 0 49999 4.9999 1 1\n1 155 1 2069 0 100 5000000 0 49999 4.9999 1 1\n1 163 1 2073 1 100 3309000 0 33089 3.30887 1 1\n1 231 1 2080 1 1153000 5000000 11529 49999 3.84708 1 1","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Next convert VCF file to BGEN format (note: sample file must be saved separately)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"# convert VCF to BGEN format\noutfile = \"sim.bgen\"\nrun(`$qctools_exe -g $vcffile -og $outfile`)\n\n# then save sample file separately\nmake_bgen_samplefile(\"sim.sample\", n + offsprings)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Welcome to qctool\n(version: 2.0.7, revision )\n\n(C) 2009-2017 University of Oxford\n\nOpening genotype files                                      : [******************************] (1/1,0.0s,32.2/s)\n========================================================================\n\nInput SAMPLE file(s):         Output SAMPLE file:             \"(n/a)\".\nSample exclusion output file:   \"(n/a)\".\n\nInput GEN file(s):\n                                                    (not computed)  \"sim.phased.vcf.gz\"\n                                         (total 1 sources, number of snps not computed).\n                      Number of samples: 2100\nOutput GEN file(s):             \"sim.bgen\"\nOutput SNP position file(s):    (n/a)\nSample filter:                  .\n# of samples in input files:    2100.\n# of samples after filtering:   2100 (0 filtered out).\n\n========================================================================\n\nProcessing SNPs                                             :  (50000/?,169.4s,295.2/s)60.3s,275.2/s)\nTotal: 50000SNPs.\n========================================================================\n\nNumber of SNPs:\n                     -- in input file(s):                 (not computed).\n -- in output file(s):                50000\n\nNumber of samples in input file(s):   2100.\n\nOutput GEN files:                     (50000  snps)  \"sim.bgen\"\n                                      (total 50000 snps).\n========================================================================\n\n\nThank you for using qctool.","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Finally, generate HMM knockoffs by running the following code in the command line directly. You may need to adjust file directories and change parameters. ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"bgenfile = \"sim\"\nsample_qc = \"samples_qc.txt\"\nvariant_qc = \"variants_qc.txt\"\nmapfile = \"sim.partition.map\"\npartfile = \"sim.partition.txt\"\nibdfile = \"sim.snpknock.ibdmap\"\nK = 10\ncluster_size_min = 1000 \ncluster_size_max = 10000 \nhmm_rho = 1\nhmm_lambda = 1e-3 \nwindows = 0\nn_threads = 1\nseed = 2021\ncompute_references = true\ngenerate_knockoffs = true\noutfile = \"sim.knockoffs\"\n\n@time snpknock2(snpknock2_exe, bgenfile, sample_qc, variant_qc, mapfile, partfile, ibdfile, \n    K, cluster_size_min, cluster_size_max, hmm_rho, hmm_lambda, windows, n_threads, \n    seed, compute_references, generate_knockoffs, outfile)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"\t+----------------------+\n\t|                      |\n\t|  SNPKNOCK2, v0.3     |\n\t|  July 21, 2020       |\n\t|  Matteo Sesia        |\n\t|                      |\n\t+----------------------+\n\nCopyright (C) 2020 Stanford University.\nDistributed under the GNU GPLv3 open source license.\n\nUse --help for more information.\n\nCommand line arguments:\n  --bgen sim\n  --keep samples_qc.txt\n  --extract variants_qc.txt\n  --map sim.partition.map\n  --part sim.partition.txt\n  --ibd sim.snpknock.ibdmap\n  --K 10\n  --cluster_size_min 1000\n  --cluster_size_max 10000\n  --hmm-rho 1\n  --hmm-lambda 0.001\n  --windows 0\n  --n_threads 1\n  --seed 2021\n  --compute-references\n  --generate-knockoffs\n  --out ./knockoffs/sim.knockoffs\n\nRequested operations:\n  --compute-references\n  --generate_knockoffs\n\n\n\n┌ Info: snpknock2 command:\n│ `/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2 --bgen sim --keep samples_qc.txt --extract variants_qc.txt --map sim.partition.map --part sim.partition.txt --ibd sim.snpknock.ibdmap --K 10 --cluster_size_min 1000 --cluster_size_max 10000 --hmm-rho 1 --hmm-lambda 0.001 --windows 0 --n_threads 1 --seed 2021 --compute-references --generate-knockoffs --out ./knockoffs/sim.knockoffs`\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:100\n┌ Info: Output directory: /home/users/bbchu/hmm/knockoffs\n└ @ Knockoffs /home/users/bbchu/.julia/packages/Knockoffs/69ZxJ/src/hmm_wrapper.jl:101\n\n\n\n--------------------------------------------------------------------------------\nLoading metadata\n--------------------------------------------------------------------------------\nLoading sample information from:\n  sim.sample\nLoading legend from:\n  sim.bim\nLoading partitions from:\n  sim.partition.txt\nLoading IBD segments from:\n  sim.snpknock.ibdmap\nLoaded 140 IBD segments.\n\nPrinting summary of 1 windows:\n     0: 0--50000\nSummary of metadata for chromosome 1:\n  number of samples (after | before filtering) : 2100 | 2100\n  number of SNPs (after | before filtering)    : 50000 | 50000\n  number of variant partitions                 : 7\n  size of genomic windows                      : whole-chromosome\n  number of IBD segments                       : 140\n\n\n--------------------------------------------------------------------------------\nKinship (using only haplotype data)\n--------------------------------------------------------------------------------\nReached 1\nChromosome 1 will be loaded from:\n  haplotype file            : sim.bgen\n  sample file               : sim.sample\n  legend file               : sim.bim\n  thinning factor           : 10\n  sample filter file        : samples_qc.txt\n  variant filter file       : variants_qc.txt\n  number of SNPs            : 5000\n  number of haplotypes      : 4200\n\nReading BGEN file using 1 thread:\n|....................................................................................................|\n|====================================================================================================|\nSolving 1 bifurcating K-means problems using 1 threads.\n\nKinship clusters written to:\n  ./knockoffs/sim.knockoffs_clust.txt\n  ./knockoffs/sim.knockoffs.sample\n\nAssigning references for the whole chromosome using 1 threads: \n|....................................................................................................|\n|\n\n\nBifurcating K-means\nSmallest allowed cluster size: 1000\n step\t cluster\t    size\t    left\t   right\taccepted\nBifurcating K-means completed after 0 steps.\nNumber of clusters: 1.\n\n\n\n====================================================================================================|\n\nReached 2\nIndividual global references written to:\n  ./knockoffs/sim.knockoffs_lref.txt\n\nIndividual local references written to:\n  ./knockoffs/sim.knockoffs_ref.txt\n\n\n--------------------------------------------------------------------------------\nKnockoffs for chromosome 1\n--------------------------------------------------------------------------------\nChromosome 1 will be loaded from:\n  haplotype file            : sim\n  haplotype file format     : bgen\n  sample file               : sim.sample\n  legend file               : sim.bim\n  map file                  : sim.partition.map\n  sample filter file        : samples_qc.txt\n  variant filter file       : variants_qc.txt\n  number of SNPs            : 50000\n  number of windows         : 1\n  number of haplotypes      : 4200\n\nLoading data for chromosome 1\nReading BGEN file using 1 thread:\n|....................................................................................................|\n|====================================================================================================|\n\nInitializing HMM with user-supplied hyperparameters: rho = 1, lambda = 0.001.\n\nHMM parameters written to:\n  ./knockoffs/sim.knockoffs_hmm.txt\n\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res0_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res0_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 50000 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 50000 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res0.bed\n  ./knockoffs/sim.knockoffs_res0.bim\n  ./knockoffs/sim.knockoffs_res0.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res0_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res1_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res1_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 738 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 738 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res1.bed\n  ./knockoffs/sim.knockoffs_res1.bim\n  ./knockoffs/sim.knockoffs_res1.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res1_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res2_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res2_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 143 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 143 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res2.bed\n  ./knockoffs/sim.knockoffs_res2.bim\n  ./knockoffs/sim.knockoffs_res2.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res2_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res3_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res3_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 72 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 72 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res3.bed\n  ./knockoffs/sim.knockoffs_res3.bim\n  ./knockoffs/sim.knockoffs_res3.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res3_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res4_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res4_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 37 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 37 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res4.bed\n  ./knockoffs/sim.knockoffs_res4.bim\n  ./knockoffs/sim.knockoffs_res4.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res4_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res5_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res5_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 15 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 15 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res5.bed\n  ./knockoffs/sim.knockoffs_res5.bim\n  ./knockoffs/sim.knockoffs_res5.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res5_anc.txt\nSNP groups written to:\n  ./knockoffs/sim.knockoffs_res6_grp.txt\nSNP windows written to:\n  ./knockoffs/sim.knockoffs_res6_windows.txt\n\nGenerating related knockoffs for chromosome 1 (279 haplotypes in 139 families, 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\nGenerating unrelated knockoffs for chromosome 1 (3921 haplotypes; 50000 variants in 5 groups):\n|....................................................................................................|\n|====================================================================================================|\n\n\nOutput (binary) written to:\n  ./knockoffs/sim.knockoffs_res6.bed\n  ./knockoffs/sim.knockoffs_res6.bim\n  ./knockoffs/sim.knockoffs_res6.fam\nReconstructed ancestries written to:\n  ./knockoffs/sim.knockoffs_res6_anc.txt\n\nFinished.\n\n1484.517148 seconds (409.38 k allocations: 24.636 MiB, 0.01% compilation time)\n\n\n\n\n\nProcess(`\u001b[4m/scratch/users/bbchu/knockoffgwas/snpknock2/bin/snpknock2\u001b[24m \u001b[4m--bgen\u001b[24m \u001b[4msim\u001b[24m \u001b[4m--keep\u001b[24m \u001b[4msamples_qc.txt\u001b[24m \u001b[4m--extract\u001b[24m \u001b[4mvariants_qc.txt\u001b[24m \u001b[4m--map\u001b[24m \u001b[4msim.partition.map\u001b[24m \u001b[4m--part\u001b[24m \u001b[4msim.partition.txt\u001b[24m \u001b[4m--ibd\u001b[24m \u001b[4msim.snpknock.ibdmap\u001b[24m \u001b[4m--K\u001b[24m \u001b[4m10\u001b[24m \u001b[4m--cluster_size_min\u001b[24m \u001b[4m1000\u001b[24m \u001b[4m--cluster_size_max\u001b[24m \u001b[4m10000\u001b[24m \u001b[4m--hmm-rho\u001b[24m \u001b[4m1\u001b[24m \u001b[4m--hmm-lambda\u001b[24m \u001b[4m0.001\u001b[24m \u001b[4m--windows\u001b[24m \u001b[4m0\u001b[24m \u001b[4m--n_threads\u001b[24m \u001b[4m1\u001b[24m \u001b[4m--seed\u001b[24m \u001b[4m2021\u001b[24m \u001b[4m--compute-references\u001b[24m \u001b[4m--generate-knockoffs\u001b[24m \u001b[4m--out\u001b[24m \u001b[4m./knockoffs/sim.knockoffs\u001b[24m`, ProcessExited(0))","category":"page"},{"location":"man/hmm/hmm/#Step-3:-Examine-Generated-Knockoffs","page":"HMM Knockoffs","title":"Step 3: Examine Generated Knockoffs","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"The generated knockoffs are saved in binary PLINK format, we can import it using SnpArrays","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"x = SnpArray(\"knockoffs/sim.knockoffs_res0.bed\")","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"2100×100000 SnpArray:\n 0x03  0x03  0x02  0x02  0x03  0x03  …  0x02  0x02  0x02  0x03  0x03  0x03\n 0x02  0x02  0x03  0x03  0x00  0x02     0x02  0x02  0x03  0x03  0x02  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x00  0x03  0x02  0x02  0x02  0x02     0x03  0x02  0x03  0x03  0x03  0x03\n 0x03  0x03  0x00  0x00  0x03  0x02     0x02  0x02  0x03  0x03  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x02  …  0x03  0x03  0x03  0x02  0x03  0x03\n 0x02  0x00  0x00  0x00  0x02  0x02     0x03  0x00  0x02  0x02  0x03  0x03\n 0x02  0x02  0x02  0x02  0x00  0x02     0x02  0x02  0x02  0x03  0x03  0x03\n 0x02  0x03  0x02  0x02  0x03  0x03     0x02  0x02  0x02  0x00  0x03  0x03\n 0x02  0x02  0x02  0x02  0x02  0x00     0x02  0x02  0x02  0x02  0x03  0x03\n 0x03  0x00  0x02  0x03  0x02  0x03  …  0x02  0x02  0x02  0x02  0x03  0x03\n 0x00  0x03  0x03  0x02  0x02  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x02  0x02  0x03  0x03  0x03  0x03     0x00  0x02  0x02  0x02  0x03  0x03\n    ⋮                             ⋮  ⋱           ⋮                    \n 0x00  0x00  0x03  0x03  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x00  0x02  0x03  0x03  0x02  0x02     0x03  0x03  0x03  0x03  0x03  0x03\n 0x00  0x02  0x03  0x03  0x02  0x02  …  0x00  0x00  0x02  0x00  0x03  0x03\n 0x00  0x00  0x02  0x02  0x03  0x03     0x02  0x02  0x03  0x03  0x03  0x03\n 0x00  0x02  0x03  0x03  0x02  0x02     0x00  0x00  0x02  0x02  0x03  0x03\n 0x00  0x00  0x02  0x02  0x03  0x02     0x03  0x03  0x02  0x02  0x03  0x03\n 0x02  0x03  0x02  0x00  0x03  0x02     0x03  0x03  0x00  0x00  0x03  0x03\n 0x03  0x02  0x03  0x00  0x03  0x03  …  0x02  0x02  0x02  0x02  0x03  0x03\n 0x03  0x03  0x02  0x02  0x03  0x03     0x02  0x02  0x03  0x03  0x02  0x02\n 0x03  0x00  0x00  0x00  0x02  0x02     0x02  0x02  0x03  0x03  0x03  0x03\n 0x00  0x03  0x03  0x02  0x02  0x02     0x00  0x00  0x00  0x00  0x03  0x03\n 0x02  0x00  0x00  0x00  0x02  0x02     0x02  0x02  0x02  0x02  0x03  0x03","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Notice there are 100k SNPs: the original 50k SNPs and their knockoffs. Reading the SNP names will tell us which are the originals:","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"snpid = SnpData(\"knockoffs/sim.knockoffs_res0\").snp_info.snpid","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"100000-element Vector{String}:\n \"snp1.k\"\n \"snp1\"\n \"snp2\"\n \"snp2.k\"\n \"snp3.k\"\n \"snp3\"\n \"snp4.k\"\n \"snp4\"\n \"snp5.k\"\n \"snp5\"\n \"snp6\"\n \"snp6.k\"\n \"snp7\"\n ⋮\n \"snp49995\"\n \"snp49995.k\"\n \"snp49996.k\"\n \"snp49996\"\n \"snp49997.k\"\n \"snp49997\"\n \"snp49998.k\"\n \"snp49998\"\n \"snp49999\"\n \"snp49999.k\"\n \"snp50000.k\"\n \"snp50000\"","category":"page"},{"location":"man/hmm/hmm/#Step-4:-Model-selection-with-knockoffs","page":"HMM Knockoffs","title":"Step 4: Model selection with knockoffs","text":"","category":"section"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"Tutorial for this part coming soon! Basically, one constructs a SnpLinAlg, feed that into MendelIHT.jl, and calculate knockoff statistics afterwards using built-in functions like coefficient_diff and threshold.","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"SnpLinAlg performs compressed linear algebra (often faster than double precision BLAS)\nMendelIHT.jl is a very efficient implementation of the iterative hard thresholding algorithm. For model selection, IHT is known to be superior to standard LASSO, elastic net, and MCP solvers. ","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"xla = SnpLinAlg{Float64}(x, center=true, scale=true, impute=true)","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"2100×100000 SnpLinAlg{Float64}:\n  1.76602    1.68237   -0.311698  …   1.20757    0.0817861   0.12776\n  0.316766   0.246784   1.13646       1.20757  -12.1861      0.12776\n  0.316766   0.246784  -0.311698     -0.22433    0.0817861   0.12776\n -1.13249    1.68237   -0.311698      1.20757    0.0817861   0.12776\n  1.76602    1.68237   -1.75985       1.20757    0.0817861   0.12776\n  0.316766   0.246784  -0.311698  …  -0.22433    0.0817861   0.12776\n  0.316766  -1.1888    -1.75985      -0.22433    0.0817861   0.12776\n  0.316766   0.246784  -0.311698      1.20757    0.0817861   0.12776\n  0.316766   1.68237   -0.311698     -1.65623    0.0817861   0.12776\n  0.316766   0.246784  -0.311698     -0.22433    0.0817861   0.12776\n  1.76602   -1.1888    -0.311698  …  -0.22433    0.0817861   0.12776\n -1.13249    1.68237    1.13646      -0.22433    0.0817861   0.12776\n  0.316766   0.246784   1.13646      -0.22433    0.0817861   0.12776\n  ⋮                               ⋱                         \n -1.13249   -1.1888     1.13646       1.20757    0.0817861   0.12776\n -1.13249    0.246784   1.13646       1.20757    0.0817861   0.12776\n -1.13249    0.246784   1.13646   …  -1.65623    0.0817861   0.12776\n -1.13249   -1.1888    -0.311698      1.20757    0.0817861   0.12776\n -1.13249    0.246784   1.13646      -0.22433    0.0817861   0.12776\n -1.13249   -1.1888    -0.311698     -0.22433    0.0817861   0.12776\n  0.316766   1.68237   -0.311698     -1.65623    0.0817861   0.12776\n  1.76602    0.246784   1.13646   …  -0.22433    0.0817861   0.12776\n  1.76602    1.68237   -0.311698      1.20757  -12.1861     -7.7633\n  1.76602   -1.1888    -1.75985       1.20757    0.0817861   0.12776\n -1.13249    1.68237    1.13646      -1.65623    0.0817861   0.12776\n  0.316766  -1.1888    -1.75985      -0.22433    0.0817861   0.12776","category":"page"},{"location":"man/hmm/hmm/","page":"HMM Knockoffs","title":"HMM Knockoffs","text":"","category":"page"},{"location":"#Knockoffs.jl","page":"Home","title":"Knockoffs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a Julia implementation of the knockoff filter. The knockoff filter is a general framework for controlling the false discovery rate when performing variable selection. As the name suggests, the knockoff filter operates by manufacturing knockoff variables that are cheap — their construction does not require collecting any new data — and are designed to mimic the correlation structure found within the original variables. The knockoffs serve as negative controls and they allow one to identify the truly important predictors, while controlling the false discovery rate (FDR) — the expected fraction of false discoveries among all discoveries.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Within Julia,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Knockoffs\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package supports Julia v1.8+.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/fixed/fixed.md\",\n    \"man/modelX/modelX.md\",\n    \"man/group.md\",\n    \"man/knockoffscreen/knockoffscreen.md\",\n    \"man/ghost_knockoffs.md\",\n    \"man/hmm/hmm.md\",\n    \"man/ipad.md\",\n    \"man/JuliaCall.md\",\n    \"man/api.md\"\n]\nDepth = 2","category":"page"}]
}
